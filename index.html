<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Squash & Stretch Physics Demo</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            font-family: system-ui, -apple-system, sans-serif;
            color: #fff;
            overflow: hidden;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .canvas-container {
            flex: 1;
            position: relative;
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
            border: 2px solid #333;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(100, 150, 255, 0.3);
            image-rendering: -webkit-optimize-contrast;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        .controls {
            width: 300px;
            background: rgba(20, 20, 30, 0.9);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #333;
            max-height: 90vh;
            overflow-y: auto;
        }
        h2 {
            margin: 0 0 20px 0;
            color: #667eea;
            font-size: 20px;
        }
        .info {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 12px;
            color: #93c5fd;
        }
        label {
            display: block;
            margin: 15px 0 5px 0;
            font-size: 13px;
            color: #aaa;
        }
        input[type="range"] {
            width: 100%;
        }
        .value-display {
            float: right;
            color: #667eea;
            font-weight: 600;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            width: 100%;
            margin: 5px 0;
            transition: transform 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        .checkbox-container input[type="checkbox"] {
            width: auto;
            margin-right: 10px;
        }
        .instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
            transition: opacity 0.3s, visibility 0.3s;
        }
        
        .instructions.hidden {
            opacity: 0;
            visibility: hidden;
        }
        .key {
            display: inline-block;
            background: #667eea;
            padding: 2px 8px;
            border-radius: 4px;
            margin: 0 2px;
            font-weight: 600;
        }
        
        .health-bar-container {
            position: absolute;
            bottom: 40px;
            right: 40px;
            z-index: 10;
            background: transparent;
        }
        
        .health-bar-circular {
            position: relative;
            width: 150px;
            height: 150px;
            background: transparent;
        }
        
        .health-bar-circular canvas {
            display: block;
            background: transparent !important;
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
        }
        
        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
        }
        
        .health-value {
            font-size: 32px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px rgba(102, 126, 234, 0.8);
        }
        
        .health-label {
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .dash-indicator {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
            transition: background 0.2s, box-shadow 0.2s;
        }
        
        .dash-indicator.cooldown {
            background: #ff0000;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
        }
        .multiplayer-ui {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(20, 20, 30, 0.95);
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #667eea;
            display: block;
            transition: opacity 0.3s, visibility 0.3s;
        }
        
        .multiplayer-ui.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        
        .multiplayer-ui h3 {
            margin: 0 0 15px 0;
            color: #667eea;
            font-size: 18px;
        }
        
        .multiplayer-ui button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin: 5px;
            transition: transform 0.2s;
        }
        
        .multiplayer-ui button:hover {
            transform: translateY(-2px);
        }
        
        .multiplayer-ui input {
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            margin: 5px;
            width: 200px;
        }
        
        .room-id-display {
            margin: 10px 0;
            padding: 10px;
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 4px;
            font-family: monospace;
            font-size: 16px;
            color: #667eea;
        }
        
        .player-list {
            margin-top: 15px;
            font-size: 12px;
            color: #aaa;
        }
        
        .player-list-item {
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .connection-status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            background: #ff0000;
        }
        
        .connection-status.connected {
            background: #00ff00;
        }
        
        .color-picker-widget {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 20, 30, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #667eea;
            z-index: 100;
            transition: opacity 0.3s, visibility 0.3s;
        }
        
        .color-picker-widget.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        
        .color-picker-widget h4 {
            margin: 0 0 10px 0;
            color: #667eea;
            font-size: 14px;
        }
        
        .color-picker-widget input[type="color"] {
            width: 60px;
            height: 60px;
            border: 2px solid #667eea;
            border-radius: 8px;
            cursor: pointer;
            background: none;
        }
        
        .color-picker-widget label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-top: 8px;
        }
        
        /* Custom scrollbar styling */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(20, 20, 30, 0.5);
            border-radius: 4px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 4px;
            border: 1px solid rgba(102, 126, 234, 0.3);
        }
        
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }
        
        /* Firefox scrollbar */
        .custom-scrollbar {
            scrollbar-width: thin;
            scrollbar-color: #667eea rgba(20, 20, 30, 0.5);
        }
        
        /* Menu Widget - Small compact design */
        .menu-widget {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 200;
            background: rgba(20, 20, 30, 0.95);
            border-radius: 8px;
            border: 2px solid #667eea;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .menu-widget.collapsed {
            width: 280px;
        }
        
        .menu-widget.expanded {
            width: 280px;
            min-height: 200px;
        }
        
        .menu-toggle-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            width: 100%;
            transition: transform 0.2s;
        }
        
        .menu-toggle-button:hover {
            transform: translateY(-2px);
        }
        
        .menu-content {
            display: none;
            padding: 15px;
        }
        
        .menu-widget.expanded .menu-content {
            display: block;
        }
        
        .menu-screen {
            display: none;
        }
        
        .menu-screen.active {
            display: block;
        }
        
        .menu-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            width: 100%;
            margin: 6px 0;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .menu-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.4);
        }
        
        .menu-button:active {
            transform: translateY(0);
        }
        
        .menu-input {
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 13px;
            width: calc(100% - 24px);
            margin: 8px 0;
        }
        
        .menu-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 5px rgba(102, 126, 234, 0.3);
        }
        
        .menu-widget .room-id-display {
            margin: 10px 0;
            padding: 10px;
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            color: #667eea;
            text-align: center;
            word-break: break-all;
        }
        
        .menu-widget .player-list {
            margin: 10px 0;
            font-size: 11px;
            color: #aaa;
            max-height: 120px;
            overflow-y: auto;
        }
        
        .menu-widget .player-list-item {
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .menu-widget .connection-status {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            margin-right: 6px;
            background: #ff0000;
        }
        
        .menu-widget .connection-status.connected {
            background: #00ff00;
        }
        
        .menu-widget .controls-info {
            background: rgba(10, 10, 20, 0.5);
            padding: 12px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 12px;
            line-height: 1.6;
        }
        
        .menu-widget .controls-info .key {
            display: inline-block;
            background: #667eea;
            padding: 2px 6px;
            border-radius: 3px;
            margin: 0 2px;
            font-weight: 600;
            font-size: 11px;
        }
        
        .menu-widget .color-picker-container {
            text-align: center;
            margin: 15px 0;
        }
        
        .menu-widget .color-picker-container h4 {
            margin: 0 0 10px 0;
            color: #667eea;
            font-size: 14px;
        }
        
        .menu-widget .color-picker-container input[type="color"] {
            width: 60px;
            height: 60px;
            border: 2px solid #667eea;
            border-radius: 8px;
            cursor: pointer;
            background: none;
        }
        
        .menu-widget .color-picker-container label {
            display: block;
            font-size: 11px;
            color: #aaa;
            margin-top: 8px;
        }
        
        .menu-widget h3 {
            margin: 0 0 12px 0;
            color: #667eea;
            font-size: 16px;
        }
        
        .version-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            font-family: monospace;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="menu-widget collapsed" id="menuWidget">
        <button class="menu-toggle-button" onclick="toggleMenuWidget()">Menu</button>
        <div class="menu-content">
            <!-- Main Menu Screen -->
            <div class="menu-screen active" id="mainMenuScreen">
                <button class="menu-button" onclick="showMultiplayerMenu()">Multiplayer</button>
                <button class="menu-button" onclick="showTrainingMenu()">Training</button>
                <button class="menu-button" id="challengesButton" onclick="showChallengesMenu()" style="display: none;">Challenges</button>
                <button class="menu-button" onclick="showStatsMenu()">Stats</button>
                <button class="menu-button" onclick="showShopMenu()">Shop</button>
                <button class="menu-button" onclick="showControlsMenu()">Controls</button>
                <button class="menu-button" onclick="showCustomizeMenu()">Customize</button>
                <button class="menu-button" onclick="showSettingsMenu()">Settings</button>
                <button class="menu-button" onclick="goToDiscord()">Discord</button>
                <button class="menu-button" onclick="quitApp()">Quit</button>
            </div>
            
            <!-- Multiplayer Menu Screen -->
            <div class="menu-screen" id="multiplayerMenuScreen">
                <h3>Multiplayer</h3>
                <button class="menu-button" onclick="hostGame()">Host Game</button>
                <button class="menu-button" onclick="showJoinScreen()">Join Game</button>
                <button class="menu-button" onclick="showMainMenu()">Back</button>
            </div>
            
            <!-- Training Menu Screen -->
            <div class="menu-screen" id="trainingMenuScreen">
                <h3>Training</h3>
                <button class="menu-button" onclick="showTrainingSettings()">Training Settings</button>
                <button class="menu-button" onclick="showMainMenu()">Back</button>
            </div>
            
            <!-- Training Settings Screen -->
            <div class="menu-screen" id="trainingSettingsScreen">
                <h3>Training Settings</h3>
                <div style="margin: 20px 0;">
                    <label style="display: block; margin-bottom: 10px; color: #fff;">
                        Number of AIs: <span id="aiCountDisplay">2</span>
                    </label>
                    <input type="range" id="aiCountSlider" min="1" max="10" value="2" 
                           style="width: 100%; margin-bottom: 20px;"
                           oninput="updateTrainingSettings()">
                </div>
                <div style="margin: 20px 0;">
                    <label style="display: flex; align-items: center; color: #fff; margin-bottom: 20px;">
                        <input type="checkbox" id="friendlyFireCheckbox" 
                               style="margin-right: 10px; width: 20px; height: 20px;"
                               onchange="updateTrainingSettings()">
                        Friendly Fire
                    </label>
                </div>
                <div style="margin: 20px 0;">
                    <label style="display: block; margin-bottom: 10px; color: #fff;">
                        AI Speed: <span id="aiSpeedDisplay">60%</span>
                    </label>
                    <input type="range" id="aiSpeedSlider" min="30" max="100" value="60" step="10"
                           style="width: 100%; margin-bottom: 20px;"
                           oninput="updateTrainingSettings()">
                </div>
                <button class="menu-button" onclick="startTrainingWithSettings()">Start Training</button>
                <button class="menu-button" onclick="showTrainingMenu()">Back</button>
            </div>
            
            <!-- Join Game Screen -->
            <div class="menu-screen" id="joinGameScreen">
                <h3>Join Game</h3>
                <input type="text" class="menu-input" id="roomIdInput" placeholder="Enter Room ID">
                <button class="menu-button" onclick="joinGame()">Connect</button>
                <button class="menu-button" onclick="showMultiplayerMenu()">Back</button>
            </div>
            
            <!-- Game Screen (when in multiplayer) -->
            <div class="menu-screen" id="gameScreen">
                <h3>Multiplayer</h3>
                <div class="room-id-display" id="roomIdDisplay"></div>
                <div class="player-list" id="playerList"></div>
                <button class="menu-button" onclick="leaveGame()">Leave Game</button>
                <button class="menu-button" onclick="showMainMenu()">Back to Menu</button>
            </div>
            
            <!-- Controls Screen -->
            <div class="menu-screen" id="controlsScreen">
                <h3>Controls</h3>
                <div class="controls-info">
                    <div><strong>Movement:</strong></div>
                    <div><span class="key">W A S D</span> or <span class="key">Arrow Keys</span> - Move</div>
                    <div><span class="key">Space</span> or <span class="key">Double Click</span> - Dash</div>
                    <div><span class="key">Click</span> - Move to mouse</div>
                    <div style="margin-top: 10px;"><strong>Menu:</strong></div>
                    <div><span class="key">ESC</span> or <span class="key">P</span> - Toggle Menu</div>
                </div>
                <button class="menu-button" onclick="showMainMenu()">Back</button>
            </div>
            
            <!-- Customize Screen -->
            <div class="menu-screen" id="customizeScreen">
                <h3>Customize</h3>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; color: #aaa; font-size: 12px; margin-bottom: 5px;">Player Name</label>
                    <input type="text" class="menu-input" id="playerNameInput" placeholder="Enter your name" maxlength="20">
                </div>
                <div style="margin-bottom: 15px;">
                    <h4 style="color: #fff; font-size: 14px; margin-bottom: 10px;">Player Color</h4>
                    <div id="colorSelectionContainer" style="display: grid; grid-template-columns: repeat(3, 60px); gap: 10px; max-height: 300px; overflow-y: auto; overflow-x: hidden; padding-right: 5px;" class="custom-scrollbar">
                        <!-- Colors will be populated by JavaScript -->
                    </div>
                </div>
                <div style="margin-bottom: 15px;">
                    <h4 style="color: #fff; font-size: 14px; margin-bottom: 10px;">Aura</h4>
                    <div id="auraSelectionContainer" style="display: grid; grid-template-columns: repeat(3, 60px); gap: 10px; max-height: 300px; overflow-y: auto; overflow-x: hidden; padding-right: 5px;" class="custom-scrollbar">
                        <!-- Auras will be populated by JavaScript -->
                    </div>
                </div>
                <div style="margin-bottom: 15px;">
                    <h4 style="color: #fff; font-size: 14px; margin-bottom: 10px;">Particle Effects</h4>
                    <div id="particleSelectionContainer" style="display: grid; grid-template-columns: repeat(3, 60px); gap: 10px; max-height: 300px; overflow-y: auto; overflow-x: hidden; padding-right: 5px;" class="custom-scrollbar">
                        <!-- Particles will be populated by JavaScript -->
                    </div>
                </div>
                <button class="menu-button" onclick="showMainMenu()">Back</button>
            </div>
            
            <!-- Settings Screen -->
            <div class="menu-screen" id="settingsScreen">
                <h3>Settings</h3>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; color: #fff; font-size: 14px; margin-bottom: 8px; font-weight: 600;">Resolution</label>
                    <select id="resolutionSelect" class="menu-input" style="width: 100%; padding: 8px; background: rgba(102, 126, 234, 0.2); border: 1px solid rgba(102, 126, 234, 0.5); border-radius: 4px; color: #fff; font-size: 14px;">
                        <option value="1280x720">1280 x 720</option>
                        <option value="1920x1080" selected>1920 x 1080 (Recommended)</option>
                        <option value="2560x1440">2560 x 1440</option>
                        <option value="3840x2160">3840 x 2160 (4K)</option>
                    </select>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; color: #fff; font-size: 14px; margin-bottom: 8px; font-weight: 600;">Frame Rate Limit</label>
                    <select id="fpsSelect" class="menu-input" style="width: 100%; padding: 8px; background: rgba(102, 126, 234, 0.2); border: 1px solid rgba(102, 126, 234, 0.5); border-radius: 4px; color: #fff; font-size: 14px;">
                        <option value="30">30 FPS</option>
                        <option value="60" selected>60 FPS (Recommended)</option>
                        <option value="120">120 FPS</option>
                        <option value="144">144 FPS</option>
                        <option value="240">240 FPS</option>
                        <option value="0">Unlimited</option>
                    </select>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; color: #fff; font-size: 14px; margin-bottom: 8px; font-weight: 600;">Graphics Quality</label>
                    <select id="graphicsSelect" class="menu-input" style="width: 100%; padding: 8px; background: rgba(102, 126, 234, 0.2); border: 1px solid rgba(102, 126, 234, 0.5); border-radius: 4px; color: #fff; font-size: 14px;">
                        <option value="low">Low</option>
                        <option value="medium" selected>Medium (Recommended)</option>
                        <option value="high">High</option>
                        <option value="ultra">Ultra</option>
                    </select>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; color: #fff; font-size: 14px; margin-bottom: 8px; font-weight: 600;">Master Volume</label>
                    <input type="range" id="volumeSlider" min="0" max="100" value="100" style="width: 100%; margin-bottom: 5px;">
                    <div style="display: flex; justify-content: space-between; color: #aaa; font-size: 12px;">
                        <span>0%</span>
                        <span id="volumeDisplay">100%</span>
                        <span>100%</span>
                    </div>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; color: #fff; font-size: 14px; margin-bottom: 8px; font-weight: 600;">Show FPS Counter</label>
                    <input type="checkbox" id="showFPSCheckbox" style="width: 20px; height: 20px; cursor: pointer;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; color: #fff; font-size: 14px; margin-bottom: 8px; font-weight: 600;">VSync</label>
                    <input type="checkbox" id="vsyncCheckbox" checked style="width: 20px; height: 20px; cursor: pointer;">
                </div>
                <div style="margin-top: 20px; display: flex; gap: 10px;">
                    <button class="menu-button" onclick="applySettings()" style="flex: 1;">Apply Settings</button>
                    <button class="menu-button" onclick="resetSettings()" style="flex: 1;">Reset to Default</button>
                </div>
                <button class="menu-button" onclick="showMainMenu()" style="margin-top: 15px;">Back</button>
            </div>
            
            <!-- Shop Screen -->
            <div class="menu-screen" id="shopScreen">
                <h3>Shop</h3>
                <div style="margin-bottom: 15px; display: flex; gap: 15px; justify-content: center; align-items: center;">
                    <div style="background: rgba(102, 126, 234, 0.2); padding: 10px 15px; border-radius: 6px; border: 1px solid rgba(102, 126, 234, 0.5);">
                        <div style="color: #aaa; font-size: 11px; margin-bottom: 3px;">Orbs</div>
                        <div id="orbDisplay" style="color: #ffd700; font-size: 18px; font-weight: 600;">0</div>
                    </div>
                </div>
                <div style="margin-bottom: 15px;">
                    <button class="menu-button" onclick="showPurchaseOrbsMenu()" style="width: 100%; padding: 12px; font-size: 14px; background: rgba(255, 215, 0, 0.2); border: 2px solid #ffd700;">Add Orbs</button>
                </div>
                <div style="margin-bottom: 15px; display: flex; gap: 10px; justify-content: center;">
                    <button class="menu-button" id="shopCategoryColors" onclick="switchShopCategory('colors')" style="padding: 8px 15px; font-size: 12px; background: rgba(102, 126, 234, 0.3);">Colors</button>
                    <button class="menu-button" id="shopCategoryAuras" onclick="switchShopCategory('auras')" style="padding: 8px 15px; font-size: 12px;">Auras</button>
                    <button class="menu-button" id="shopCategoryParticles" onclick="switchShopCategory('particles')" style="padding: 8px 15px; font-size: 12px;">Particles</button>
                </div>
                <div id="shopItemsContainer" style="max-height: 400px; overflow-y: auto; overflow-x: hidden; padding-right: 5px;" class="custom-scrollbar">
                    <!-- Shop items will be populated by JavaScript -->
                </div>
                <button class="menu-button" onclick="showMainMenu()" style="margin-top: 15px;">Back</button>
            </div>
            
            <!-- VS Menu Screen -->
            <div class="menu-screen" id="vsMenuScreen">
                <h3>VS Matchmaking</h3>
                <div id="queueStatus" style="color: #aaa; font-size: 12px; margin-bottom: 10px; text-align: center;">Not in queue</div>
                <div id="rankingInfo" style="background: rgba(102, 126, 234, 0.1); padding: 10px; border-radius: 6px; margin-bottom: 10px; font-size: 11px; text-align: center;">
                    <div id="rankTierDisplay" style="font-weight: 600; margin-bottom: 3px;"></div>
                    <div id="rankRatingDisplay" style="color: #aaa;"></div>
                </div>
                <button class="menu-button" id="queue1v1Button" onclick="joinQueue('1v1')">1v1</button>
                <button class="menu-button" id="queue2v2Button" onclick="joinQueue('2v2')">2v2</button>
                <button class="menu-button" id="freeForAllButton" onclick="startFreeForAll()">FreeForAll</button>
                <button class="menu-button" id="cancelQueueButton" onclick="cancelQueue()" style="display: none;">Cancel Queue</button>
                <button class="menu-button" onclick="showMainMenu()">Back</button>
            </div>
            
            <!-- Stats Menu Screen -->
            <div class="menu-screen" id="statsMenuScreen">
                <h3>Player Stats</h3>
                <div id="statsDisplay" style="background: rgba(10, 10, 20, 0.5); padding: 15px; border-radius: 6px; margin-bottom: 10px; font-size: 12px; max-height: 400px; overflow-y: auto;">
                    <!-- Stats will be populated by JavaScript -->
                </div>
                <button class="menu-button" onclick="showMainMenu()">Back to Menu</button>
            </div>
            
            <!-- Challenges Menu Screen -->
            <div class="menu-screen" id="challengesMenuScreen">
                <h3>Challenges</h3>
                <button class="menu-button" onclick="startSpikeDodge()">Spike Dodge</button>
                <div style="color: #aaa; font-size: 11px; margin-top: 10px; text-align: center;">
                    Dodge falling spikes!<br>
                    They get faster and more numerous over time.<br><br>
                    <span style="color: #ffd700;">Best Score: <span id="spikeDodgeBestScoreDisplay">0</span></span>
                </div>
                <button class="menu-button" onclick="startDodgeMode()">Dodge Mode</button>
                <div style="color: #aaa; font-size: 11px; margin-top: 10px; text-align: center;">
                    Run away from AI Bombs!<br>
                    One touch = instant death!<br>
                    New bomb spawns every 10 seconds.<br>
                    Survive as long as you can!<br><br>
                    <span style="color: #ffd700;">Best Time: <span id="dodgeModeBestTimeDisplay">0s</span></span>
                </div>
                <button class="menu-button" onclick="startTargetBreak()">Break the Target</button>
                <div style="color: #aaa; font-size: 11px; margin-top: 10px; text-align: center;">
                    Break targets before time runs out!<br>
                    Timer: 2-5 seconds per target.<br>
                    Break as many as you can!<br><br>
                    <span style="color: #ffd700;">Best Score: <span id="targetBreakBestScoreDisplay">0</span></span>
                </div>
                <button class="menu-button" onclick="showMainMenu()">Back</button>
            </div>
        </div>
    </div>
    
    <div class="container">
        <div class="canvas-container">
            <canvas id="gameCanvas"></canvas>
            <div class="health-bar-container">
                <div id="healthBar"></div>
                <div id="dashIndicator" class="dash-indicator"></div>
            </div>
            <div class="version-info" id="versionInfo">v1.0.0</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Default values
        const DEFAULT_STRETCH_INTENSITY = 2;
        const DEFAULT_SQUASH_INTENSITY = 0.7;
        const DEFAULT_DEFORM_SPEED = 0.25;
        const DEFAULT_MOVE_SPEED = 5;
        const DEFAULT_DASH_MULT = 2.5;
        const DEFAULT_BUBBLE_SIZE = 50;
        const DEFAULT_SHOW_VELOCITY = false;
        const DEFAULT_SHOW_TRAIL = true;
        const DEFAULT_WOBBLE_ON_IDLE = true;
        
        // Ocean background variable (declared early so resizeCanvas can access it)
        let oceanBackground = null;
        
        // Base resolution for the game (maintains consistent game logic)
        let BASE_WIDTH = 1920;
        let BASE_HEIGHT = 1080;
        let BASE_ASPECT_RATIO = BASE_WIDTH / BASE_HEIGHT;
        
        // Game settings
        let gameSettings = {
            resolution: '1920x1080',
            fpsLimit: 60,
            graphicsQuality: 'medium',
            masterVolume: 100,
            showFPS: false,
            vsync: true
        };
        
        // FPS limiting
        let targetFPS = 60;
        let frameInterval = 1000 / targetFPS;
        let lastFrameTime = 0;
        let fpsCounter = 0;
        let fpsTime = 0;
        let currentFPS = 0;
        
        // Global scale factor for UI elements
        let currentScale = 1;
        let canvasDisplayWidth = BASE_WIDTH;
        let canvasDisplayHeight = BASE_HEIGHT;
        let canvasOffsetX = 0;
        let canvasOffsetY = 0;
        
        // Set canvas size to match container with proper scaling
        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            const containerAspectRatio = containerWidth / containerHeight;
            
            const oldWidth = canvas.width;
            const oldHeight = canvas.height;
            
            // Calculate scale to fill container while maintaining aspect ratio
            // Use the larger scale to ensure it fills the screen
            let scale, displayWidth, displayHeight;
            
            const scaleX = containerWidth / BASE_WIDTH;
            const scaleY = containerHeight / BASE_HEIGHT;
            
            // Use the smaller scale to ensure it fits (letterbox/pillarbox)
            // This ensures the game always fits and maintains aspect ratio
            scale = Math.min(scaleX, scaleY);
            
            displayWidth = BASE_WIDTH * scale;
            displayHeight = BASE_HEIGHT * scale;
            
            // Store scale and dimensions for UI positioning
            currentScale = scale;
            canvasDisplayWidth = displayWidth;
            canvasDisplayHeight = displayHeight;
            canvasOffsetX = (containerWidth - displayWidth) / 2;
            canvasOffsetY = (containerHeight - displayHeight) / 2;
            
            // Set canvas internal resolution (always use base resolution for game logic)
            canvas.width = BASE_WIDTH;
            canvas.height = BASE_HEIGHT;
            
            // Set canvas display size (scaled to fit container)
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            
            // Always center the canvas
            canvas.style.marginLeft = canvasOffsetX + 'px';
            canvas.style.marginTop = canvasOffsetY + 'px';
            canvas.style.marginRight = 'auto';
            canvas.style.marginBottom = 'auto';
            
            // Update UI element positions and sizes
            updateUIPositions();
            
            // Reinitialize ocean background if size changed
            if (oceanBackground && (oldWidth !== canvas.width || oldHeight !== canvas.height)) {
                oceanBackground.resize();
            }
        }
        
        // Update UI element positions and sizes based on canvas scale
        function updateUIPositions() {
            const container = canvas.parentElement;
            
            // Update menu widget
            const menuWidget = document.getElementById('menuWidget');
            if (menuWidget) {
                // Scale menu size
                const baseMenuWidth = 280;
                menuWidget.style.width = (baseMenuWidth * currentScale) + 'px';
                
                // Scale all menu elements
                const menuButtons = menuWidget.querySelectorAll('.menu-button, .menu-toggle-button');
                menuButtons.forEach(button => {
                    button.style.fontSize = (14 * currentScale) + 'px';
                    button.style.padding = (12 * currentScale) + 'px ' + (20 * currentScale) + 'px';
                    button.style.borderRadius = (6 * currentScale) + 'px';
                });
                
                // Scale menu content
                const menuContent = menuWidget.querySelector('.menu-content');
                if (menuContent) {
                    menuContent.style.padding = (15 * currentScale) + 'px';
                }
                
                // Scale menu headings
                const menuHeadings = menuWidget.querySelectorAll('h3');
                menuHeadings.forEach(heading => {
                    heading.style.fontSize = (16 * currentScale) + 'px';
                    heading.style.marginBottom = (12 * currentScale) + 'px';
                });
                
                // Scale menu inputs
                const menuInputs = menuWidget.querySelectorAll('.menu-input');
                menuInputs.forEach(input => {
                    input.style.fontSize = (13 * currentScale) + 'px';
                    input.style.padding = (8 * currentScale) + 'px ' + (12 * currentScale) + 'px';
                    input.style.borderRadius = (4 * currentScale) + 'px';
                });
                
                // Scale other text elements
                const infoTexts = menuWidget.querySelectorAll('.controls-info, .room-id-display, .player-list');
                infoTexts.forEach(text => {
                    text.style.fontSize = (12 * currentScale) + 'px';
                });
                
                // Position relative to canvas display area
                menuWidget.style.left = (canvasOffsetX + 20 * currentScale) + 'px';
                menuWidget.style.top = (canvasOffsetY + 20 * currentScale) + 'px';
            }
            
            // Update health bar container
            const healthBarContainer = document.querySelector('.health-bar-container');
            if (healthBarContainer) {
                const baseHealthSize = 150;
                healthBarContainer.style.width = (baseHealthSize * currentScale) + 'px';
                healthBarContainer.style.height = (baseHealthSize * currentScale) + 'px';
                healthBarContainer.style.right = (canvasOffsetX + 40 * currentScale) + 'px';
                healthBarContainer.style.bottom = (canvasOffsetY + 40 * currentScale) + 'px';
                
                // Update health bar size
                const healthBar = document.getElementById('healthBar');
                if (healthBar && healthBar.querySelector('.health-bar-circular')) {
                    const healthBarCircular = healthBar.querySelector('.health-bar-circular');
                    healthBarCircular.style.width = (baseHealthSize * currentScale) + 'px';
                    healthBarCircular.style.height = (baseHealthSize * currentScale) + 'px';
                    
                    // Update health bar canvas - need to recreate with new scale
                    const healthCanvas = healthBarCircular.querySelector('canvas');
                    if (healthCanvas && window.healthBar) {
                        const baseRadius = 60;
                        const baseLineWidth = 12;
                        const baseGlowSize = 20;
                        const newSize = (baseRadius + baseLineWidth + baseGlowSize) * 2 * currentScale;
                        const newRadius = baseRadius * currentScale;
                        const newLineWidth = baseLineWidth * currentScale;
                        
                        // Update health bar properties
                        window.healthBar.radius = newRadius;
                        window.healthBar.lineWidth = newLineWidth;
                        window.healthBar.glowSize = baseGlowSize * currentScale;
                        window.healthBar.size = newSize;
                        
                        healthCanvas.width = newSize;
                        healthCanvas.height = newSize;
                        healthCanvas.style.width = newSize + 'px';
                        healthCanvas.style.height = newSize + 'px';
                        
                        // Redraw health bar
                        window.healthBar.draw();
                    }
                    
                    // Update health text size
                    const healthText = healthBarCircular.querySelector('.health-text');
                    if (healthText) {
                        const healthValue = healthText.querySelector('.health-value');
                        const healthLabel = healthText.querySelector('.health-label');
                        if (healthValue) {
                            healthValue.style.fontSize = (32 * currentScale) + 'px';
                        }
                        if (healthLabel) {
                            healthLabel.style.fontSize = (12 * currentScale) + 'px';
                        }
                    }
                }
                
                // Update dash indicator
                const dashIndicator = document.getElementById('dashIndicator');
                if (dashIndicator) {
                    dashIndicator.style.width = (20 * currentScale) + 'px';
                    dashIndicator.style.height = (20 * currentScale) + 'px';
                    dashIndicator.style.bottom = (10 * currentScale) + 'px';
                }
            }
            
            // Update version info
            const versionInfo = document.getElementById('versionInfo');
            if (versionInfo) {
                versionInfo.style.fontSize = (12 * currentScale) + 'px';
                versionInfo.style.left = (canvasOffsetX + 20 * currentScale) + 'px';
                versionInfo.style.bottom = (canvasOffsetY + 20 * currentScale) + 'px';
            }
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Multiplayer state
        let peer = null;
        let connections = new Map(); // peerId -> DataConnection
        let players = new Map(); // peerId -> player data
        let localPlayerId = null;
        let isHost = false;
        let roomId = null;
        let lastSyncTime = 0;
        const SYNC_INTERVAL = 1000 / 60; // 60fps for position/velocity
        const SYNC_INTERVAL_MEDIUM = 1000 / 30; // 30fps for scale/rotation
        let lastSyncTimeMedium = 0;
        
        // Image cache for player images
        const imageCache = new Map(); // imageData -> Image object
        
        // Matchmaking state
        let inQueue = false;
        let queueMode = null; // '1v1' or '2v2'
        let matchmakingPeer = null;
        let matchmakingConnections = new Map();
        let matchInProgress = false;
        let playerTeams = new Map(); // playerId -> team (1 or 2)
        let team1Players = [];
        let team2Players = [];
        
        // Ranking system
        let playerRanking = {
            rating: 1000, // Starting ELO rating
            wins: 0,
            losses: 0,
            draws: 0,
            winStreak: 0,
            bestWinStreak: 0,
            totalMatches: 0,
            // Spike Dodge Challenge stats
            spikeDodge: {
                bestScore: 0,
                totalPlayed: 0,
                totalSpikesDodged: 0,
                averageScore: 0
            },
            // Dodge Mode Challenge stats
            dodgeMode: {
                bestTime: 0,
                totalPlayed: 0,
                totalTimeSurvived: 0
            },
            // Target Break Challenge stats
            targetBreak: {
                bestScore: 0,
                totalPlayed: 0,
                totalTargetsBroken: 0
            },
            // FreeForAll stats
            freeForAll: {
                bestSurvivalTime: 0,
                totalPlayed: 0,
                totalWins: 0,
                totalTimeSurvived: 0
            }
        };
        
        // Currency and unlockables
        let playerCurrency = {
            orbs: 0
        };
        
        // Available colors (all unlockable) - 50 colors with tiered pricing
        const availableColors = [
            { id: 'default', name: 'Default Blue', hex: '#3b82f6', price: 0, unlocked: true }, // Free default
            // Common tier (150-300 orbs)
            { id: 'red', name: 'Red', hex: '#ef4444', price: 150 },
            { id: 'green', name: 'Green', hex: '#10b981', price: 150 },
            { id: 'yellow', name: 'Yellow', hex: '#f59e0b', price: 150 },
            { id: 'purple', name: 'Purple', hex: '#8b5cf6', price: 150 },
            { id: 'pink', name: 'Pink', hex: '#ec4899', price: 225 },
            { id: 'cyan', name: 'Cyan', hex: '#06b6d4', price: 225 },
            { id: 'orange', name: 'Orange', hex: '#f97316', price: 225 },
            { id: 'lime', name: 'Lime', hex: '#84cc16', price: 225 },
            { id: 'indigo', name: 'Indigo', hex: '#6366f1', price: 300 },
            { id: 'teal', name: 'Teal', hex: '#14b8a6', price: 300 },
            { id: 'rose', name: 'Rose', hex: '#f43f5e', price: 300 },
            { id: 'amber', name: 'Amber', hex: '#fbbf24', price: 300 },
            // Rare tier (450-900 orbs)
            { id: 'emerald', name: 'Emerald', hex: '#34d399', price: 450 },
            { id: 'violet', name: 'Violet', hex: '#a78bfa', price: 450 },
            { id: 'sky', name: 'Sky', hex: '#38bdf8', price: 450 },
            { id: 'coral', name: 'Coral', hex: '#ff7f50', price: 600 },
            { id: 'turquoise', name: 'Turquoise', hex: '#40e0d0', price: 600 },
            { id: 'lavender', name: 'Lavender', hex: '#e6e6fa', price: 600 },
            { id: 'mint', name: 'Mint', hex: '#98ff98', price: 600 },
            { id: 'peach', name: 'Peach', hex: '#ffdab9', price: 600 },
            { id: 'salmon', name: 'Salmon', hex: '#fa8072', price: 750 },
            { id: 'khaki', name: 'Khaki', hex: '#f0e68c', price: 750 },
            { id: 'plum', name: 'Plum', hex: '#dda0dd', price: 750 },
            { id: 'tan', name: 'Tan', hex: '#d2b48c', price: 750 },
            { id: 'olive', name: 'Olive', hex: '#808000', price: 900 },
            { id: 'maroon', name: 'Maroon', hex: '#800000', price: 900 },
            { id: 'navy', name: 'Navy', hex: '#000080', price: 900 },
            { id: 'forest', name: 'Forest Green', hex: '#228b22', price: 900 },
            // Epic tier (1200-2100 orbs)
            { id: 'crimson', name: 'Crimson', hex: '#dc143c', price: 1200 },
            { id: 'royal', name: 'Royal Blue', hex: '#4169e1', price: 1200 },
            { id: 'orchid', name: 'Orchid', hex: '#da70d6', price: 1200 },
            { id: 'sienna', name: 'Sienna', hex: '#a0522d', price: 1350 },
            { id: 'steel', name: 'Steel Blue', hex: '#4682b4', price: 1350 },
            { id: 'tomato', name: 'Tomato', hex: '#ff6347', price: 1350 },
            { id: 'slate', name: 'Slate Blue', hex: '#6a5acd', price: 1500 },
            { id: 'chocolate', name: 'Chocolate', hex: '#d2691e', price: 1500 },
            { id: 'peru', name: 'Peru', hex: '#cd853f', price: 1500 },
            { id: 'medium', name: 'Medium Purple', hex: '#9370db', price: 1800 },
            { id: 'dark', name: 'Dark Cyan', hex: '#008b8b', price: 1800 },
            { id: 'fire', name: 'Fire Brick', hex: '#b22222', price: 1800 },
            { id: 'sea', name: 'Sea Green', hex: '#2e8b57', price: 2100 },
            { id: 'medium', name: 'Medium Sea Green', hex: '#3cb371', price: 2100 },
            // Legendary tier (2400-3000 orbs)
            { id: 'dark', name: 'Dark Magenta', hex: '#8b008b', price: 2400 },
            { id: 'indian', name: 'Indian Red', hex: '#cd5c5c', price: 2400 },
            { id: 'medium', name: 'Medium Orchid', hex: '#ba55d3', price: 2400 },
            { id: 'dark', name: 'Dark Goldenrod', hex: '#b8860b', price: 2700 },
            { id: 'medium', name: 'Medium Turquoise', hex: '#48d1cc', price: 2700 },
            { id: 'pale', name: 'Pale Violet Red', hex: '#db7093', price: 2700 },
            { id: 'dark', name: 'Dark Slate Gray', hex: '#2f4f4f', price: 3000 },
            { id: 'medium', name: 'Medium Slate Blue', hex: '#7b68ee', price: 3000 },
            { id: 'dark', name: 'Dark Olive Green', hex: '#556b2f', price: 3000 },
            // Premium tier (4500-6000 orbs) - White/Black/Gold/Silver
            { id: 'white', name: 'White', hex: '#ffffff', price: 4500 },
            { id: 'black', name: 'Black', hex: '#000000', price: 4500 },
            { id: 'gold', name: 'Gold', hex: '#ffd700', price: 5400 },
            { id: 'silver', name: 'Silver', hex: '#c0c0c0', price: 5400 },
            { id: 'rainbow', name: 'Rainbow', hex: '#ff0080', price: 6000 }
        ];
        
        let unlockedColors = ['default']; // Array of unlocked color IDs
        let selectedColorId = 'default';
        
        // Available auras (25 total, each with independent color and pricing)
        const availableAuras = [
            { id: 'none', name: 'None', color: null, price: 0, unlocked: true },
            // Common tier (150-300 orbs)
            { id: 'glow_blue', name: 'Blue Glow', color: '#3b82f6', price: 150 },
            { id: 'glow_red', name: 'Red Glow', color: '#ef4444', price: 150 },
            { id: 'glow_green', name: 'Green Glow', color: '#10b981', price: 150 },
            { id: 'glow_yellow', name: 'Yellow Glow', color: '#f59e0b', price: 150 },
            { id: 'glow_purple', name: 'Purple Glow', color: '#8b5cf6', price: 225 },
            { id: 'glow_pink', name: 'Pink Glow', color: '#ec4899', price: 225 },
            { id: 'glow_cyan', name: 'Cyan Glow', color: '#06b6d4', price: 225 },
            { id: 'glow_orange', name: 'Orange Glow', color: '#f97316', price: 225 },
            { id: 'glow_lime', name: 'Lime Glow', color: '#84cc16', price: 300 },
            { id: 'glow_indigo', name: 'Indigo Glow', color: '#6366f1', price: 300 },
            // Rare tier (450-900 orbs)
            { id: 'glow_teal', name: 'Teal Glow', color: '#14b8a6', price: 450 },
            { id: 'glow_rose', name: 'Rose Glow', color: '#f43f5e', price: 450 },
            { id: 'glow_amber', name: 'Amber Glow', color: '#fbbf24', price: 600 },
            { id: 'glow_emerald', name: 'Emerald Glow', color: '#34d399', price: 600 },
            { id: 'glow_violet', name: 'Violet Glow', color: '#a78bfa', price: 750 },
            { id: 'glow_sky', name: 'Sky Glow', color: '#38bdf8', price: 750 },
            { id: 'ring_blue', name: 'Blue Ring', color: '#3b82f6', price: 900 },
            { id: 'ring_red', name: 'Red Ring', color: '#ef4444', price: 900 },
            // Epic tier (1200-2100 orbs)
            { id: 'ring_gold', name: 'Gold Ring', color: '#ffd700', price: 1200 },
            { id: 'halo_white', name: 'White Halo', color: '#ffffff', price: 1500 },
            { id: 'glow_gold', name: 'Gold Glow', color: '#ffd700', price: 1800 },
            { id: 'glow_silver', name: 'Silver Glow', color: '#c0c0c0', price: 1800 },
            // Legendary tier (2400-3000 orbs)
            { id: 'glow_white', name: 'White Glow', color: '#ffffff', price: 2400 },
            { id: 'glow_black', name: 'Black Glow', color: '#000000', price: 3000 }
        ];
        
        // Available particle effects (25 total, each with independent color and pricing)
        const availableParticles = [
            { id: 'none', name: 'None', color: null, price: 0, unlocked: true },
            // Common tier (150-300 orbs)
            { id: 'sparkles_blue', name: 'Blue Sparkles', color: '#3b82f6', price: 150 },
            { id: 'sparkles_red', name: 'Red Sparkles', color: '#ef4444', price: 150 },
            { id: 'sparkles_green', name: 'Green Sparkles', color: '#10b981', price: 150 },
            { id: 'sparkles_yellow', name: 'Yellow Sparkles', color: '#f59e0b', price: 150 },
            { id: 'sparkles_purple', name: 'Purple Sparkles', color: '#8b5cf6', price: 225 },
            { id: 'sparkles_pink', name: 'Pink Sparkles', color: '#ec4899', price: 225 },
            { id: 'sparkles_cyan', name: 'Cyan Sparkles', color: '#06b6d4', price: 225 },
            { id: 'sparkles_orange', name: 'Orange Sparkles', color: '#f97316', price: 225 },
            { id: 'sparkles_lime', name: 'Lime Sparkles', color: '#84cc16', price: 300 },
            { id: 'sparkles_indigo', name: 'Indigo Sparkles', color: '#6366f1', price: 300 },
            // Rare tier (450-900 orbs)
            { id: 'sparkles_teal', name: 'Teal Sparkles', color: '#14b8a6', price: 450 },
            { id: 'sparkles_rose', name: 'Rose Sparkles', color: '#f43f5e', price: 450 },
            { id: 'sparkles_amber', name: 'Amber Sparkles', color: '#fbbf24', price: 600 },
            { id: 'sparkles_emerald', name: 'Emerald Sparkles', color: '#34d399', price: 600 },
            { id: 'sparkles_violet', name: 'Violet Sparkles', color: '#a78bfa', price: 750 },
            { id: 'sparkles_sky', name: 'Sky Sparkles', color: '#38bdf8', price: 750 },
            { id: 'trail_blue', name: 'Blue Trail', color: '#3b82f6', price: 900 },
            { id: 'trail_red', name: 'Red Trail', color: '#ef4444', price: 900 },
            // Epic tier (1200-2100 orbs)
            { id: 'trail_gold', name: 'Gold Trail', color: '#ffd700', price: 1200 },
            { id: 'sparkles_gold', name: 'Gold Sparkles', color: '#ffd700', price: 1500 },
            { id: 'sparkles_silver', name: 'Silver Sparkles', color: '#c0c0c0', price: 1800 },
            { id: 'burst_rainbow', name: 'Rainbow Burst', color: '#ff0080', price: 2100 },
            // Legendary tier (2400-3000 orbs)
            { id: 'sparkles_white', name: 'White Sparkles', color: '#ffffff', price: 2400 },
            { id: 'sparkles_black', name: 'Black Sparkles', color: '#000000', price: 3000 }
        ];
        
        let unlockedAuras = ['none'];
        let unlockedParticles = ['none'];
        let selectedAuraId = 'none';
        let selectedParticleId = 'none';
        
        // Load ranking from localStorage
        function loadRanking() {
            try {
                const saved = localStorage.getItem('playerRanking');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Merge with defaults to ensure all properties exist
                    playerRanking = {
                        ...playerRanking,
                        ...parsed,
                        spikeDodge: { ...playerRanking.spikeDodge, ...(parsed.spikeDodge || {}) },
                        dodgeMode: { ...playerRanking.dodgeMode, ...(parsed.dodgeMode || {}) },
                        targetBreak: { ...playerRanking.targetBreak, ...(parsed.targetBreak || {}) },
                        freeForAll: { ...playerRanking.freeForAll, ...(parsed.freeForAll || {}) }
                    };
                }
            } catch (e) {
                console.warn('Could not load ranking from localStorage:', e);
            }
        }
        
        // Save ranking to localStorage
        function saveRanking() {
            try {
                localStorage.setItem('playerRanking', JSON.stringify(playerRanking));
            } catch (e) {
                console.warn('Could not save ranking to localStorage:', e);
            }
        }
        
        // Calculate ELO rating change
        function calculateELOChange(myRating, opponentRating, result) {
            // result: 1 = win, 0.5 = draw, 0 = loss
            const K = 32; // K-factor (how much rating changes per game)
            const expectedScore = 1 / (1 + Math.pow(10, (opponentRating - myRating) / 400));
            const ratingChange = Math.round(K * (result - expectedScore));
            return ratingChange;
        }
        
        // Update ranking after match result
        function updateRanking(result, opponentRating = null) {
            // result: 'win', 'loss', 'draw'
            if (result === 'win') {
                playerRanking.wins++;
                playerRanking.winStreak++;
                if (playerRanking.winStreak > playerRanking.bestWinStreak) {
                    playerRanking.bestWinStreak = playerRanking.winStreak;
                }
                // Estimate opponent rating if not provided (average of all players)
                const estimatedOpponentRating = opponentRating || playerRanking.rating;
                const ratingChange = calculateELOChange(playerRanking.rating, estimatedOpponentRating, 1);
                playerRanking.rating += ratingChange;
            } else if (result === 'loss') {
                playerRanking.losses++;
                playerRanking.winStreak = 0;
                const estimatedOpponentRating = opponentRating || playerRanking.rating;
                const ratingChange = calculateELOChange(playerRanking.rating, estimatedOpponentRating, 0);
                playerRanking.rating += ratingChange;
            } else if (result === 'draw') {
                playerRanking.draws++;
                playerRanking.winStreak = 0;
                const estimatedOpponentRating = opponentRating || playerRanking.rating;
                const ratingChange = calculateELOChange(playerRanking.rating, estimatedOpponentRating, 0.5);
                playerRanking.rating += ratingChange;
            }
            
            playerRanking.totalMatches++;
            playerRanking.rating = Math.max(0, Math.round(playerRanking.rating)); // Ensure rating doesn't go negative
            saveRanking();
            return playerRanking;
        }
        
        // Get rank tier based on rating
        function getRankTier(rating) {
            if (rating >= 2000) return { name: 'Grandmaster', color: '#ff00ff' };
            if (rating >= 1800) return { name: 'Master', color: '#ff6600' };
            if (rating >= 1600) return { name: 'Diamond', color: '#00ccff' };
            if (rating >= 1400) return { name: 'Platinum', color: '#00ffcc' };
            if (rating >= 1200) return { name: 'Gold', color: '#ffd700' };
            if (rating >= 1000) return { name: 'Silver', color: '#c0c0c0' };
            return { name: 'Bronze', color: '#cd7f32' };
        }
        
        // Currency and unlockables functions
        function loadCurrency() {
            try {
                const saved = localStorage.getItem('playerCurrency');
                if (saved) {
                    playerCurrency = JSON.parse(saved);
                }
            } catch (e) {
                console.warn('Could not load currency from localStorage:', e);
            }
        }
        
        function saveCurrency() {
            try {
                localStorage.setItem('playerCurrency', JSON.stringify(playerCurrency));
            } catch (e) {
                console.warn('Could not save currency to localStorage:', e);
            }
        }
        
        function loadUnlockedColors() {
            try {
                const saved = localStorage.getItem('unlockedColors');
                if (saved) {
                    unlockedColors = JSON.parse(saved);
                    // Ensure default color is always unlocked
                    if (!unlockedColors.includes('default')) {
                        unlockedColors.push('default');
                    }
                } else {
                    // If no saved data, ensure default is unlocked
                    if (!unlockedColors.includes('default')) {
                        unlockedColors.push('default');
                    }
                }
                const savedSelected = localStorage.getItem('selectedColorId');
                if (savedSelected) {
                    selectedColorId = savedSelected;
                } else {
                    // If no saved selection, use default
                    selectedColorId = 'default';
                }
            } catch (e) {
                console.warn('Could not load unlocked colors from localStorage:', e);
                // On error, ensure default is unlocked
                if (!unlockedColors.includes('default')) {
                    unlockedColors = ['default'];
                }
            }
        }
        
        function saveUnlockedColors() {
            try {
                localStorage.setItem('unlockedColors', JSON.stringify(unlockedColors));
                localStorage.setItem('selectedColorId', selectedColorId);
            } catch (e) {
                console.warn('Could not save unlocked colors to localStorage:', e);
            }
        }
        
        function loadUnlockedAuras() {
            try {
                const saved = localStorage.getItem('unlockedAuras');
                if (saved) {
                    unlockedAuras = JSON.parse(saved);
                }
                const savedSelected = localStorage.getItem('selectedAuraId');
                if (savedSelected) {
                    selectedAuraId = savedSelected;
                }
            } catch (e) {
                console.warn('Could not load unlocked auras from localStorage:', e);
            }
        }
        
        function saveUnlockedAuras() {
            try {
                localStorage.setItem('unlockedAuras', JSON.stringify(unlockedAuras));
                localStorage.setItem('selectedAuraId', selectedAuraId);
            } catch (e) {
                console.warn('Could not save unlocked auras to localStorage:', e);
            }
        }
        
        function loadUnlockedParticles() {
            try {
                const saved = localStorage.getItem('unlockedParticles');
                if (saved) {
                    unlockedParticles = JSON.parse(saved);
                }
                const savedSelected = localStorage.getItem('selectedParticleId');
                if (savedSelected) {
                    selectedParticleId = savedSelected;
                }
            } catch (e) {
                console.warn('Could not load unlocked particles from localStorage:', e);
            }
        }
        
        function saveUnlockedParticles() {
            try {
                localStorage.setItem('unlockedParticles', JSON.stringify(unlockedParticles));
                localStorage.setItem('selectedParticleId', selectedParticleId);
            } catch (e) {
                console.warn('Could not save unlocked particles to localStorage:', e);
            }
        }
        
        function addOrbs(amount) {
            playerCurrency.orbs += amount;
            saveCurrency();
            updateOrbDisplay();
        }
        
        function spendOrbs(amount) {
            if (playerCurrency.orbs >= amount) {
                playerCurrency.orbs -= amount;
                saveCurrency();
                updateOrbDisplay();
                return true;
            }
            return false;
        }
        
        function unlockColor(colorId) {
            if (!unlockedColors.includes(colorId)) {
                unlockedColors.push(colorId);
                saveUnlockedColors();
                return true;
            }
            return false;
        }
        
        function unlockAura(auraId) {
            if (!unlockedAuras.includes(auraId)) {
                unlockedAuras.push(auraId);
                saveUnlockedAuras();
                return true;
            }
            return false;
        }
        
        function unlockParticle(particleId) {
            if (!unlockedParticles.includes(particleId)) {
                unlockedParticles.push(particleId);
                saveUnlockedParticles();
                return true;
            }
            return false;
        }
        
        function unlockRandomColor() {
            const lockedColors = availableColors.filter(c => !unlockedColors.includes(c.id));
            if (lockedColors.length > 0) {
                const randomColor = lockedColors[Math.floor(Math.random() * lockedColors.length)];
                unlockColor(randomColor.id);
                return randomColor;
            }
            return null;
        }
        
        function updateOrbDisplay() {
            const orbDisplay = document.getElementById('orbCountDisplay');
            if (orbDisplay) {
                orbDisplay.textContent = playerCurrency.orbs;
            }
            const shopOrbDisplay = document.getElementById('orbDisplay');
            if (shopOrbDisplay) {
                shopOrbDisplay.textContent = playerCurrency.orbs || 0;
            }
        }
        
        function showOrbNotification(amount) {
            // Remove any existing notification
            const existingNotification = document.getElementById('orbNotification');
            if (existingNotification) {
                existingNotification.remove();
            }
            
            // Create notification element
            const notification = document.createElement('div');
            notification.id = 'orbNotification';
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px 25px;
                border-radius: 8px;
                font-size: 18px;
                font-weight: 600;
                z-index: 10001;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
                animation: slideInRight 0.3s ease-out, fadeOut 0.3s ease-in 2.7s forwards;
                pointer-events: none;
            `;
            notification.textContent = `+${amount} Orbs Added `;
            
            // Add animation keyframes if they don't exist
            if (!document.getElementById('orbNotificationStyles')) {
                const style = document.createElement('style');
                style.id = 'orbNotificationStyles';
                style.textContent = `
                    @keyframes slideInRight {
                        from {
                            transform: translateX(100%);
                            opacity: 0;
                        }
                        to {
                            transform: translateX(0);
                            opacity: 1;
                        }
                    }
                    @keyframes fadeOut {
                        from {
                            opacity: 1;
                        }
                        to {
                            opacity: 0;
                            transform: translateX(100%);
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(notification);
            
            // Remove notification after animation completes
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 3000);
        }
        
        function showPurchaseOrbsMenu() {
            // Show purchase options (placeholder for future payment integration)
            const amount = prompt('Enter amount of orbs to add (for testing):');
            if (amount && !isNaN(amount) && parseInt(amount) > 0) {
                addOrbs(parseInt(amount));
                alert(`Added ${amount} orbs!`);
                updateOrbDisplay();
            }
        }
        
        // Load ranking on startup
        loadRanking();
        loadCurrency();
        loadUnlockedColors();
        loadUnlockedAuras();
        loadUnlockedParticles();
        loadSettings();
        
        // Initialize player color from selected color
        setTimeout(() => {
            const color = availableColors.find(c => c.id === selectedColorId);
            if (color && localPlayer) {
                localPlayer.color = hexToHsl(color.hex);
            }
        }, 100);
        
        // Initialize challenge menu displays after ranking is loaded
        setTimeout(() => {
            const spikeDodgeBestEl = document.getElementById('spikeDodgeBestScoreDisplay');
            if (spikeDodgeBestEl) {
                spikeDodgeBestEl.textContent = playerRanking.spikeDodge.bestScore;
            }
            const dodgeModeBestEl = document.getElementById('dodgeModeBestTimeDisplay');
            if (dodgeModeBestEl) {
                dodgeModeBestEl.textContent = playerRanking.dodgeMode.bestTime + 's';
            }
            const targetBreakBestEl = document.getElementById('targetBreakBestScoreDisplay');
            if (targetBreakBestEl) {
                targetBreakBestEl.textContent = playerRanking.targetBreak.bestScore;
            }
        }, 100);
        let matchmakingRoomId = null;
        let isMatchmakingHost = false;
        let matchmakingCheckInterval = null;
        
        // Training mode state
        let trainingMode = null;
        let trainingAIBots = [];
        let trainingRespawnTimer = 0;
        let trainingRespawnDelay = 5000; // 5 seconds
        let trainingSettings = {
            aiCount: 2,
            friendlyFire: false,
            maxHealth: 100,
            aiSpeed: 60 // percentage
        };
        
        // Challenges/Game modes state
        let currentGameMode = null; // 'spike_dodge', 'dodge_mode', 'target_break', 'freeforall', 'training', or null
        let spikes = [];
        let spikeSpawnTimer = 0;
        let spikeSpeed = 2;
        let spikeSpawnRate = 2000; // milliseconds
        let gameStartTime = 0;
        let spikesDodged = 0;
        let playerDead = false;
        let deathParticles = [];
        
        // Dodge Mode Challenge state
        let aiBombs = []; // Changed from aiBots to aiBombs
        let dodgeModeStartTime = 0;
        
        let lastBombSpawnTime = 0;
        let bombSpawnInterval = 10000; // 10 seconds
        
        // FreeForAll state
        let freeForAllStartTime = 0;
        let freeForAllInProgress = false;
        let freeForAllSearching = false;
        let freeForAllSearchTimeout = null;
        let freeForAllMatchmakingPeer = null;
        
        // Target Break Challenge state
        let targets = [];
        let activeTargets = []; // Array of active targets (increases with targetsBroken)
        let targetTimer = 0;
        let targetTimeLimit = 0;
        let targetsBroken = 0;
        let targetBreakBestScore = 0;
        
        // Player bubble - initialize after canvas is resized
        function createPlayer(id, isLocal = false) {
            const player = {
                id: id,
                x: canvas.width / 2 + (Math.random() - 0.5) * 100,
                y: canvas.height / 2 + (Math.random() - 0.5) * 100,
                vx: 0,
                vy: 0,
                baseRadius: DEFAULT_BUBBLE_SIZE,
                scaleX: 1,
                scaleY: 1,
                targetScaleX: 1,
                targetScaleY: 1,
                rotation: 0,
                isDashing: false,
                dashCooldown: 0,
                trail: [],
                color: isLocal ? null : generatePlayerColor(id), // Local player uses default, others get unique colors
                name: null,
                image: null,
                health: 100,
                maxHealth: 100,
                lastCollisionTime: 0, // Prevent multiple damage from same collision
                dead: false,
                // Interpolation for smooth remote player movement
                targetX: 0,
                targetY: 0,
                targetVx: 0,
                targetVy: 0,
                lastUpdateTime: Date.now()
            };
            
            // Load saved name and image for local player
            if (isLocal) {
                try {
                    const savedName = localStorage.getItem('playerName');
                    if (savedName) {
                        player.name = savedName;
                    }
                    const savedImage = localStorage.getItem('playerImage');
                    if (savedImage) {
                        player.image = savedImage;
                    }
                } catch (e) {
                    console.warn('Could not load player data from localStorage:', e);
                }
            }
            
            return player;
        }
        
        function generatePlayerColor(id) {
            // Generate consistent color based on player ID
            const hue = (id.charCodeAt(0) * 137.508) % 360;
            return `hsl(${hue}, 70%, 60%)`;
        }
        
        let localPlayer = null;
        
        // Ocean Background
        class OceanComplete {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = ctx; // Use the global ctx instead of creating a new one
                this.initParticles();
            }
            
            initParticles() {
                this.particles = [];
                const particleCount = 80; // Number of background particles
                
                for (let i = 0; i < particleCount; i++) {
                    this.particles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        radius: 1 + Math.random() * 2,
                        speedX: (Math.random() - 0.5) * 0.5,
                        speedY: (Math.random() - 0.5) * 0.5,
                        opacity: 0.3 + Math.random() * 0.4,
                        color: this.getRandomParticleColor()
                    });
                }
            }
            
            getRandomParticleColor() {
                const colors = [
                    'rgba(100, 200, 255, ', // Light blue
                    'rgba(150, 220, 255, ', // Cyan
                    'rgba(200, 240, 255, ', // Very light blue
                    'rgba(100, 180, 255, ', // Medium blue
                    'rgba(59, 130, 246, '   // Blue
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            updateParticles() {
                this.particles.forEach(particle => {
                    // Update position
                    particle.x += particle.speedX;
                    particle.y += particle.speedY;
                    
                    // Wrap around edges
                    if (particle.x < 0) particle.x = this.canvas.width;
                    if (particle.x > this.canvas.width) particle.x = 0;
                    if (particle.y < 0) particle.y = this.canvas.height;
                    if (particle.y > this.canvas.height) particle.y = 0;
                    
                    // Subtle opacity variation
                    particle.opacity += (Math.random() - 0.5) * 0.02;
                    particle.opacity = Math.max(0.2, Math.min(0.7, particle.opacity));
                });
            }
            
            drawParticles() {
                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.opacity;
                    this.ctx.fillStyle = particle.color + particle.opacity + ')';
                    
                    // Draw particle with glow effect
                    this.ctx.shadowBlur = 5;
                    this.ctx.shadowColor = particle.color + particle.opacity + ')';
                    
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                });
            }
            
            // === WAVES ===
            initWaves() {
                this.waves = [];
                this.colors = [
                    { top: '#001a33', bottom: '#003d5c' },
                    { top: '#002a44', bottom: '#004d6d' },
                    { top: '#003355', bottom: '#005577' }
                ];
                
                for (let i = 0; i < 5; i++) {
                    this.waves.push({
                        amplitude: 30 + Math.random() * 40,
                        frequency: 0.003 + Math.random() * 0.002,
                        speed: 0.0005 + Math.random() * 0.001,
                        offset: Math.random() * Math.PI * 2,
                        yPosition: this.canvas.height * (0.3 + i * 0.15),
                        color: this.colors[i % this.colors.length],
                        phase: 0
                    });
                }
            }
            
            updateWaves(time) {
                this.waves.forEach(wave => {
                    wave.phase = time * wave.speed;
                });
            }
            
            drawWaves() {
                // Draw waves from back to front
                this.waves.forEach((wave, index) => {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, this.canvas.height);
                    
                    for (let x = 0; x <= this.canvas.width; x += 5) {
                        const y = wave.yPosition + 
                            Math.sin(x * wave.frequency + wave.phase + wave.offset) * wave.amplitude;
                        this.ctx.lineTo(x, y);
                    }
                    
                    this.ctx.lineTo(this.canvas.width, this.canvas.height);
                    this.ctx.closePath();
                    
                    const waveGradient = this.ctx.createLinearGradient(0, wave.yPosition - 50, 0, this.canvas.height);
                    waveGradient.addColorStop(0, wave.color.top);
                    waveGradient.addColorStop(1, wave.color.bottom);
                    
                    this.ctx.fillStyle = waveGradient;
                    this.ctx.fill();
                    
                    // Wave highlights
                    this.ctx.strokeStyle = `rgba(0, 200, 255, ${0.2 - index * 0.03})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                });
            }
            
            // === BUBBLES ===
            initBubbles() {
                this.bubbles = [];
                // Reduced from 50 to 30 for better performance
                for (let i = 0; i < 30; i++) {
                    this.bubbles.push(this.createBubble());
                }
            }
            
            createBubble() {
                return {
                    x: Math.random() * this.canvas.width,
                    y: this.canvas.height + Math.random() * 200,
                    radius: 3 + Math.random() * 15,
                    speed: 0.5 + Math.random() * 1.5,
                    wobble: Math.random() * 0.02,
                    wobbleOffset: Math.random() * Math.PI * 2,
                    opacity: 0.3 + Math.random() * 0.4
                };
            }
            
            updateBubbles() {
                this.bubbles.forEach(bubble => {
                    bubble.y -= bubble.speed;
                    bubble.x += Math.sin(bubble.y * bubble.wobble + bubble.wobbleOffset) * 0.5;
                    
                    if (bubble.y < -bubble.radius * 2) {
                        Object.assign(bubble, this.createBubble());
                        bubble.y = this.canvas.height + Math.random() * 200;
                    }
                });
            }
            
            drawBubbles() {
                this.bubbles.forEach(bubble => {
                    // Bubble gradient
                    const bubbleGradient = this.ctx.createRadialGradient(
                        bubble.x - bubble.radius * 0.3,
                        bubble.y - bubble.radius * 0.3,
                        0,
                        bubble.x,
                        bubble.y,
                        bubble.radius
                    );
                    bubbleGradient.addColorStop(0, `rgba(200, 240, 255, ${bubble.opacity})`);
                    bubbleGradient.addColorStop(0.7, `rgba(100, 200, 255, ${bubble.opacity * 0.5})`);
                    bubbleGradient.addColorStop(1, `rgba(0, 150, 255, 0)`);
                    
                    this.ctx.fillStyle = bubbleGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Highlight
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${bubble.opacity * 0.6})`;
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x - bubble.radius * 0.3, bubble.y - bubble.radius * 0.3, bubble.radius * 0.3, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Rim
                    this.ctx.strokeStyle = `rgba(200, 240, 255, ${bubble.opacity * 0.4})`;
                    this.ctx.lineWidth = 1.5;
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                });
            }
            
            // === CAUSTIC LIGHT ===
            initCaustics() {
                this.caustics = [];
                // Reduced from 10 to 6 for better performance
                for (let i = 0; i < 6; i++) {
                    this.caustics.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        radius: 100 + Math.random() * 200,
                        speed: 0.0002 + Math.random() * 0.0003,
                        phase: Math.random() * Math.PI * 2
                    });
                }
            }
            
            updateCaustics(time) {
                this.caustics.forEach(c => {
                    c.phase = time * c.speed;
                });
            }
            
            drawCaustics() {
                this.ctx.globalCompositeOperation = 'lighter';
                
                this.caustics.forEach(c => {
                    const x = c.x + Math.sin(c.phase) * 50;
                    const y = c.y + Math.cos(c.phase * 0.7) * 30;
                    
                    const causticGradient = this.ctx.createRadialGradient(x, y, 0, x, y, c.radius);
                    causticGradient.addColorStop(0, 'rgba(100, 220, 255, 0.3)');
                    causticGradient.addColorStop(0.5, 'rgba(0, 200, 255, 0.1)');
                    causticGradient.addColorStop(1, 'rgba(0, 150, 255, 0)');
                    
                    this.ctx.fillStyle = causticGradient;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                });
                
                this.ctx.globalCompositeOperation = 'source-over';
            }
            
            // === MAIN UPDATE & DRAW ===
            update(time) {
                this.updateParticles();
            }
            
            draw(time) {
                // Smooth blue gradient background with multiple color stops
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#004d6d');      // Light blue at top
                gradient.addColorStop(0.3, '#003d5c');    // Medium-light blue
                gradient.addColorStop(0.6, '#002a44');    // Medium blue
                gradient.addColorStop(0.85, '#001f33');   // Medium-dark blue
                gradient.addColorStop(1, '#001a33');      // Dark blue at bottom
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw particles on top of gradient
                this.drawParticles();
            }
            
            // Reinitialize when canvas resizes
            resize() {
                // Reinitialize particles with new canvas size
                this.initParticles();
            }
        }
        
        // Input handling
        const keys = {};
        let mouseX = 0;
        let mouseY = 0;
        let mouseDown = false;
        let lastClickTime = 0;
        const DOUBLE_CLICK_DELAY = 300; // milliseconds
        
        // UI visibility state
        let uiVisible = true;
        
        // Menu state - Game is never paused, menu is just an overlay
        let menuVisible = false;
        
        function toggleMenuWidget() {
            const menuWidget = document.getElementById('menuWidget');
            if (!menuWidget) return;
            
            menuVisible = !menuVisible;
            
            if (menuVisible) {
                menuWidget.classList.remove('collapsed');
                menuWidget.classList.add('expanded');
                showMainMenu();
            } else {
                menuWidget.classList.remove('expanded');
                menuWidget.classList.add('collapsed');
            }
        }
        
        function toggleMenu() {
            toggleMenuWidget();
        }
        
        function showMainMenu() {
            hideAllScreens();
            document.getElementById('mainMenuScreen').classList.add('active');
            updateChallengesButtonVisibility();
        }
        
        function showVSMenu() {
            hideAllScreens();
            document.getElementById('vsMenuScreen').classList.add('active');
            updateQueueStatus();
            updateRankingDisplay();
        }
        
        // FreeForAll mode
        function startFreeForAll() {
            // Check if already in a game
            if (isHost || roomId) {
                // Already in a multiplayer game - use it as FreeForAll lobby
                freeForAllInProgress = true;
                freeForAllStartTime = Date.now();
                currentGameMode = 'freeforall';
                resumeGame();
                return;
            }
            
            // Hide queue buttons like joinQueue does
            document.getElementById('queue1v1Button').style.display = 'none';
            document.getElementById('queue2v2Button').style.display = 'none';
            document.getElementById('freeForAllButton').style.display = 'none';
            document.getElementById('cancelQueueButton').style.display = 'block';
            
            // Start searching for FreeForAll lobby
            freeForAllSearching = true;
            const searchRoomId = 'freeforall-lobby';
            
            // Show searching status
            const statusEl = document.getElementById('queueStatus');
            if (statusEl) {
                statusEl.textContent = 'Searching for FreeForAll lobby...';
                statusEl.style.color = '#667eea';
            }
            
            // Try to connect as client first (search for existing lobby)
            freeForAllMatchmakingPeer = new Peer({
                secure: true
            });
            
            freeForAllMatchmakingPeer.on('open', (myId) => {
                console.log('FreeForAll search peer opened:', myId);
                
                // Try to connect to existing FreeForAll lobby
                const conn = freeForAllMatchmakingPeer.connect(searchRoomId);
                
                conn.on('open', () => {
                    console.log('Found FreeForAll lobby! Joining...');
                    freeForAllSearching = false;
                    if (freeForAllSearchTimeout) {
                        clearTimeout(freeForAllSearchTimeout);
                        freeForAllSearchTimeout = null;
                    }
                    
                    // Use the search peer as our game peer
                    peer = freeForAllMatchmakingPeer;
                    freeForAllMatchmakingPeer = null;
                    
                    // Join the existing lobby
                    roomId = searchRoomId;
                    isHost = false;
                    localPlayerId = 'local';
                    
                    if (!localPlayer) {
                        localPlayer = createPlayer('local', true);
                    }
                    players.set('local', localPlayer);
                    
                    // Set up connection to host
                    connections.set(conn.peer, conn);
                    setupConnection(conn);
                    
                    updateChallengesButtonVisibility();
                    
                    // Wait a moment for connection to establish, then start game
                    setTimeout(() => {
                        startFreeForAllGame();
                    }, 500);
                });
                
                conn.on('error', (err) => {
                    console.log('No existing FreeForAll lobby found, will create one...');
                    // Connection failed means no lobby exists - we'll create one after timeout
                });
            });
            
            freeForAllMatchmakingPeer.on('error', (err) => {
                console.error('FreeForAll search peer error:', err);
            });
            
            // Set 10 second timeout - if no lobby found, create one
            freeForAllSearchTimeout = setTimeout(() => {
                if (freeForAllSearching) {
                    console.log('No FreeForAll lobby found, creating new one...');
                    freeForAllSearching = false;
                    
                    // Clean up search peer
                    if (freeForAllMatchmakingPeer) {
                        freeForAllMatchmakingPeer.destroy();
                        freeForAllMatchmakingPeer = null;
                    }
                    
                    // Create new FreeForAll lobby as host
                    createFreeForAllLobby();
                }
            }, 10000); // 10 seconds
        }
        
        function createFreeForAllLobby() {
            const freeForAllRoomId = 'freeforall-lobby';
            
            // Create peer as host
            peer = new Peer(freeForAllRoomId, {
                secure: true
            });
            
            peer.on('open', (id) => {
                console.log('FreeForAll lobby created, hosting as:', id);
                isHost = true;
                roomId = freeForAllRoomId;
                localPlayerId = 'local';
                
                if (!localPlayer) {
                    localPlayer = createPlayer('local', true);
                }
                players.set('local', localPlayer);
                
                updateChallengesButtonVisibility();
                
                // Start FreeForAll game
                startFreeForAllGame();
            });
            
            peer.on('connection', (conn) => {
                console.log('Player joined FreeForAll lobby:', conn.peer);
                setupConnection(conn);
            });
            
            peer.on('error', (err) => {
                console.error('FreeForAll lobby creation error:', err);
            });
        }
        
        function startFreeForAllGame() {
            // Start the FreeForAll game
            freeForAllInProgress = true;
            freeForAllStartTime = Date.now();
            currentGameMode = 'freeforall';
            
            // Reset all players
            players.forEach((player, playerId) => {
                player.health = 100;
                player.maxHealth = 100;
                player.dead = false;
                player.visible = true;
                player.x = canvas.width / 2 + (Math.random() - 0.5) * 200;
                player.y = canvas.height / 2 + (Math.random() - 0.5) * 200;
                player.vx = 0;
                player.vy = 0;
            });
            
            if (localPlayer) {
                localPlayer.health = 100;
                localPlayer.maxHealth = 100;
                localPlayer.dead = false;
                localPlayer.visible = true;
            }
            
            if (healthBar) {
                healthBar.setHealth(100);
            }
            
            playerDead = false;
            deathParticles = [];
            
            // Hide menu
            resumeGame();
            
            // Update status
            const statusEl = document.getElementById('queueStatus');
            if (statusEl) {
                statusEl.textContent = 'FreeForAll in progress!';
                statusEl.style.color = '#00ff88';
            }
        }
        
        function checkFreeForAllWinner() {
            if (!freeForAllInProgress || currentGameMode !== 'freeforall') return;
            
            let alivePlayers = [];
            let aliveCount = 0;
            
            // Check all players including local player
            players.forEach((player, playerId) => {
                if (player && !player.dead && player.health > 0) {
                    alivePlayers.push({ id: playerId, player: player });
                    aliveCount++;
                }
            });
            
            // Also check local player separately if not in players map
            if (localPlayer && !players.has(localPlayerId)) {
                if (!localPlayer.dead && localPlayer.health > 0) {
                    alivePlayers.push({ id: localPlayerId, player: localPlayer });
                    aliveCount++;
                }
            }
            
            // If only one player left, they win
            if (aliveCount === 1 && alivePlayers.length === 1) {
                const winner = alivePlayers[0];
                const isLocalWinner = winner.id === localPlayerId;
                
                // Calculate survival time for all players
                const survivalTime = Math.floor((Date.now() - freeForAllStartTime) / 1000);
                
                // Reset FreeForAll state BEFORE showing screens to prevent multiple checks
                freeForAllInProgress = false;
                currentGameMode = null;
                
                if (isLocalWinner) {
                    // Local player won - update stats
                    playerRanking.freeForAll.totalWins++;
                    if (survivalTime > playerRanking.freeForAll.bestSurvivalTime) {
                        playerRanking.freeForAll.bestSurvivalTime = survivalTime;
                    }
                    playerRanking.freeForAll.totalTimeSurvived += survivalTime;
                    playerRanking.freeForAll.totalPlayed++;
                    saveRanking();
                    
                    // Show victory screen - winner stays in game
                    showFreeForAllVictoryScreen(winner.player.name || 'You', true, survivalTime);
                } else {
                    // Local player lost - show defeat screen
                    if (localPlayer && (localPlayer.dead || localPlayer.health <= 0)) {
                        // Update stats for time survived before death
                        if (survivalTime > playerRanking.freeForAll.bestSurvivalTime) {
                            playerRanking.freeForAll.bestSurvivalTime = survivalTime;
                        }
                        playerRanking.freeForAll.totalTimeSurvived += survivalTime;
                        playerRanking.freeForAll.totalPlayed++;
                        saveRanking();
                        
                        showFreeForAllDefeatScreen(winner.player.name || 'Winner', survivalTime);
                    } else {
                        // Local player is still alive but someone else won? This shouldn't happen
                        // But if it does, show defeat screen anyway
                        playerRanking.freeForAll.totalPlayed++;
                        saveRanking();
                        showFreeForAllDefeatScreen(winner.player.name || 'Winner', survivalTime);
                    }
                }
            } else if (aliveCount === 0) {
                // Everyone died - reset
                freeForAllInProgress = false;
                currentGameMode = null;
                playerRanking.freeForAll.totalPlayed++;
                saveRanking();
            }
            // If aliveCount > 1, game continues
        }
        
        function showFreeForAllVictoryScreen(winnerName, isLocalWinner, survivalTime) {
            const screen = document.createElement('div');
            screen.id = 'freeForAllVictoryScreen';
            screen.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 10001;
                color: white;
                font-family: system-ui, -apple-system, sans-serif;
            `;
            screen.innerHTML = `
                <h2 style="font-size: 36px; margin-bottom: 20px; color: #ffd700;"> VICTORY! </h2>
                <p style="font-size: 24px; margin-bottom: 10px;">${winnerName} Wins!</p>
                <p style="font-size: 18px; color: #aaa; margin-bottom: 30px;">Survival Time: ${survivalTime}s</p>
                <p style="font-size: 14px; color: #667eea; margin-bottom: 30px;">You stay in the game!</p>
                <button onclick="closeFreeForAllVictoryScreen()" style="
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    border: none;
                    padding: 15px 30px;
                    border-radius: 8px;
                    font-size: 16px;
                    font-weight: 600;
                    cursor: pointer;
                ">Continue</button>
            `;
            document.body.appendChild(screen);
        }
        
        function showFreeForAllDefeatScreen(winnerName, survivalTime) {
            const screen = document.createElement('div');
            screen.id = 'freeForAllDefeatScreen';
            screen.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 10001;
                color: white;
                font-family: system-ui, -apple-system, sans-serif;
            `;
            screen.innerHTML = `
                <h2 style="font-size: 32px; margin-bottom: 20px; color: #ff4444;">Defeated</h2>
                <p style="font-size: 20px; margin-bottom: 10px;">${winnerName} is the last one standing!</p>
                <p style="font-size: 16px; color: #aaa; margin-bottom: 10px;">You survived: ${survivalTime}s</p>
                <p style="font-size: 14px; color: #667eea; margin-bottom: 30px;">Best Survival Time: ${playerRanking.freeForAll.bestSurvivalTime}s</p>
                <button onclick="retryFreeForAll()" style="
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    border: none;
                    padding: 15px 30px;
                    border-radius: 8px;
                    font-size: 16px;
                    font-weight: 600;
                    cursor: pointer;
                    margin: 10px;
                ">Try Again</button>
                <button onclick="exitFreeForAll()" style="
                    background: rgba(100, 100, 100, 0.5);
                    color: white;
                    border: none;
                    padding: 15px 30px;
                    border-radius: 8px;
                    font-size: 16px;
                    font-weight: 600;
                    cursor: pointer;
                    margin: 10px;
                ">Back to Lobby</button>
            `;
            document.body.appendChild(screen);
        }
        
        function closeFreeForAllVictoryScreen() {
            const screen = document.getElementById('freeForAllVictoryScreen');
            if (screen) {
                screen.remove();
            }
        }
        
        function retryFreeForAll() {
            const screen = document.getElementById('freeForAllDefeatScreen');
            if (screen) {
                screen.remove();
            }
            
            // Reset player
            if (localPlayer) {
                localPlayer.visible = true;
                localPlayer.dead = false;
                localPlayer.health = 100;
                localPlayer.maxHealth = 100;
                localPlayer.x = canvas.width / 2;
                localPlayer.y = canvas.height / 2;
                localPlayer.vx = 0;
                localPlayer.vy = 0;
            }
            
            if (healthBar) {
                healthBar.setHealth(100, false);
            }
            
            playerDead = false;
            deathParticles = [];
            
            // Restart FreeForAll if still in a game
            if (isHost || roomId) {
                freeForAllInProgress = true;
                freeForAllStartTime = Date.now();
                currentGameMode = 'freeforall';
            }
        }
        
        function exitFreeForAll() {
            const screen = document.getElementById('freeForAllDefeatScreen');
            if (screen) {
                screen.remove();
            }
            
            // Leave the game and go back to lobby
            if (peer) {
                peer.destroy();
                peer = null;
            }
            if (roomId) {
                roomId = null;
            }
            isHost = false;
            players.clear();
            connections.clear();
            
            // Reset player
            if (localPlayer) {
                localPlayer.visible = true;
                localPlayer.dead = false;
                localPlayer.health = 100;
                localPlayer.maxHealth = 100;
                localPlayer.x = canvas.width / 2;
                localPlayer.y = canvas.height / 2;
                localPlayer.vx = 0;
                localPlayer.vy = 0;
            }
            
            if (healthBar) {
                healthBar.setHealth(100);
            }
            
            playerDead = false;
            deathParticles = [];
            freeForAllInProgress = false;
            currentGameMode = null;
            
            // Go back to main menu
            showMainMenu();
        }
        
        function showStatsMenu() {
            hideAllScreens();
            document.getElementById('statsMenuScreen').classList.add('active');
            updateStatsDisplay();
        }
        
        function updateRankingDisplay() {
            const tier = getRankTier(playerRanking.rating);
            const rankTierDisplay = document.getElementById('rankTierDisplay');
            const rankRatingDisplay = document.getElementById('rankRatingDisplay');
            
            if (rankTierDisplay) {
                rankTierDisplay.textContent = tier.name;
                rankTierDisplay.style.color = tier.color;
            }
            if (rankRatingDisplay) {
                rankRatingDisplay.textContent = `Rating: ${playerRanking.rating} | W: ${playerRanking.wins} L: ${playerRanking.losses}`;
            }
        }
        
        function updateStatsDisplay() {
            const statsDisplay = document.getElementById('statsDisplay');
            if (!statsDisplay) return;
            
            const tier = getRankTier(playerRanking.rating);
            const winRate = playerRanking.totalMatches > 0 
                ? ((playerRanking.wins / playerRanking.totalMatches) * 100).toFixed(1) 
                : '0.0';
            
            const avgSpikeScore = playerRanking.spikeDodge.totalPlayed > 0
                ? Math.round(playerRanking.spikeDodge.totalSpikesDodged / playerRanking.spikeDodge.totalPlayed)
                : 0;
            
            // Get other players' stats for comparison
            let otherPlayersStats = [];
            players.forEach((player, playerId) => {
                if (playerId !== localPlayerId && player.name) {
                    // Try to get their stats from localStorage (if we've stored them)
                    // For now, we'll just show their name and rating if available
                    otherPlayersStats.push({
                        name: player.name || `Player ${playerId.substring(0, 6)}`,
                        id: playerId
                    });
                }
            });
            
            statsDisplay.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <div style="font-size: 18px; font-weight: 600; color: ${tier.color}; margin-bottom: 8px; text-align: center;">${tier.name}</div>
                    <div style="font-size: 14px; color: #aaa; text-align: center;">Rating: <span style="color: #fff; font-weight: 600;">${playerRanking.rating}</span></div>
                </div>
                
                <div style="background: rgba(255, 165, 0, 0.1); padding: 12px; border-radius: 6px; margin-bottom: 15px; border: 1px solid rgba(255, 165, 0, 0.3);">
                    <div style="font-size: 14px; font-weight: 600; color: #ffaa00; margin-bottom: 10px;">Spike Dodge Challenge</div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                        <span style="color: #aaa; font-size: 11px;">Best Score:</span>
                        <span style="color: #ffd700; font-weight: 600; font-size: 11px;">${playerRanking.spikeDodge.bestScore}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                        <span style="color: #aaa; font-size: 11px;">Times Played:</span>
                        <span style="color: #fff; font-weight: 600; font-size: 11px;">${playerRanking.spikeDodge.totalPlayed}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                        <span style="color: #aaa; font-size: 11px;">Total Spikes Dodged:</span>
                        <span style="color: #fff; font-weight: 600; font-size: 11px;">${playerRanking.spikeDodge.totalSpikesDodged}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #aaa; font-size: 11px;">Average Score:</span>
                        <span style="color: #fff; font-weight: 600; font-size: 11px;">${avgSpikeScore}</span>
                    </div>
                </div>
                
                <div style="background: rgba(255, 100, 100, 0.1); padding: 12px; border-radius: 6px; margin-bottom: 15px; border: 1px solid rgba(255, 100, 100, 0.3);">
                    <div style="font-size: 14px; font-weight: 600; color: #ff6464; margin-bottom: 10px;">Dodge Mode Challenge</div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                        <span style="color: #aaa; font-size: 11px;">Best Time:</span>
                        <span style="color: #ffd700; font-weight: 600; font-size: 11px;">${playerRanking.dodgeMode.bestTime}s</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                        <span style="color: #aaa; font-size: 11px;">Times Played:</span>
                        <span style="color: #fff; font-weight: 600; font-size: 11px;">${playerRanking.dodgeMode.totalPlayed}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #aaa; font-size: 11px;">Total Time Survived:</span>
                        <span style="color: #fff; font-weight: 600; font-size: 11px;">${Math.floor(playerRanking.dodgeMode.totalTimeSurvived / 60)}m ${playerRanking.dodgeMode.totalTimeSurvived % 60}s</span>
                    </div>
                </div>
                
                <div style="background: rgba(100, 255, 100, 0.1); padding: 12px; border-radius: 6px; margin-bottom: 15px; border: 1px solid rgba(100, 255, 100, 0.3);">
                    <div style="font-size: 14px; font-weight: 600; color: #64ff64; margin-bottom: 10px;">Target Break Challenge</div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                        <span style="color: #aaa; font-size: 11px;">Best Score:</span>
                        <span style="color: #ffd700; font-weight: 600; font-size: 11px;">${playerRanking.targetBreak.bestScore}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                        <span style="color: #aaa; font-size: 11px;">Times Played:</span>
                        <span style="color: #fff; font-weight: 600; font-size: 11px;">${playerRanking.targetBreak.totalPlayed}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #aaa; font-size: 11px;">Total Targets Broken:</span>
                        <span style="color: #fff; font-weight: 600; font-size: 11px;">${playerRanking.targetBreak.totalTargetsBroken}</span>
                    </div>
                </div>
                
                ${otherPlayersStats.length > 0 ? `
                    <div style="background: rgba(100, 200, 255, 0.1); padding: 12px; border-radius: 6px; border: 1px solid rgba(100, 200, 255, 0.3);">
                        <div style="font-size: 14px; font-weight: 600; color: #64c8ff; margin-bottom: 10px;">Other Players in Game</div>
                        ${otherPlayersStats.map(p => `
                            <div style="display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 11px;">
                                <span style="color: #aaa;">${p.name}:</span>
                                <span style="color: #fff;">Connected</span>
                            </div>
                        `).join('')}
                        <div style="color: #888; font-size: 10px; margin-top: 8px; font-style: italic;">
                            Note: Rankings are stored locally. Each player has their own ranking.
                        </div>
                    </div>
                ` : `
                    <div style="background: rgba(100, 100, 100, 0.1); padding: 12px; border-radius: 6px; border: 1px solid rgba(100, 100, 100, 0.3);">
                        <div style="font-size: 12px; color: #888; text-align: center; font-style: italic;">
                            No other players connected. Rankings are stored locally on each device.
                        </div>
                    </div>
                `}
            `;
        }
        
        function showTrainingMenu() {
            hideAllScreens();
            document.getElementById('trainingMenuScreen').classList.add('active');
        }
        
        function showTrainingSettings() {
            hideAllScreens();
            document.getElementById('trainingSettingsScreen').classList.add('active');
            updateTrainingSettings();
        }
        
        function updateTrainingSettings() {
            // Update settings from UI
            const aiCountSlider = document.getElementById('aiCountSlider');
            const friendlyFireCheckbox = document.getElementById('friendlyFireCheckbox');
            const healthSlider = document.getElementById('healthSlider');
            const aiSpeedSlider = document.getElementById('aiSpeedSlider');
            
            if (aiCountSlider) {
                trainingSettings.aiCount = parseInt(aiCountSlider.value);
                const aiCountDisplay = document.getElementById('aiCountDisplay');
                if (aiCountDisplay) {
                    aiCountDisplay.textContent = trainingSettings.aiCount;
                }
            }
            
            if (friendlyFireCheckbox) {
                trainingSettings.friendlyFire = friendlyFireCheckbox.checked;
            }
            
            if (aiSpeedSlider) {
                trainingSettings.aiSpeed = parseInt(aiSpeedSlider.value);
                const aiSpeedDisplay = document.getElementById('aiSpeedDisplay');
                if (aiSpeedDisplay) {
                    aiSpeedDisplay.textContent = trainingSettings.aiSpeed + '%';
                }
            }
        }
        
        function startTrainingWithSettings() {
            // Apply settings and start training
            updateTrainingSettings();
            currentGameMode = 'training';
            trainingAIBots = [];
            trainingRespawnTimer = 0;
            playerDead = false;
            deathParticles = [];
            
            // Reset player with custom health
            if (localPlayer) {
                localPlayer.x = canvas.width / 2;
                localPlayer.y = canvas.height / 2;
                localPlayer.vx = 0;
                localPlayer.vy = 0;
                localPlayer.visible = true;
                localPlayer.dead = false;
                localPlayer.health = trainingSettings.maxHealth;
                localPlayer.maxHealth = trainingSettings.maxHealth;
            }
            
            if (healthBar) {
                healthBar.setHealth(trainingSettings.maxHealth);
            }
            
            // Spawn AI bots based on settings
            for (let i = 0; i < trainingSettings.aiCount; i++) {
                spawnTrainingAI(i);
            }
            
            // Hide menu and start game
            hideAllScreens();
            resumeGame();
        }
        
        function spawnTrainingAI(index) {
            // Spawn AI at random position away from player
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.max(canvas.width, canvas.height) * 0.3;
            const ai = {
                id: 'training_ai_' + index,
                x: canvas.width / 2 + Math.cos(angle) * distance,
                y: canvas.height / 2 + Math.sin(angle) * distance,
                vx: 0,
                vy: 0,
                baseRadius: DEFAULT_BUBBLE_SIZE,
                scaleX: 1,
                scaleY: 1,
                targetScaleX: 1,
                targetScaleY: 1,
                rotation: 0,
                color: `hsl(${Math.random() * 60 + 0}, 100%, 50%)`, // Red to orange
                health: trainingSettings.maxHealth,
                maxHealth: trainingSettings.maxHealth,
                dead: false,
                visible: true,
                lastAttackTime: 0,
                attackCooldown: 2000 + Math.random() * 3000, // 2-5 seconds
                wanderTargetX: null,
                wanderTargetY: null,
                wanderTimer: 0,
                lastCollisionTime: 0
            };
            trainingAIBots.push(ai);
        }
        
        function resetTrainingMode() {
            // Reset all training state
            trainingAIBots = [];
            trainingRespawnTimer = 0;
            playerDead = false;
            deathParticles = [];
            
            // Reset player with training settings
            if (localPlayer) {
                localPlayer.x = canvas.width / 2;
                localPlayer.y = canvas.height / 2;
                localPlayer.vx = 0;
                localPlayer.vy = 0;
                localPlayer.visible = true;
                localPlayer.dead = false;
                localPlayer.health = trainingSettings.maxHealth;
                localPlayer.maxHealth = trainingSettings.maxHealth;
            }
            
            if (healthBar) {
                healthBar.setHealth(trainingSettings.maxHealth);
            }
            
            // Return to training menu
            currentGameMode = null;
            hideAllScreens();
            document.getElementById('trainingMenuScreen').classList.add('active');
        }
        
        function updateTrainingMode(deltaTime) {
            if (currentGameMode !== 'training') return;
            
            // If player is dead, reset training mode after a delay
            if (playerDead) {
                trainingRespawnTimer += deltaTime;
                
                if (trainingRespawnTimer >= trainingRespawnDelay) {
                    // Reset training mode
                    resetTrainingMode();
                }
                return;
            }
            
            // Check if all AIs are dead (player won)
            const aliveAIs = trainingAIBots.filter(ai => !ai.dead);
            const deadAIs = trainingAIBots.filter(ai => ai.dead);
            
            // If all AIs are dead, reset training mode after a delay
            if (aliveAIs.length === 0 && deadAIs.length > 0) {
                trainingRespawnTimer += deltaTime;
                
                if (trainingRespawnTimer >= trainingRespawnDelay) {
                    // Reset training mode instead of respawning
                    resetTrainingMode();
                }
            } else {
                // Reset timer if there are alive AIs
                trainingRespawnTimer = 0;
            }
            
            // Update each AI bot
            for (let i = trainingAIBots.length - 1; i >= 0; i--) {
                const ai = trainingAIBots[i];
                if (ai.dead) {
                    // Don't remove dead AIs immediately - keep them for respawn check
                    continue;
                }
                
                updateTrainingAI(ai, deltaTime);
                
                // Check collision with player
                if (localPlayer && !playerDead && !localPlayer.dead) {
                    const dx = ai.x - localPlayer.x;
                    const dy = ai.y - localPlayer.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const collisionDist = ai.baseRadius + localPlayer.baseRadius;
                    
                    if (dist < collisionDist) {
                        handleTrainingCollision(ai, localPlayer);
                    }
                }
                
                // Check collision with other AIs if friendly fire is enabled
                if (trainingSettings.friendlyFire) {
                    for (let j = i + 1; j < trainingAIBots.length; j++) {
                        const otherAI = trainingAIBots[j];
                        if (otherAI.dead) continue;
                        
                        const dx = ai.x - otherAI.x;
                        const dy = ai.y - otherAI.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const collisionDist = ai.baseRadius + otherAI.baseRadius;
                        
                        if (dist < collisionDist) {
                            handleTrainingAICollision(ai, otherAI);
                        }
                    }
                }
            }
            
            // Update death particles
            updateDeathParticles();
        }
        
        function updateTrainingAI(ai, deltaTime) {
            if (!localPlayer || playerDead) return;
            
            const moveSpeed = DEFAULT_MOVE_SPEED * (trainingSettings.aiSpeed / 100); // Based on settings
            const now = Date.now();
            
            // Random wandering behavior
            ai.wanderTimer += deltaTime;
            if (!ai.wanderTargetX || ai.wanderTimer > 2000 + Math.random() * 2000) {
                // Pick new random target
                ai.wanderTargetX = Math.random() * canvas.width;
                ai.wanderTargetY = Math.random() * canvas.height;
                ai.wanderTimer = 0;
            }
            
            // Move towards wander target
            const dx = ai.wanderTargetX - ai.x;
            const dy = ai.wanderTargetY - ai.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > 10) {
                const dirX = dx / dist;
                const dirY = dy / dist;
                ai.vx += dirX * moveSpeed * 0.3;
                ai.vy += dirY * moveSpeed * 0.3;
            }
            
            // Random attack behavior - occasionally dash towards player
            if (now - ai.lastAttackTime > ai.attackCooldown) {
                const playerDx = localPlayer.x - ai.x;
                const playerDy = localPlayer.y - ai.y;
                const playerDist = Math.sqrt(playerDx * playerDx + playerDy * playerDy);
                
                if (playerDist < canvas.width * 0.5) {
                    // Dash towards player
                    const dirX = playerDx / playerDist;
                    const dirY = playerDy / playerDist;
                    ai.vx += dirX * moveSpeed * 2;
                    ai.vy += dirY * moveSpeed * 2;
                    ai.lastAttackTime = now;
                    ai.attackCooldown = 2000 + Math.random() * 3000; // Next attack in 2-5 seconds
                }
            }
            
            // Removed random damage - damage only occurs on collision
            
            // Apply friction
            ai.vx *= 0.9;
            ai.vy *= 0.9;
            
            // Update position
            ai.x += ai.vx;
            ai.y += ai.vy;
            
            // Boundary collision
            const radius = ai.baseRadius;
            if (ai.x - radius < 0) {
                ai.x = radius;
                ai.vx = Math.abs(ai.vx) * 0.8;
            }
            if (ai.x + radius > canvas.width) {
                ai.x = canvas.width - radius;
                ai.vx = -Math.abs(ai.vx) * 0.8;
            }
            if (ai.y - radius < 0) {
                ai.y = radius;
                ai.vy = Math.abs(ai.vy) * 0.8;
            }
            if (ai.y + radius > canvas.height) {
                ai.y = canvas.height - radius;
                ai.vy = -Math.abs(ai.vy) * 0.8;
            }
            
            // Update squash and stretch based on velocity
            const velocity = Math.sqrt(ai.vx * ai.vx + ai.vy * ai.vy);
            if (velocity > 0.5) {
                const angle = Math.atan2(ai.vy, ai.vx);
                ai.rotation = angle;
                const velocityRatio = Math.min(velocity / (moveSpeed * 2), 1);
                ai.targetScaleX = 1 + 0.3 * velocityRatio;
                ai.targetScaleY = 1 - 0.2 * velocityRatio;
            } else {
                ai.targetScaleX = 1;
                ai.targetScaleY = 1;
            }
            
            ai.scaleX += (ai.targetScaleX - ai.scaleX) * 0.1;
            ai.scaleY += (ai.targetScaleY - ai.scaleY) * 0.1;
        }
        
        function handleTrainingCollision(ai, player) {
            const dx = player.x - ai.x;
            const dy = player.y - ai.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDistance = ai.baseRadius + player.baseRadius;
            
            if (distance < minDistance && distance > 0) {
                // Prevent multiple damage from same collision (cooldown of 0.5 seconds)
                const now = Date.now();
                const collisionCooldown = 500; // 500ms cooldown
                
                // Calculate overlap
                const overlap = minDistance - distance;
                const separationX = (dx / distance) * overlap * 0.5;
                const separationY = (dy / distance) * overlap * 0.5;
                
                // Store velocities before collision to calculate recoil
                const aiVelBefore = Math.sqrt(ai.vx * ai.vx + ai.vy * ai.vy);
                const playerVelBefore = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
                
                // Push entities apart
                ai.x -= separationX;
                ai.y -= separationY;
                player.x += separationX;
                player.y += separationY;
                
                // Apply collision response (bounce effect) - same as player-player collisions
                const normalX = dx / distance;
                const normalY = dy / distance;
                const relativeVx = player.vx - ai.vx;
                const relativeVy = player.vy - ai.vy;
                const relativeSpeed = relativeVx * normalX + relativeVy * normalY;
                
                // Only apply bounce if entities are moving towards each other
                if (relativeSpeed < 0) {
                    const bounceStrength = 0.3; // How much velocity is transferred
                    const impulse = relativeSpeed * bounceStrength;
                    
                    ai.vx += impulse * normalX;
                    ai.vy += impulse * normalY;
                    player.vx -= impulse * normalX;
                    player.vy -= impulse * normalY;
                    
                    // Calculate recoil (change in velocity magnitude)
                    const aiVelAfter = Math.sqrt(ai.vx * ai.vx + ai.vy * ai.vy);
                    const playerVelAfter = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
                    
                    const aiRecoil = Math.abs(aiVelAfter - aiVelBefore);
                    const playerRecoil = Math.abs(playerVelAfter - playerVelBefore);
                    
                    // Apply damage to entity with more recoil (only if cooldown has passed)
                    if (now - ai.lastCollisionTime > collisionCooldown && 
                        (!player.lastCollisionTime || now - player.lastCollisionTime > collisionCooldown)) {
                        
                        // Determine who is hitting based on initial velocities (before collision)
                        const aiInitialSpeed = aiVelBefore;
                        const playerInitialSpeed = playerVelBefore;
                        
                        if (aiInitialSpeed > playerInitialSpeed * 1.1) {
                            // AI is hitting player (AI was moving faster)
                            const newHealth = Math.max(0, player.health - 10);
                            player.health = newHealth;
                            player.maxHealth = player.maxHealth || 100;
                            
                            if (!player.lastCollisionTime) {
                                player.lastCollisionTime = 0;
                            }
                            player.lastCollisionTime = now;
                            ai.lastCollisionTime = now;
                            
                            if (healthBar && player.id === localPlayerId) {
                                healthBar.setHealth(newHealth);
                            }
                            
                            if (newHealth <= 0 && !player.dead) {
                                player.dead = true;
                                player.visible = false;
                                if (player.id === localPlayerId) {
                                    playerDead = true;
                                    triggerDeathEffect();
                                }
                            }
                        } else if (playerInitialSpeed > aiInitialSpeed * 1.1) {
                            // Player is hitting AI (Player was moving faster)
                            const newAIHealth = Math.max(0, ai.health - 10);
                            ai.health = newAIHealth;
                            ai.lastCollisionTime = now;
                            
                            if (!player.lastCollisionTime) {
                                player.lastCollisionTime = 0;
                            }
                            player.lastCollisionTime = now;
                            
                            if (newAIHealth <= 0 && !ai.dead) {
                                ai.dead = true;
                                ai.visible = false;
                            }
                        } else {
                            // Similar speeds - both take damage
                            const newPlayerHealth = Math.max(0, player.health - 5);
                            const newAIHealth = Math.max(0, ai.health - 5);
                            
                            player.health = newPlayerHealth;
                            player.maxHealth = player.maxHealth || 100;
                            ai.health = newAIHealth;
                            
                            if (!player.lastCollisionTime) {
                                player.lastCollisionTime = 0;
                            }
                            player.lastCollisionTime = now;
                            ai.lastCollisionTime = now;
                            
                            if (healthBar && player.id === localPlayerId) {
                                healthBar.setHealth(newPlayerHealth);
                            }
                            
                            if (newPlayerHealth <= 0 && !player.dead) {
                                player.dead = true;
                                player.visible = false;
                                if (player.id === localPlayerId) {
                                    playerDead = true;
                                    triggerDeathEffect();
                                }
                            }
                            
                            if (newAIHealth <= 0 && !ai.dead) {
                                ai.dead = true;
                                ai.visible = false;
                            }
                        }
                    }
                }
            }
        }
        
        function handleTrainingAICollision(ai1, ai2) {
            const dx = ai2.x - ai1.x;
            const dy = ai2.y - ai1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDistance = ai1.baseRadius + ai2.baseRadius;
            
            if (distance < minDistance && distance > 0) {
                // Prevent multiple damage from same collision (cooldown of 0.5 seconds)
                const now = Date.now();
                const collisionCooldown = 500; // 500ms cooldown
                
                // Calculate overlap
                const overlap = minDistance - distance;
                const separationX = (dx / distance) * overlap * 0.5;
                const separationY = (dy / distance) * overlap * 0.5;
                
                // Store velocities before collision
                const ai1VelBefore = Math.sqrt(ai1.vx * ai1.vx + ai1.vy * ai1.vy);
                const ai2VelBefore = Math.sqrt(ai2.vx * ai2.vx + ai2.vy * ai2.vy);
                
                // Push entities apart
                ai1.x -= separationX;
                ai1.y -= separationY;
                ai2.x += separationX;
                ai2.y += separationY;
                
                // Apply collision response (bounce effect)
                const normalX = dx / distance;
                const normalY = dy / distance;
                const relativeVx = ai2.vx - ai1.vx;
                const relativeVy = ai2.vy - ai1.vy;
                const relativeSpeed = relativeVx * normalX + relativeVy * normalY;
                
                // Only apply bounce if entities are moving towards each other
                if (relativeSpeed < 0) {
                    const bounceStrength = 0.3;
                    const impulse = relativeSpeed * bounceStrength;
                    
                    ai1.vx += impulse * normalX;
                    ai1.vy += impulse * normalY;
                    ai2.vx -= impulse * normalX;
                    ai2.vy -= impulse * normalY;
                    
                    // Apply damage based on speed difference
                    if (now - ai1.lastCollisionTime > collisionCooldown && 
                        now - ai2.lastCollisionTime > collisionCooldown) {
                        
                        const ai1InitialSpeed = ai1VelBefore;
                        const ai2InitialSpeed = ai2VelBefore;
                        
                        if (ai1InitialSpeed > ai2InitialSpeed * 1.1) {
                            // AI1 is hitting AI2
                            const newAI2Health = Math.max(0, ai2.health - 10);
                            ai2.health = newAI2Health;
                            ai1.lastCollisionTime = now;
                            ai2.lastCollisionTime = now;
                            
                            if (newAI2Health <= 0 && !ai2.dead) {
                                ai2.dead = true;
                                ai2.visible = false;
                            }
                        } else if (ai2InitialSpeed > ai1InitialSpeed * 1.1) {
                            // AI2 is hitting AI1
                            const newAI1Health = Math.max(0, ai1.health - 10);
                            ai1.health = newAI1Health;
                            ai1.lastCollisionTime = now;
                            ai2.lastCollisionTime = now;
                            
                            if (newAI1Health <= 0 && !ai1.dead) {
                                ai1.dead = true;
                                ai1.visible = false;
                            }
                        } else {
                            // Similar speeds - both take damage
                            const newAI1Health = Math.max(0, ai1.health - 5);
                            const newAI2Health = Math.max(0, ai2.health - 5);
                            
                            ai1.health = newAI1Health;
                            ai2.health = newAI2Health;
                            ai1.lastCollisionTime = now;
                            ai2.lastCollisionTime = now;
                            
                            if (newAI1Health <= 0 && !ai1.dead) {
                                ai1.dead = true;
                                ai1.visible = false;
                            }
                            
                            if (newAI2Health <= 0 && !ai2.dead) {
                                ai2.dead = true;
                                ai2.visible = false;
                            }
                        }
                    }
                }
            }
        }
        
        function drawTrainingAI() {
            trainingAIBots.forEach(ai => {
                if (!ai.visible || ai.dead) return;
                
                ctx.save();
                ctx.translate(ai.x, ai.y);
                ctx.scale(ai.scaleX, ai.scaleY);
                ctx.rotate(ai.rotation);
                
                // Draw AI bubble
                drawBubble(0, 0, 1, 1, 0, 1, ai.color);
                
                ctx.restore();
                
                // Draw health bar
                const barWidth = ai.baseRadius * 2;
                const barHeight = 4;
                const barX = ai.x - barWidth / 2;
                const barY = ai.y - ai.baseRadius - 10;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                const healthPercent = ai.health / ai.maxHealth;
                ctx.fillStyle = healthPercent > 0.5 ? 'rgba(0, 255, 0, 0.8)' : 
                               healthPercent > 0.25 ? 'rgba(255, 255, 0, 0.8)' : 
                               'rgba(255, 0, 0, 0.8)';
                ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
            });
        }
        
        function showChallengesMenu() {
            hideAllScreens();
            document.getElementById('challengesMenuScreen').classList.add('active');
            // Update best score displays
            const spikeDodgeBestEl = document.getElementById('spikeDodgeBestScoreDisplay');
            if (spikeDodgeBestEl) {
                spikeDodgeBestEl.textContent = playerRanking.spikeDodge.bestScore;
            }
            const dodgeModeBestEl = document.getElementById('dodgeModeBestTimeDisplay');
            if (dodgeModeBestEl) {
                dodgeModeBestEl.textContent = playerRanking.dodgeMode.bestTime + 's';
            }
            const targetBreakBestEl = document.getElementById('targetBreakBestScoreDisplay');
            if (targetBreakBestEl) {
                targetBreakBestEl.textContent = playerRanking.targetBreak.bestScore;
            }
        }
        
        function updateChallengesButtonVisibility() {
            const challengesButton = document.getElementById('challengesButton');
            if (challengesButton) {
                const isAlone = (!isHost && !roomId && players.size <= 1);
                const isHosting = isHost;
                challengesButton.style.display = (isAlone || isHosting) ? 'block' : 'none';
            }
        }
        
        // Matchmaking functions
        function joinQueue(mode) {
            if (inQueue) {
                cancelQueue();
            }
            
            queueMode = mode;
            inQueue = true;
            updateQueueStatus();
            
            // Create a matchmaking room ID based on the queue mode
            // This allows players in the same queue to find each other
            matchmakingRoomId = `matchmaking-${mode}-${Date.now()}`;
            
            // Try to connect to an existing matchmaking room first
            // If no room exists, become the host
            attemptMatchmakingConnection(mode);
            
            // Update UI
            document.getElementById('queue1v1Button').style.display = 'none';
            document.getElementById('queue2v2Button').style.display = 'none';
            document.getElementById('freeForAllButton').style.display = 'none';
            document.getElementById('cancelQueueButton').style.display = 'block';
        }
        
        function attemptMatchmakingConnection(mode) {
            // Use a fixed room ID for matchmaking - first player becomes host, others connect
            const matchmakingRoomId = `matchmaking-${mode}`;
            
            // Try to become host first
            matchmakingPeer = new Peer(matchmakingRoomId, {
                secure: true
            });
            
            matchmakingPeer.on('open', (id) => {
                console.log('Matchmaking peer opened as host:', id);
                isMatchmakingHost = true;
                updateQueueStatus();
            });
            
            matchmakingPeer.on('connection', (conn) => {
                console.log('Player connected to matchmaking:', conn.peer);
                conn.on('open', () => {
                    matchmakingConnections.set(conn.peer, conn);
                    handleMatchmakingConnection(conn);
                });
                
                conn.on('error', (err) => {
                    console.error('Matchmaking connection error:', err);
                });
            });
            
            matchmakingPeer.on('error', (err) => {
                console.log('Could not become host, trying to connect as client...', err);
                // If we can't become host (room already exists), connect as client
                if (err.type === 'peer-unavailable' || err.type === 'unavailable-id') {
                    connectAsMatchmakingClient(mode);
                } else {
                    // Retry after delay
                    setTimeout(() => {
                        if (inQueue) {
                            attemptMatchmakingConnection(mode);
                        }
                    }, 2000);
                }
            });
        }
        
        function connectAsMatchmakingClient(mode) {
            const matchmakingRoomId = `matchmaking-${mode}`;
            
            // Create a new peer as client
            if (matchmakingPeer) {
                matchmakingPeer.destroy();
            }
            
            matchmakingPeer = new Peer({
                secure: true
            });
            
            matchmakingPeer.on('open', (myId) => {
                console.log('Matchmaking client peer opened:', myId);
                isMatchmakingHost = false;
                
                // Try to connect to the matchmaking room
                const conn = matchmakingPeer.connect(matchmakingRoomId);
                
                conn.on('open', () => {
                    console.log('Connected to matchmaking room as client');
                    matchmakingConnections.set(conn.peer, conn);
                    handleMatchmakingConnection(conn);
                });
                
                conn.on('error', (err) => {
                    console.error('Failed to connect to matchmaking room:', err);
                    // Retry connection
                    setTimeout(() => {
                        if (inQueue) {
                            connectAsMatchmakingClient(mode);
                        }
                    }, 2000);
                });
            });
            
            matchmakingPeer.on('error', (err) => {
                console.error('Matchmaking client peer error:', err);
                setTimeout(() => {
                    if (inQueue) {
                        connectAsMatchmakingClient(mode);
                    }
                }, 2000);
            });
        }
        
        function handleMatchmakingConnection(conn) {
            conn.on('data', (data) => {
                console.log('Matchmaking data received:', data);
                
                if (data.type === 'queue_request') {
                    // Another player is looking for a match
                    const requiredPlayers = queueMode === '1v1' ? 2 : 4;
                    const currentPlayers = matchmakingConnections.size + 1; // +1 for host
                    
                    if (currentPlayers >= requiredPlayers) {
                        // We have enough players, start the match
                        startMatchmakingMatch();
                    } else {
                        // Send queue status
                        conn.send({
                            type: 'queue_status',
                            currentPlayers: currentPlayers,
                            requiredPlayers: requiredPlayers
                        });
                    }
                } else if (data.type === 'queue_status') {
                    // Update queue status
                    updateQueueStatus();
                } else if (data.type === 'match_start') {
                    // Match is starting
                    startMatchmakingMatch();
                }
            });
            
            // Send queue request
            conn.send({
                type: 'queue_request',
                mode: queueMode,
                playerId: localPlayerId
            });
            
            // Check if we have enough players to start
            const requiredPlayers = queueMode === '1v1' ? 2 : 4;
            const currentPlayers = matchmakingConnections.size + 1; // +1 for self
            
            if (currentPlayers >= requiredPlayers) {
                // Broadcast match start to all connected players
                matchmakingConnections.forEach((c) => {
                    c.send({
                        type: 'match_start',
                        mode: queueMode
                    });
                });
                startMatchmakingMatch();
            }
        }
        
        function startMatchmakingMatch() {
            console.log('Starting matchmaking match!');
            
            // Clear matchmaking check interval
            if (matchmakingCheckInterval) {
                clearInterval(matchmakingCheckInterval);
                matchmakingCheckInterval = null;
            }
            
            // Close matchmaking connections and set up game connections
            const matchPlayers = Array.from(matchmakingConnections.keys());
            
            // Initialize teams
            initializeMatchTeams();
            
            // Convert matchmaking connections to game connections
            // For now, we'll use the existing multiplayer system
            // Set up the game as a hosted match
            roomId = `match-${Date.now()}`;
            isHost = isMatchmakingHost;
            
            if (isMatchmakingHost) {
                // Host creates the game room
                localPlayerId = roomId;
                
                // Create game peer
                if (peer) {
                    peer.destroy();
                }
                
                peer = new Peer(roomId, {
                    secure: true
                });
                
                peer.on('open', (id) => {
                    console.log('Game host opened:', id);
                    // Players will connect via matchmaking connections
                    matchmakingConnections.forEach((conn, peerId) => {
                        // Set up game connection
                        setupConnection(conn);
                    });
                });
            } else {
                // Client connects to host
                const hostConn = Array.from(matchmakingConnections.values())[0];
                if (hostConn) {
                    setupConnection(hostConn);
                }
            }
            
            // Hide queue UI and show game
            inQueue = false;
            updateQueueStatus();
            document.getElementById('queue1v1Button').style.display = 'block';
            document.getElementById('queue2v2Button').style.display = 'block';
            document.getElementById('cancelQueueButton').style.display = 'none';
            
            // Close matchmaking menu and show game
            hideAllScreens();
            document.getElementById('gameScreen').classList.add('active');
            updatePlayerList();
        }
        
        function cancelQueue() {
            inQueue = false;
            queueMode = null;
            isMatchmakingHost = false;
            matchmakingRoomId = null;
            
            if (matchmakingCheckInterval) {
                clearInterval(matchmakingCheckInterval);
                matchmakingCheckInterval = null;
            }
            
            if (matchmakingPeer) {
                matchmakingPeer.destroy();
                matchmakingPeer = null;
            }
            matchmakingConnections.clear();
            
            // Cancel FreeForAll search if active
            if (freeForAllSearching) {
                freeForAllSearching = false;
                if (freeForAllSearchTimeout) {
                    clearTimeout(freeForAllSearchTimeout);
                    freeForAllSearchTimeout = null;
                }
                if (freeForAllMatchmakingPeer) {
                    freeForAllMatchmakingPeer.destroy();
                    freeForAllMatchmakingPeer = null;
                }
            }
            
            updateQueueStatus();
            document.getElementById('queue1v1Button').style.display = 'block';
            document.getElementById('queue2v2Button').style.display = 'block';
            document.getElementById('freeForAllButton').style.display = 'block';
            document.getElementById('cancelQueueButton').style.display = 'none';
        }
        
        function updateQueueStatus() {
            const statusEl = document.getElementById('queueStatus');
            if (statusEl) {
                if (inQueue) {
                    statusEl.textContent = `Searching for ${queueMode} match...`;
                    statusEl.style.color = '#667eea';
                } else {
                    statusEl.textContent = 'Not in queue';
                    statusEl.style.color = '#aaa';
                }
            }
        }
        
        
        // Challenges/Game Modes
        function startSpikeDodge() {
            // Reset game state
            currentGameMode = 'spike_dodge';
            spikes = [];
            spikeSpawnTimer = 0;
            spikeSpeed = 2;
            spikeSpawnRate = 2000;
            gameStartTime = Date.now();
            spikesDodged = 0;
            playerDead = false;
            deathParticles = [];
            
            // Reset player position to center
            if (localPlayer) {
                localPlayer.x = canvas.width / 2;
                localPlayer.y = canvas.height / 2;
                localPlayer.vx = 0;
                localPlayer.vy = 0;
                localPlayer.visible = true;
                localPlayer.dead = false;
                localPlayer.health = 100;
                localPlayer.maxHealth = 100;
            }
            
            // Reset health
            if (healthBar) {
                healthBar.setHealth(100);
            }
            
            // Hide menu
            resumeGame();
        }
        
        function updateSpikeDodge(deltaTime) {
            if (currentGameMode !== 'spike_dodge' || playerDead) return;
            
            const elapsed = (Date.now() - gameStartTime) / 1000; // seconds
            
            // Increase difficulty over time
            spikeSpeed = 2 + elapsed * 0.5;
            spikeSpawnRate = Math.max(500, 2000 - elapsed * 50);
            
            // Spawn spikes
            spikeSpawnTimer += deltaTime;
            if (spikeSpawnTimer >= spikeSpawnRate) {
                spikeSpawnTimer = 0;
                spawnSpike();
            }
            
            // Update spikes
            for (let i = spikes.length - 1; i >= 0; i--) {
                const spike = spikes[i];
                
                // Store current position in trail for shadow effect
                spike.trail.push({ x: spike.x, y: spike.y, alpha: 1.0 });
                
                // Limit trail length and fade out older positions
                if (spike.trail.length > 8) {
                    spike.trail.shift();
                }
                spike.trail.forEach(t => {
                    t.alpha *= 0.85; // Fade out trail
                });
                
                spike.y += spikeSpeed;
                
                // Remove if off screen
                if (spike.y > canvas.height + 20) {
                    spikes.splice(i, 1);
                    spikesDodged++; // Count dodged spikes
                    continue;
                }
                
                // Check collision with player (only if player is alive and visible)
                if (localPlayer && !playerDead && localPlayer.visible !== false) {
                    const dx = spike.x - localPlayer.x;
                    const dy = spike.y - localPlayer.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const collisionDist = spike.radius + localPlayer.baseRadius;
                    
                    if (dist < collisionDist) {
                        // Player hit!
                        if (healthBar) {
                            healthBar.takeDamage(20);
                        }
                        // Remove spike
                        spikes.splice(i, 1);
                    }
                }
            }
            
            // Update death particles
            updateDeathParticles();
        }
        
        function spawnSpike() {
            const spike = {
                x: Math.random() * canvas.width,
                y: -20,
                radius: 8 + Math.random() * 12,
                color: `hsl(${Math.random() * 60 + 0}, 70%, 50%)`, // Red to orange
                trail: [] // Store previous positions for shadow effect
            };
            spikes.push(spike);
        }
        
        function drawSpikes() {
            if (currentGameMode !== 'spike_dodge') return;
            
            spikes.forEach(spike => {
                const size = spike.radius;
                
                // Draw shadow trail (after shadow effect)
                if (spike.trail && spike.trail.length > 1) {
                    for (let i = spike.trail.length - 1; i >= 0; i--) {
                        const trailPos = spike.trail[i];
                        if (trailPos.alpha > 0.05) {
                            ctx.save();
                            ctx.translate(trailPos.x, trailPos.y);
                            ctx.globalAlpha = trailPos.alpha * 0.4; // Make shadow more transparent
                            
                            // Draw shadow spike (slightly larger and darker)
                            const shadowSize = size * (1 + (1 - trailPos.alpha) * 0.3); // Slightly larger as it fades
                            const shadowColor = spike.color.replace('50%)', `${Math.max(10, 50 * trailPos.alpha)}%)`);
                            
                            ctx.fillStyle = shadowColor;
                            ctx.beginPath();
                            ctx.moveTo(0, shadowSize);
                            ctx.lineTo(-shadowSize * 0.6, -shadowSize * 0.3);
                            ctx.lineTo(shadowSize * 0.6, -shadowSize * 0.3);
                            ctx.closePath();
                            ctx.fill();
                            
                            // Add blur effect to shadow
                            ctx.shadowBlur = 10 * trailPos.alpha;
                            ctx.shadowColor = shadowColor;
                            ctx.strokeStyle = shadowColor;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(0, shadowSize);
                            ctx.lineTo(-shadowSize * 0.6, -shadowSize * 0.3);
                            ctx.lineTo(shadowSize * 0.6, -shadowSize * 0.3);
                            ctx.closePath();
                            ctx.stroke();
                            
                            ctx.restore();
                        }
                    }
                }
                
                // Draw main spike
                ctx.save();
                ctx.translate(spike.x, spike.y);
                
                // Draw 3D spike pointing downward
                // Main triangle (pointing down)
                ctx.fillStyle = spike.color;
                ctx.beginPath();
                ctx.moveTo(0, size); // Bottom point
                ctx.lineTo(-size * 0.6, -size * 0.3); // Top left
                ctx.lineTo(size * 0.6, -size * 0.3); // Top right
                ctx.closePath();
                ctx.fill();
                
                // Add darker side for 3D effect
                const darkerColor = spike.color.replace('50%)', '35%)');
                ctx.fillStyle = darkerColor;
                ctx.beginPath();
                ctx.moveTo(0, size);
                ctx.lineTo(-size * 0.6, -size * 0.3);
                ctx.lineTo(-size * 0.4, -size * 0.1);
                ctx.closePath();
                ctx.fill();
                
                // Highlight for 3D effect
                const lighterColor = spike.color.replace('50%)', '65%)');
                ctx.fillStyle = lighterColor;
                ctx.beginPath();
                ctx.moveTo(0, size);
                ctx.lineTo(size * 0.6, -size * 0.3);
                ctx.lineTo(size * 0.4, -size * 0.1);
                ctx.closePath();
                ctx.fill();
                
                // Add glow
                ctx.shadowBlur = 15;
                ctx.shadowColor = spike.color;
                ctx.strokeStyle = spike.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, size);
                ctx.lineTo(-size * 0.6, -size * 0.3);
                ctx.lineTo(size * 0.6, -size * 0.3);
                ctx.closePath();
                ctx.stroke();
                
                ctx.restore();
            });
        }
        
        // AI Fight Challenge
        function startDodgeMode() {
            currentGameMode = 'dodge_mode';
            aiBombs = [];
            dodgeModeStartTime = Date.now();
            // Set lastBombSpawnTime to 5 seconds ago, so first bomb spawns after 5 seconds
            lastBombSpawnTime = Date.now() - (bombSpawnInterval - 5000); // 5 second delay before first spawn
            playerDead = false;
            deathParticles = [];
            
            // Reset player
            if (localPlayer) {
                localPlayer.x = canvas.width / 2;
                localPlayer.y = canvas.height / 2;
                localPlayer.vx = 0;
                localPlayer.vy = 0;
                localPlayer.visible = true;
                localPlayer.dead = false;
                localPlayer.health = 100;
                localPlayer.maxHealth = 100;
            }
            
            if (healthBar) {
                healthBar.setHealth(100);
            }
            
            // Don't spawn first bomb immediately - wait 5 seconds
            // The updateDodgeMode function will handle spawning after the delay
            
            resumeGame();
        }
        
        function spawnBomb() {
            const bomb = {
                id: 'bomb_' + Date.now() + '_' + Math.random(),
                x: canvas.width / 2, // Always spawn in the center
                y: canvas.height / 2,
                vx: 0,
                vy: 0,
                baseRadius: DEFAULT_BUBBLE_SIZE,
                scaleX: 1,
                scaleY: 1,
                targetScaleX: 1,
                targetScaleY: 1,
                rotation: 0,
                dead: false,
                visible: true,
                color: `hsl(${Math.random() * 60 + 0}, 100%, 50%)`, // Red to orange colors
                pulse: 0 // For pulsing animation
            };
            aiBombs.push(bomb);
        }
        
        function updateDodgeMode(deltaTime) {
            if (currentGameMode !== 'dodge_mode' || playerDead) return;
            
            const now = Date.now();
            
            // Spawn new bomb every 10 seconds
            if (now - lastBombSpawnTime >= bombSpawnInterval) {
                spawnBomb();
                lastBombSpawnTime = now;
            }
            
            // Update bombs
            for (let i = aiBombs.length - 1; i >= 0; i--) {
                const bomb = aiBombs[i];
                if (bomb.dead) {
                    aiBombs.splice(i, 1);
                    continue;
                }
                
                updateBomb(bomb, deltaTime);
                
                // Check collision with player - instant death
                if (localPlayer && !playerDead && !localPlayer.dead) {
                    const dx = bomb.x - localPlayer.x;
                    const dy = bomb.y - localPlayer.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const collisionDist = bomb.baseRadius + localPlayer.baseRadius;
                    
                    if (dist < collisionDist) {
                        // Bomb touches player - instant death
                        playerDead = true;
                        if (localPlayer) {
                            localPlayer.dead = true;
                            localPlayer.visible = false;
                        }
                        if (healthBar) {
                            healthBar.setHealth(0, false); // Instant death, no animation
                        }
                        // Bomb explodes
                        bomb.dead = true;
                        bomb.visible = false;
                        // Trigger death effect immediately
                        triggerDeathEffect();
                    }
                }
                
                // Check collision with other bombs
                for (let j = i + 1; j < aiBombs.length; j++) {
                    const otherBomb = aiBombs[j];
                    if (otherBomb.dead) continue;
                    
                    const dx = bomb.x - otherBomb.x;
                    const dy = bomb.y - otherBomb.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const collisionDist = bomb.baseRadius + otherBomb.baseRadius;
                    
                    if (dist < collisionDist) {
                        // Bombs touch each other - both explode
                        bomb.dead = true;
                        bomb.visible = false;
                        otherBomb.dead = true;
                        otherBomb.visible = false;
                    }
                }
            }
            
            // Update death particles
            updateDeathParticles();
        }
        
        function updateBomb(bomb, deltaTime) {
            if (!localPlayer || playerDead) return;
            
            const moveSpeed = DEFAULT_MOVE_SPEED * 0.8; // Slightly slower than player
            
            // Update pulse animation
            bomb.pulse += deltaTime * 0.015;
            
            // Simple chase behavior - always chase player
            const dx = localPlayer.x - bomb.x;
            const dy = localPlayer.y - bomb.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > 0) {
                const dirX = dx / dist;
                const dirY = dy / dist;
                // Chase player directly
                bomb.vx += dirX * moveSpeed * 0.4;
                bomb.vy += dirY * moveSpeed * 0.4;
            }
            
            // Apply friction
            bomb.vx *= 0.9;
            bomb.vy *= 0.9;
            
            // Update position
            bomb.x += bomb.vx;
            bomb.y += bomb.vy;
            
            // Boundary collision
            const radius = bomb.baseRadius;
            if (bomb.x - radius < 0) {
                bomb.x = radius;
                bomb.vx = Math.abs(bomb.vx) * 0.8;
            }
            if (bomb.x + radius > canvas.width) {
                bomb.x = canvas.width - radius;
                bomb.vx = -Math.abs(bomb.vx) * 0.8;
            }
            if (bomb.y - radius < 0) {
                bomb.y = radius;
                bomb.vy = Math.abs(bomb.vy) * 0.8;
            }
            if (bomb.y + radius > canvas.height) {
                bomb.y = canvas.height - radius;
                bomb.vy = -Math.abs(bomb.vy) * 0.8;
            }
            
            // Update squash and stretch based on velocity
            const velocity = Math.sqrt(bomb.vx * bomb.vx + bomb.vy * bomb.vy);
            if (velocity > 0.5) {
                const angle = Math.atan2(bomb.vy, bomb.vx);
                bomb.rotation = angle;
                const velocityRatio = Math.min(velocity / (moveSpeed * 2), 1);
                bomb.targetScaleX = 1 + 0.3 * velocityRatio;
                bomb.targetScaleY = 1 - 0.2 * velocityRatio;
            } else {
                bomb.targetScaleX = 1;
                bomb.targetScaleY = 1;
            }
            
            bomb.scaleX += (bomb.targetScaleX - bomb.scaleX) * 0.1;
            bomb.scaleY += (bomb.targetScaleY - bomb.scaleY) * 0.1;
        }
        
        function drawBombs() {
            aiBombs.forEach(bomb => {
                if (!bomb.visible || bomb.dead) return;
                
                // Draw bomb with pulsing effect
                const pulseScale = 1 + Math.sin(bomb.pulse * 10) * 0.1;
                ctx.save();
                ctx.translate(bomb.x, bomb.y);
                ctx.scale(bomb.scaleX * pulseScale, bomb.scaleY * pulseScale);
                ctx.rotate(bomb.rotation);
                
                // Draw bomb bubble with red/orange color
                drawBubble(0, 0, 1, 1, 0, 1, bomb.color);
                
                // Draw warning symbol or inner glow
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(0, 0, bomb.baseRadius * 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });
        }
        
        // Target Break Challenge
        function startTargetBreak() {
            currentGameMode = 'target_break';
            targets = [];
            activeTargets = [];
            targetTimer = 0;
            targetTimeLimit = 0;
            targetsBroken = 0;
            playerDead = false;
            deathParticles = [];
            
            // Reset player
            if (localPlayer) {
                localPlayer.x = canvas.width / 2;
                localPlayer.y = canvas.height / 2;
                localPlayer.vx = 0;
                localPlayer.vy = 0;
                localPlayer.visible = true;
                localPlayer.dead = false;
                localPlayer.health = 100;
                localPlayer.maxHealth = 100;
            }
            
            if (healthBar) {
                healthBar.setHealth(100);
            }
            
            // Spawn first target
            spawnTargets();
            
            resumeGame();
        }
        
        function getTargetCount() {
            // Calculate how many targets should be active
            // 1 target for 0-4 broken, 2 for 5-9, 3 for 10-14, etc.
            return 1 + Math.floor(targetsBroken / 5);
        }
        
        function spawnTargets() {
            const targetCount = getTargetCount();
            const margin = 100;
            
            // Clear existing targets
            activeTargets = [];
            
            // Spawn the required number of targets
            for (let i = 0; i < targetCount; i++) {
                // Random timer between 2-5 seconds for each target
                const timeLimit = 2000 + Math.random() * 3000; // 2000-5000ms
                
                // Random position (try to avoid overlapping)
                let x, y;
                let attempts = 0;
                do {
                    x = margin + Math.random() * (canvas.width - margin * 2);
                    y = margin + Math.random() * (canvas.height - margin * 2);
                    attempts++;
                } while (attempts < 10 && activeTargets.some(t => {
                    const dx = t.x - x;
                    const dy = t.y - y;
                    return Math.sqrt(dx * dx + dy * dy) < 100; // Minimum distance
                }));
                
                activeTargets.push({
                    id: 'target_' + Date.now() + '_' + i,
                    x: x,
                    y: y,
                    radius: 30 + Math.random() * 20,
                    color: `hsl(${Math.random() * 360}, 70%, 50%)`,
                    pulse: 0,
                    broken: false,
                    timer: 0,
                    timeLimit: timeLimit
                });
            }
            
            // Set global timer to the shortest time limit
            targetTimeLimit = Math.min(...activeTargets.map(t => t.timeLimit));
            targetTimer = 0;
        }
        
        function updateTargetBreak(deltaTime) {
            if (currentGameMode !== 'target_break' || playerDead) return;
            
            // If no targets exist, spawn them immediately
            if (activeTargets.length === 0) {
                spawnTargets();
                return;
            }
            
            // Check if all targets are broken
            const allBroken = activeTargets.every(t => t.broken);
            if (allBroken) {
                // Wait a moment before spawning new targets
                setTimeout(() => {
                    if (currentGameMode === 'target_break' && !playerDead) {
                        spawnTargets();
                    }
                }, 500);
                return;
            }
            
            // Update each target's timer and check for timeout
            let anyTimeExpired = false;
            for (let i = activeTargets.length - 1; i >= 0; i--) {
                const target = activeTargets[i];
                
                if (target.broken) continue;
                
                // Update individual target timer
                target.timer += deltaTime;
                
                // Check if this target's time ran out
                if (target.timer >= target.timeLimit) {
                    // Time's up for this target - game over
                    target.broken = true;
                    anyTimeExpired = true;
                }
                
                // Update target pulse animation
                target.pulse += deltaTime * 0.01;
                
                // Check collision with player
                if (localPlayer && !playerDead && !target.broken) {
                    const dx = target.x - localPlayer.x;
                    const dy = target.y - localPlayer.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const collisionDist = target.radius + localPlayer.baseRadius;
                    
                    if (dist < collisionDist) {
                        // Target broken!
                        target.broken = true;
                        targetsBroken++;
                        
                        // Check if all targets are now broken
                        const allNowBroken = activeTargets.every(t => t.broken);
                        if (allNowBroken) {
                            // Spawn new targets after brief delay
                            setTimeout(() => {
                                if (currentGameMode === 'target_break' && !playerDead) {
                                    spawnTargets();
                                }
                            }, 500);
                        }
                    }
                }
            }
            
            // If any target's time expired, game over
            if (anyTimeExpired) {
                if (healthBar) {
                    healthBar.takeDamage(100); // Instant death
                }
                return;
            }
            
            // Update global timer (for display purposes - use shortest remaining time)
            const remainingTargets = activeTargets.filter(t => !t.broken);
            if (remainingTargets.length > 0) {
                targetTimeLimit = Math.min(...remainingTargets.map(t => t.timeLimit));
                targetTimer = Math.min(...remainingTargets.map(t => t.timer));
            }
            
            // Update death particles
            updateDeathParticles();
        }
        
        function drawTargets() {
            // Draw all active targets
            activeTargets.forEach(target => {
                if (target.broken) return;
                
                const timeLeft = target.timeLimit - target.timer;
                const timePercent = timeLeft / target.timeLimit;
                
                // Draw target with pulsing effect
                ctx.save();
                ctx.translate(target.x, target.y);
                
                // Outer ring (pulsing based on time left)
                const pulseScale = 1 + Math.sin(target.pulse * 10) * 0.1;
                ctx.scale(pulseScale, pulseScale);
                
                // Color based on time left (green -> yellow -> red)
                let targetColor = target.color;
                if (timePercent < 0.3) {
                    // Red when time is running out
                    targetColor = `hsl(${(timePercent * 300)}, 100%, 50%)`;
                } else if (timePercent < 0.6) {
                    // Yellow
                    targetColor = `hsl(${60 - (timePercent - 0.3) * 200}, 100%, 50%)`;
                }
                
                // Draw target circles
                ctx.strokeStyle = targetColor;
                ctx.lineWidth = 4;
                
                // Outer ring
                ctx.beginPath();
                ctx.arc(0, 0, target.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Middle ring
                ctx.beginPath();
                ctx.arc(0, 0, target.radius * 0.7, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner circle
                ctx.fillStyle = targetColor;
                ctx.beginPath();
                ctx.arc(0, 0, target.radius * 0.4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                
                // Draw timer bar above target
                const barWidth = target.radius * 2;
                const barHeight = 6;
                const barX = target.x - barWidth / 2;
                const barY = target.y - target.radius - 15;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                ctx.fillStyle = timePercent < 0.3 ? 'rgba(255, 0, 0, 0.8)' : 
                               timePercent < 0.6 ? 'rgba(255, 255, 0, 0.8)' : 
                               'rgba(0, 255, 0, 0.8)';
                ctx.fillRect(barX, barY, barWidth * timePercent, barHeight);
            });
        }
        
        function triggerDeathEffect() {
            if (!localPlayer) return;
            
            // Create death particles
            for (let i = 0; i < 30; i++) {
                const angle = (Math.PI * 2 * i) / 30;
                const speed = 2 + Math.random() * 3;
                deathParticles.push({
                    x: localPlayer.x,
                    y: localPlayer.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.03,
                    size: 3 + Math.random() * 5,
                    color: localPlayer.color || 'hsl(200, 70%, 60%)'
                });
            }
            
            // Hide player
            if (localPlayer) {
                localPlayer.visible = false;
            }
            
            // Show death screen if in challenge mode
            if (currentGameMode === 'spike_dodge' || currentGameMode === 'dodge_mode' || currentGameMode === 'target_break') {
                setTimeout(() => {
                    showDeathScreen();
                }, 1000);
            }
        }
        
        function updateDeathParticles() {
            for (let i = deathParticles.length - 1; i >= 0; i--) {
                const particle = deathParticles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= particle.decay;
                particle.vx *= 0.98;
                particle.vy *= 0.98;
                
                if (particle.life <= 0) {
                    deathParticles.splice(i, 1);
                }
            }
        }
        
        function drawDeathParticles() {
            deathParticles.forEach(particle => {
                ctx.save();
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }
        
        function showDeathScreen() {
            let wasNewRecord = false;
            let scoreText = '';
            let bestScoreText = '';
            let retryFunction = '';
            let exitFunction = '';
            
            // Update stats based on current game mode
            if (currentGameMode === 'spike_dodge') {
                wasNewRecord = spikesDodged > playerRanking.spikeDodge.bestScore;
                if (wasNewRecord) {
                    playerRanking.spikeDodge.bestScore = spikesDodged;
                }
                playerRanking.spikeDodge.totalPlayed++;
                playerRanking.spikeDodge.totalSpikesDodged += spikesDodged;
                playerRanking.spikeDodge.averageScore = Math.round(playerRanking.spikeDodge.totalSpikesDodged / playerRanking.spikeDodge.totalPlayed);
                scoreText = `Spikes Dodged: <span id="scoreCount" style="color: #667eea; font-weight: 600;">${spikesDodged}</span>`;
                bestScoreText = `Best Score: <span id="bestScoreDisplay" style="color: #ffd700; font-weight: 600;">${playerRanking.spikeDodge.bestScore}</span>`;
                retryFunction = 'retrySpikeDodge()';
                exitFunction = 'exitSpikeDodge()';
            } else if (currentGameMode === 'dodge_mode') {
                const survivalTime = Math.floor((Date.now() - dodgeModeStartTime) / 1000);
                wasNewRecord = survivalTime > playerRanking.dodgeMode.bestTime;
                if (wasNewRecord) {
                    playerRanking.dodgeMode.bestTime = survivalTime;
                }
                playerRanking.dodgeMode.totalPlayed++;
                playerRanking.dodgeMode.totalTimeSurvived += survivalTime;
                scoreText = `Time Survived: <span id="scoreCount" style="color: #667eea; font-weight: 600;">${survivalTime}s</span>`;
                bestScoreText = `Best Time: <span id="bestScoreDisplay" style="color: #ffd700; font-weight: 600;">${playerRanking.dodgeMode.bestTime}s</span>`;
                retryFunction = 'retryDodgeMode()';
                exitFunction = 'exitDodgeMode()';
            } else if (currentGameMode === 'target_break') {
                wasNewRecord = targetsBroken > playerRanking.targetBreak.bestScore;
                if (wasNewRecord) {
                    playerRanking.targetBreak.bestScore = targetsBroken;
                    targetBreakBestScore = targetsBroken;
                }
                playerRanking.targetBreak.totalPlayed++;
                playerRanking.targetBreak.totalTargetsBroken += targetsBroken;
                scoreText = `Targets Broken: <span id="scoreCount" style="color: #667eea; font-weight: 600;">${targetsBroken}</span>`;
                bestScoreText = `Best Score: <span id="bestScoreDisplay" style="color: #ffd700; font-weight: 600;">${playerRanking.targetBreak.bestScore}</span>`;
                retryFunction = 'retryTargetBreak()';
                exitFunction = 'exitTargetBreak()';
            }
            
            saveRanking();
            
            // Award orbs - score = orbs earned
            let orbsEarned = 0;
            let randomUnlock = null;
            
            if (currentGameMode === 'spike_dodge') {
                orbsEarned = spikesDodged; // Score = orbs
                if (Math.random() < 0.1) { // 10% chance for random unlock
                    randomUnlock = unlockRandomColor();
                }
            } else if (currentGameMode === 'dodge_mode') {
                const survivalTime = Math.floor((Date.now() - dodgeModeStartTime) / 1000);
                orbsEarned = survivalTime; // Score = orbs
                if (Math.random() < 0.15) { // 15% chance for random unlock
                    randomUnlock = unlockRandomColor();
                }
            } else if (currentGameMode === 'target_break') {
                orbsEarned = targetsBroken; // Score = orbs
                if (Math.random() < 0.12) { // 12% chance for random unlock
                    randomUnlock = unlockRandomColor();
                }
            }
            
            if (orbsEarned > 0) {
                addOrbs(orbsEarned);
                // Show notification in top-right after a brief delay to ensure death screen is displayed
                setTimeout(() => {
                    showOrbNotification(orbsEarned);
                }, 100);
            }
            
            // Create death screen overlay
            const deathScreen = document.getElementById('deathScreen');
            if (deathScreen) {
                deathScreen.style.display = 'block';
                const scoreCountEl = document.getElementById('scoreCount');
                if (scoreCountEl) {
                    if (currentGameMode === 'spike_dodge') {
                        scoreCountEl.textContent = spikesDodged;
                    } else if (currentGameMode === 'dodge_mode') {
                        scoreCountEl.textContent = Math.floor((Date.now() - dodgeModeStartTime) / 1000) + 's';
                    } else if (currentGameMode === 'target_break') {
                        scoreCountEl.textContent = targetsBroken;
                    }
                }
                const bestScoreEl = document.getElementById('bestScoreDisplay');
                if (bestScoreEl) {
                    if (currentGameMode === 'spike_dodge') {
                        bestScoreEl.textContent = playerRanking.spikeDodge.bestScore;
                    } else if (currentGameMode === 'dodge_mode') {
                        bestScoreEl.textContent = playerRanking.dodgeMode.bestTime + 's';
                    } else if (currentGameMode === 'target_break') {
                        bestScoreEl.textContent = playerRanking.targetBreak.bestScore;
                    }
                }
                const newRecordEl = document.getElementById('newRecordDisplay');
                if (newRecordEl) {
                    newRecordEl.style.display = wasNewRecord ? 'block' : 'none';
                }
            } else {
                // Create death screen if it doesn't exist
                const screen = document.createElement('div');
                screen.id = 'deathScreen';
                screen.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                    color: white;
                    font-family: system-ui, -apple-system, sans-serif;
                `;
                screen.innerHTML = `
                    <h2 style="font-size: 32px; margin-bottom: 20px;">Game Over!</h2>
                    <div id="newRecordDisplay" style="font-size: 24px; color: #ffd700; margin-bottom: 20px; font-weight: 600; text-shadow: 0 0 10px rgba(255, 215, 0, 0.8); text-align: center; width: 100%; ${wasNewRecord ? '' : 'display: none;'}">
                         NEW RECORD! 
                    </div>
                    <div id="orbRewardDisplay" style="font-size: 18px; color: #ffd700; margin-bottom: 10px; font-weight: 600; ${orbsEarned > 0 ? '' : 'display: none;'}">+${orbsEarned} Orbs Earned! </div>
                    <div id="unlockRewardDisplay" style="font-size: 18px; color: #00ff88; margin-bottom: 10px; font-weight: 600; ${randomUnlock ? '' : 'display: none;'}">${randomUnlock ? ` Unlocked: ${randomUnlock.name}!` : ''}</div>
                    <p style="font-size: 18px; margin-bottom: 10px; text-align: center;">${scoreText}</p>
                    <p style="font-size: 14px; color: #aaa; margin-bottom: 30px; text-align: center;">${bestScoreText}</p>
                    <button onclick="${retryFunction}" style="
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                        border: none;
                        padding: 15px 30px;
                        border-radius: 8px;
                        font-size: 16px;
                        font-weight: 600;
                        cursor: pointer;
                        margin: 10px;
                    ">Try Again</button>
                    <button onclick="${exitFunction}" style="
                        background: rgba(100, 100, 100, 0.5);
                        color: white;
                        border: none;
                        padding: 15px 30px;
                        border-radius: 8px;
                        font-size: 16px;
                        font-weight: 600;
                        cursor: pointer;
                        margin: 10px;
                    ">Go Back to Lobby</button>
                `;
                document.body.appendChild(screen);
            }
        }
        
        function retrySpikeDodge() {
            // Hide death screen
            const deathScreen = document.getElementById('deathScreen');
            if (deathScreen) {
                deathScreen.style.display = 'none';
            }
            
            // IMPORTANT: Reset player dead state FIRST before anything else
            playerDead = false;
            
            // Reset all game state before restarting
            deathParticles = [];
            spikesDodged = 0;
            spikes = [];
            spikeSpawnTimer = 0;
            
            // Reset player state completely
            if (localPlayer) {
                localPlayer.visible = true;
                localPlayer.dead = false;
                localPlayer.health = 100;
                localPlayer.maxHealth = 100;
                localPlayer.x = canvas.width / 2;
                localPlayer.y = canvas.height / 2;
                localPlayer.vx = 0;
                localPlayer.vy = 0;
            }
            
            // Reset health bar
            if (healthBar) {
                healthBar.setHealth(100, false); // Set without animation for instant reset
            }
            
            // Restart the game mode - ensure it's set properly
            currentGameMode = 'spike_dodge';
            spikeSpeed = 2;
            spikeSpawnRate = 2000;
            gameStartTime = Date.now();
            
            // Close menu if open
            const menuWidget = document.getElementById('menuWidget');
            if (menuWidget && menuWidget.classList.contains('expanded')) {
                menuWidget.classList.remove('expanded');
                menuWidget.classList.add('collapsed');
                menuVisible = false;
            }
            
            // Force a small delay to ensure state is fully reset before game continues
            // This ensures playerDead check in updateSpikeDodge passes
            setTimeout(() => {
                // Double-check playerDead is false
                playerDead = false;
                if (localPlayer) {
                    localPlayer.dead = false;
                    localPlayer.visible = true;
                }
            }, 10);
        }
        
        function exitSpikeDodge() {
            // Hide death screen
            const deathScreen = document.getElementById('deathScreen');
            if (deathScreen) {
                deathScreen.style.display = 'none';
            }
            
            // Exit game mode
            currentGameMode = null;
            spikes = [];
            playerDead = false;
            deathParticles = [];
            spikesDodged = 0;
            
            // Reset player
            if (localPlayer) {
                localPlayer.visible = true;
                localPlayer.x = canvas.width / 2;
                localPlayer.y = canvas.height / 2;
                localPlayer.vx = 0;
                localPlayer.vy = 0;
            }
            
            // Reset health
            if (healthBar) {
                healthBar.setHealth(100);
            }
            
            // Go back to lobby
            goBackToLobby();
        }
        
        // AI Fight Challenge retry/exit
        function retryDodgeMode() {
            const deathScreen = document.getElementById('deathScreen');
            if (deathScreen) {
                deathScreen.style.display = 'none';
            }
            playerDead = false;
            deathParticles = [];
            aiBombs = [];
            
            if (localPlayer) {
                localPlayer.visible = true;
                localPlayer.dead = false;
                localPlayer.health = 100;
                localPlayer.maxHealth = 100;
                localPlayer.x = canvas.width / 2;
                localPlayer.y = canvas.height / 2;
                localPlayer.vx = 0;
                localPlayer.vy = 0;
            }
            
            if (healthBar) {
                healthBar.setHealth(100, false);
            }
            
            currentGameMode = 'dodge_mode';
            dodgeModeStartTime = Date.now();
            lastBombSpawnTime = Date.now();
            spawnBomb();
            
            const menuWidget = document.getElementById('menuWidget');
            if (menuWidget && menuWidget.classList.contains('expanded')) {
                menuWidget.classList.remove('expanded');
                menuWidget.classList.add('collapsed');
                menuVisible = false;
            }
            
            setTimeout(() => {
                playerDead = false;
                if (localPlayer) {
                    localPlayer.dead = false;
                    localPlayer.visible = true;
                }
            }, 10);
        }
        
        function exitDodgeMode() {
            const deathScreen = document.getElementById('deathScreen');
            if (deathScreen) {
                deathScreen.style.display = 'none';
            }
            currentGameMode = null;
            aiBombs = [];
            playerDead = false;
            deathParticles = [];
            
            if (localPlayer) {
                localPlayer.visible = true;
                localPlayer.x = canvas.width / 2;
                localPlayer.y = canvas.height / 2;
                localPlayer.vx = 0;
                localPlayer.vy = 0;
            }
            
            if (healthBar) {
                healthBar.setHealth(100);
            }
            
            goBackToLobby();
        }
        
        // Target Break Challenge retry/exit
        function retryTargetBreak() {
            const deathScreen = document.getElementById('deathScreen');
            if (deathScreen) {
                deathScreen.style.display = 'none';
            }
            playerDead = false;
            deathParticles = [];
            targets = [];
            currentTarget = null;
            targetTimer = 0;
            targetTimeLimit = 0;
            targetsBroken = 0;
            
            if (localPlayer) {
                localPlayer.visible = true;
                localPlayer.dead = false;
                localPlayer.health = 100;
                localPlayer.maxHealth = 100;
                localPlayer.x = canvas.width / 2;
                localPlayer.y = canvas.height / 2;
                localPlayer.vx = 0;
                localPlayer.vy = 0;
            }
            
            if (healthBar) {
                healthBar.setHealth(100, false);
            }
            
            currentGameMode = 'target_break';
            spawnTarget();
            
            const menuWidget = document.getElementById('menuWidget');
            if (menuWidget && menuWidget.classList.contains('expanded')) {
                menuWidget.classList.remove('expanded');
                menuWidget.classList.add('collapsed');
                menuVisible = false;
            }
            
            setTimeout(() => {
                playerDead = false;
                if (localPlayer) {
                    localPlayer.dead = false;
                    localPlayer.visible = true;
                }
            }, 10);
        }
        
        function exitTargetBreak() {
            const deathScreen = document.getElementById('deathScreen');
            if (deathScreen) {
                deathScreen.style.display = 'none';
            }
            currentGameMode = null;
            targets = [];
            currentTarget = null;
            playerDead = false;
            deathParticles = [];
            targetsBroken = 0;
            
            if (localPlayer) {
                localPlayer.visible = true;
                localPlayer.x = canvas.width / 2;
                localPlayer.y = canvas.height / 2;
                localPlayer.vx = 0;
                localPlayer.vy = 0;
            }
            
            if (healthBar) {
                healthBar.setHealth(100);
            }
            
            goBackToLobby();
        }
        
        function goBackToLobby() {
            // If in a hosted game, all players stay in the game
            if (isHost || roomId) {
                // Just close the menu and return to game
                const menuWidget = document.getElementById('menuWidget');
                if (menuWidget) {
                    menuWidget.classList.remove('expanded');
                    menuWidget.classList.add('collapsed');
                    menuVisible = false;
                }
            } else {
                // If alone, return to main menu
                const menuWidget = document.getElementById('menuWidget');
                if (menuWidget) {
                    menuWidget.classList.remove('expanded');
                    menuWidget.classList.add('collapsed');
                    menuVisible = false;
                }
                showMainMenu();
            }
        }
        
        function checkMatchVictory() {
            // Check if all players on one team are dead
            let team1Alive = 0;
            let team2Alive = 0;
            let winnerName = null;
            let winnerPlayer = null;
            let isLocalPlayerWinner = false;
            
            players.forEach((player, playerId) => {
                const team = playerTeams.get(playerId);
                if (!player.dead && player.health > 0) {
                    if (team === 1) {
                        team1Alive++;
                    } else if (team === 2) {
                        team2Alive++;
                    }
                }
            });
            
            // Determine winner
            if (team1Alive === 0 && team2Alive > 0) {
                // Team 2 wins - find first alive player from team 2
                players.forEach((player, playerId) => {
                    if (playerTeams.get(playerId) === 2 && !player.dead && player.health > 0 && !winnerPlayer) {
                        winnerPlayer = player;
                        if (playerId === localPlayerId) {
                            isLocalPlayerWinner = true;
                        }
                    }
                });
                if (winnerPlayer) {
                    winnerName = winnerPlayer.name || 'Team 2 Player';
                }
            } else if (team2Alive === 0 && team1Alive > 0) {
                // Team 1 wins - find first alive player from team 1
                players.forEach((player, playerId) => {
                    if (playerTeams.get(playerId) === 1 && !player.dead && player.health > 0 && !winnerPlayer) {
                        winnerPlayer = player;
                        if (playerId === localPlayerId) {
                            isLocalPlayerWinner = true;
                        }
                    }
                });
                if (winnerPlayer) {
                    winnerName = winnerPlayer.name || 'Team 1 Player';
                }
            }
            
            if (winnerName) {
                // Update ranking for local player
                if (matchInProgress && (queueMode === '1v1' || queueMode === '2v2')) {
                    const oldRating = playerRanking.rating;
                    if (isLocalPlayerWinner) {
                        updateRanking('win');
                    } else {
                        // Check if local player is dead
                        const localPlayerDead = localPlayer && (localPlayer.dead || localPlayer.health <= 0);
                        if (localPlayerDead) {
                            updateRanking('loss');
                        }
                    }
                }
                showVictoryScreen(winnerName, isLocalPlayerWinner);
            }
        }
        
        function showVictoryScreen(winnerName, isLocalPlayerWinner = false) {
            // Create or show victory screen
            const victoryScreen = document.getElementById('victoryScreen');
            const tier = getRankTier(playerRanking.rating);
            const ratingChange = isLocalPlayerWinner ? '+' : '-';
            
            if (victoryScreen) {
                victoryScreen.style.display = 'flex';
                document.getElementById('winnerName').textContent = winnerName;
                // Update ranking display if it exists
                const rankingDisplay = document.getElementById('rankingDisplay');
                if (rankingDisplay) {
                    rankingDisplay.innerHTML = `
                        <div style="margin: 20px 0; padding: 15px; background: rgba(102, 126, 234, 0.1); border-radius: 8px; border: 1px solid rgba(102, 126, 234, 0.3);">
                            <div style="font-size: 18px; margin-bottom: 10px; color: ${tier.color}; font-weight: 600;">${tier.name}</div>
                            <div style="font-size: 14px; color: #aaa;">Rating: ${playerRanking.rating} ${ratingChange}</div>
                            <div style="font-size: 12px; color: #888; margin-top: 5px;">W: ${playerRanking.wins} | L: ${playerRanking.losses} | D: ${playerRanking.draws}</div>
                        </div>
                    `;
                }
            } else {
                // Create victory screen if it doesn't exist
                const screen = document.createElement('div');
                screen.id = 'victoryScreen';
                screen.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.9);
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    z-index: 10001;
                    color: white;
                    font-family: system-ui, -apple-system, sans-serif;
                `;
                screen.innerHTML = `
                    <h2 style="font-size: 48px; margin-bottom: 20px; color: #667eea; text-shadow: 0 0 20px rgba(102, 126, 234, 0.8);">${isLocalPlayerWinner ? 'Victory!' : 'Defeat'}</h2>
                    <p style="font-size: 24px; margin-bottom: 20px;"><span id="winnerName">${winnerName}</span> ${isLocalPlayerWinner ? 'Won!' : 'Won the match!'}</p>
                    <div id="rankingDisplay" style="margin: 20px 0; padding: 15px; background: rgba(102, 126, 234, 0.1); border-radius: 8px; border: 1px solid rgba(102, 126, 234, 0.3); text-align: center;">
                        <div style="font-size: 18px; margin-bottom: 10px; color: ${tier.color}; font-weight: 600;">${tier.name}</div>
                        <div style="font-size: 14px; color: #aaa;">Rating: ${playerRanking.rating}</div>
                        <div style="font-size: 12px; color: #888; margin-top: 5px;">W: ${playerRanking.wins} | L: ${playerRanking.losses} | D: ${playerRanking.draws}</div>
                        ${playerRanking.winStreak > 0 ? `<div style="font-size: 12px; color: #ffd700; margin-top: 5px;"> Win Streak: ${playerRanking.winStreak}</div>` : ''}
                    </div>
                    <button onclick="goBackToLobbyFromVictory()" style="
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                        border: none;
                        padding: 15px 30px;
                        border-radius: 8px;
                        font-size: 16px;
                        font-weight: 600;
                        cursor: pointer;
                        margin: 10px;
                    ">Go Back to Lobby</button>
                    <button onclick="searchNewGame()" style="
                        background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
                        color: white;
                        border: none;
                        padding: 15px 30px;
                        border-radius: 8px;
                        font-size: 16px;
                        font-weight: 600;
                        cursor: pointer;
                        margin: 10px;
                    ">Search for a New Game</button>
                `;
                document.body.appendChild(screen);
            }
        }
        
        function goBackToLobbyFromVictory() {
            // Hide victory screen
            const victoryScreen = document.getElementById('victoryScreen');
            if (victoryScreen) {
                victoryScreen.style.display = 'none';
            }
            
            // Reset match state
            matchInProgress = false;
            playerTeams.clear();
            team1Players = [];
            team2Players = [];
            
            // Reset all players
            players.forEach((player, playerId) => {
                player.health = 100;
                player.visible = true;
                player.dead = false;
                if (healthBar && playerId === localPlayerId) {
                    healthBar.setHealth(100);
                }
            });
            
            playerDead = false;
            
            // Go back to lobby
            goBackToLobby();
        }
        
        function searchNewGame() {
            // Hide victory screen
            const victoryScreen = document.getElementById('victoryScreen');
            if (victoryScreen) {
                victoryScreen.style.display = 'none';
            }
            
            // Reset match state
            matchInProgress = false;
            playerTeams.clear();
            team1Players = [];
            team2Players = [];
            
            // Reset all players
            players.forEach((player, playerId) => {
                player.health = 100;
                player.visible = true;
                player.dead = false;
                if (healthBar && playerId === localPlayerId) {
                    healthBar.setHealth(100);
                }
            });
            
            playerDead = false;
            
            // Show VS menu to search again
            showVSMenu();
        }
        
        // Initialize teams when match starts (placeholder - would be set by matchmaking)
        function initializeMatchTeams() {
            if (queueMode === '1v1') {
                // Assign teams for 1v1
                let team = 1;
                players.forEach((player, playerId) => {
                    playerTeams.set(playerId, team);
                    if (team === 1) {
                        team1Players.push(playerId);
                    } else {
                        team2Players.push(playerId);
                    }
                    team = 2;
                });
            } else if (queueMode === '2v2') {
                // Assign teams for 2v2
                let team = 1;
                players.forEach((player, playerId) => {
                    playerTeams.set(playerId, team);
                    if (team === 1) {
                        team1Players.push(playerId);
                    } else {
                        team2Players.push(playerId);
                    }
                    // Alternate teams every 2 players
                    if (team1Players.length === 2) {
                        team = 2;
                    }
                });
            }
            matchInProgress = true;
        }
        
        function showMultiplayerMenu() {
            hideAllScreens();
            // If already in a game, show the game screen instead
            if (isHost || roomId) {
                // Update room ID display
                const roomIdDisplay = document.getElementById('roomIdDisplay');
                if (roomIdDisplay && roomId) {
                    roomIdDisplay.textContent = 'Room ID: ' + roomId;
                }
                document.getElementById('gameScreen').classList.add('active');
                updatePlayerList();
            } else {
                document.getElementById('multiplayerMenuScreen').classList.add('active');
            }
        }
        
        function showJoinScreen() {
            hideAllScreens();
            document.getElementById('joinGameScreen').classList.add('active');
        }
        
        function showControlsMenu() {
            hideAllScreens();
            document.getElementById('controlsScreen').classList.add('active');
        }
        
        function showSettingsMenu() {
            hideAllScreens();
            document.getElementById('settingsScreen').classList.add('active');
            loadSettings();
            updateSettingsDisplay();
        }
        
        function loadSettings() {
            try {
                const saved = localStorage.getItem('gameSettings');
                if (saved) {
                    gameSettings = JSON.parse(saved);
                    // Apply loaded settings
                    applyResolution(gameSettings.resolution);
                    targetFPS = gameSettings.fpsLimit;
                    frameInterval = targetFPS > 0 ? 1000 / targetFPS : 0;
                }
            } catch (e) {
                console.warn('Could not load settings from localStorage:', e);
            }
        }
        
        function saveSettings() {
            try {
                localStorage.setItem('gameSettings', JSON.stringify(gameSettings));
            } catch (e) {
                console.warn('Could not save settings to localStorage:', e);
            }
        }
        
        function updateSettingsDisplay() {
            const resolutionSelect = document.getElementById('resolutionSelect');
            const fpsSelect = document.getElementById('fpsSelect');
            const graphicsSelect = document.getElementById('graphicsSelect');
            const volumeSlider = document.getElementById('volumeSlider');
            const volumeDisplay = document.getElementById('volumeDisplay');
            const showFPSCheckbox = document.getElementById('showFPSCheckbox');
            const vsyncCheckbox = document.getElementById('vsyncCheckbox');
            
            if (resolutionSelect) resolutionSelect.value = gameSettings.resolution;
            if (fpsSelect) fpsSelect.value = gameSettings.fpsLimit;
            if (graphicsSelect) graphicsSelect.value = gameSettings.graphicsQuality;
            if (volumeSlider) {
                volumeSlider.value = gameSettings.masterVolume;
                if (volumeDisplay) volumeDisplay.textContent = gameSettings.masterVolume + '%';
            }
            if (showFPSCheckbox) showFPSCheckbox.checked = gameSettings.showFPS;
            if (vsyncCheckbox) vsyncCheckbox.checked = gameSettings.vsync;
        }
        
        function applyResolution(resolution) {
            const [width, height] = resolution.split('x').map(Number);
            BASE_WIDTH = width;
            BASE_HEIGHT = height;
            BASE_ASPECT_RATIO = BASE_WIDTH / BASE_HEIGHT;
            resizeCanvas();
        }
        
        function applySettings() {
            const resolutionSelect = document.getElementById('resolutionSelect');
            const fpsSelect = document.getElementById('fpsSelect');
            const graphicsSelect = document.getElementById('graphicsSelect');
            const volumeSlider = document.getElementById('volumeSlider');
            const showFPSCheckbox = document.getElementById('showFPSCheckbox');
            const vsyncCheckbox = document.getElementById('vsyncCheckbox');
            
            if (resolutionSelect) {
                gameSettings.resolution = resolutionSelect.value;
                applyResolution(gameSettings.resolution);
            }
            if (fpsSelect) {
                gameSettings.fpsLimit = parseInt(fpsSelect.value);
                targetFPS = gameSettings.fpsLimit;
                frameInterval = targetFPS > 0 ? 1000 / targetFPS : 0;
            }
            if (graphicsSelect) {
                gameSettings.graphicsQuality = graphicsSelect.value;
            }
            if (volumeSlider) {
                gameSettings.masterVolume = parseInt(volumeSlider.value);
            }
            if (showFPSCheckbox) {
                gameSettings.showFPS = showFPSCheckbox.checked;
            }
            if (vsyncCheckbox) {
                gameSettings.vsync = vsyncCheckbox.checked;
            }
            
            saveSettings();
            alert('Settings applied!');
        }
        
        function resetSettings() {
            gameSettings = {
                resolution: '1920x1080',
                fpsLimit: 60,
                graphicsQuality: 'medium',
                masterVolume: 100,
                showFPS: false,
                vsync: true
            };
            updateSettingsDisplay();
            applySettings();
        }
        
        // Volume slider update
        document.addEventListener('DOMContentLoaded', () => {
            const volumeSlider = document.getElementById('volumeSlider');
            const volumeDisplay = document.getElementById('volumeDisplay');
            if (volumeSlider && volumeDisplay) {
                volumeSlider.addEventListener('input', (e) => {
                    volumeDisplay.textContent = e.target.value + '%';
                });
            }
        });
        
        let currentShopCategory = 'colors';
        
        function showShopMenu() {
            hideAllScreens();
            document.getElementById('shopScreen').classList.add('active');
            switchShopCategory('colors');
            updateOrbDisplay();
        }
        
        function switchShopCategory(category) {
            currentShopCategory = category;
            
            // Update button styles
            const colorsBtn = document.getElementById('shopCategoryColors');
            const aurasBtn = document.getElementById('shopCategoryAuras');
            const particlesBtn = document.getElementById('shopCategoryParticles');
            if (colorsBtn) colorsBtn.style.background = category === 'colors' ? 'rgba(102, 126, 234, 0.3)' : '';
            if (aurasBtn) aurasBtn.style.background = category === 'auras' ? 'rgba(102, 126, 234, 0.3)' : '';
            if (particlesBtn) particlesBtn.style.background = category === 'particles' ? 'rgba(102, 126, 234, 0.3)' : '';
            
            updateShopDisplay();
        }
        
        function updateShopDisplay() {
            const container = document.getElementById('shopItemsContainer');
            if (!container) return;
            
            if (currentShopCategory === 'colors') {
                container.innerHTML = availableColors.map(color => {
                    const isUnlocked = unlockedColors.includes(color.id);
                    const canAfford = playerCurrency.orbs >= color.price;
                    
                    return `
                        <div style="background: rgba(102, 126, 234, 0.1); padding: 10px; border-radius: 6px; margin-bottom: 10px; border: 1px solid ${isUnlocked ? 'rgba(0, 255, 0, 0.3)' : 'rgba(102, 126, 234, 0.3)'};">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                <div style="width: 40px; height: 40px; border-radius: 50%; background: ${color.hex}; border: 2px solid #fff;"></div>
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; color: #fff; margin-bottom: 3px;">${color.name}</div>
                                    ${isUnlocked ? 
                                        '<div style="color: #00ff88; font-size: 11px;"> Unlocked</div>' : 
                                        `<div style="color: #ffd700; font-size: 11px;">Price: ${color.price} Orbs</div>`
                                    }
                                </div>
                            </div>
                            ${!isUnlocked ? (
                                canAfford ? 
                                    `<button class="menu-button" onclick="purchaseColor('${color.id}')" style="width: 100%; padding: 8px; font-size: 12px;">Buy</button>` :
                                    `<button class="menu-button" style="width: 100%; padding: 8px; font-size: 12px; opacity: 0.5; cursor: not-allowed;" disabled>Not Enough Orbs</button>`
                            ) : (
                                selectedColorId === color.id ?
                                    '<div style="text-align: center; color: #00ff88; font-size: 11px; padding: 5px;"> Selected</div>' :
                                    `<button class="menu-button" onclick="selectColor('${color.id}')" style="width: 100%; padding: 8px; font-size: 12px;">Select</button>`
                            )}
                        </div>
                    `;
                }).join('');
            } else if (currentShopCategory === 'auras') {
                container.innerHTML = availableAuras.filter(aura => aura.id !== 'none').map(aura => {
                    const isUnlocked = unlockedAuras.includes(aura.id);
                    const canAfford = playerCurrency.orbs >= aura.price;
                    
                    return `
                        <div style="background: rgba(102, 126, 234, 0.1); padding: 10px; border-radius: 6px; margin-bottom: 10px; border: 1px solid ${isUnlocked ? 'rgba(0, 255, 0, 0.3)' : 'rgba(102, 126, 234, 0.3)'};">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                <div style="width: 40px; height: 40px; border-radius: 50%; background: ${aura.color || 'rgba(102, 126, 234, 0.2)'}; border: 2px solid #fff;"></div>
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; color: #fff; margin-bottom: 3px;">${aura.name}</div>
                                    ${isUnlocked ? 
                                        '<div style="color: #00ff88; font-size: 11px;"> Unlocked</div>' : 
                                        `<div style="color: #ffd700; font-size: 11px;">Price: ${aura.price} Orbs</div>`
                                    }
                                </div>
                            </div>
                            ${!isUnlocked ? (
                                canAfford ? 
                                    `<button class="menu-button" onclick="purchaseAura('${aura.id}')" style="width: 100%; padding: 8px; font-size: 12px;">Buy</button>` :
                                    `<button class="menu-button" style="width: 100%; padding: 8px; font-size: 12px; opacity: 0.5; cursor: not-allowed;" disabled>Not Enough Orbs</button>`
                            ) : (
                                selectedAuraId === aura.id ?
                                    '<div style="text-align: center; color: #00ff88; font-size: 11px; padding: 5px;"> Selected</div>' :
                                    `<button class="menu-button" onclick="selectAura('${aura.id}')" style="width: 100%; padding: 8px; font-size: 12px;">Select</button>`
                            )}
                        </div>
                    `;
                }).join('');
            } else if (currentShopCategory === 'particles') {
                container.innerHTML = availableParticles.filter(particle => particle.id !== 'none').map(particle => {
                    const isUnlocked = unlockedParticles.includes(particle.id);
                    const canAfford = playerCurrency.orbs >= particle.price;
                    
                    return `
                        <div style="background: rgba(102, 126, 234, 0.1); padding: 10px; border-radius: 6px; margin-bottom: 10px; border: 1px solid ${isUnlocked ? 'rgba(0, 255, 0, 0.3)' : 'rgba(102, 126, 234, 0.3)'};">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                <div style="width: 40px; height: 40px; border-radius: 50%; background: ${particle.color || 'rgba(102, 126, 234, 0.2)'}; border: 2px solid #fff;"></div>
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; color: #fff; margin-bottom: 3px;">${particle.name}</div>
                                    ${isUnlocked ? 
                                        '<div style="color: #00ff88; font-size: 11px;"> Unlocked</div>' : 
                                        `<div style="color: #ffd700; font-size: 11px;">Price: ${particle.price} Orbs</div>`
                                    }
                                </div>
                            </div>
                            ${!isUnlocked ? (
                                canAfford ? 
                                    `<button class="menu-button" onclick="purchaseParticle('${particle.id}')" style="width: 100%; padding: 8px; font-size: 12px;">Buy</button>` :
                                    `<button class="menu-button" style="width: 100%; padding: 8px; font-size: 12px; opacity: 0.5; cursor: not-allowed;" disabled>Not Enough Orbs</button>`
                            ) : (
                                selectedParticleId === particle.id ?
                                    '<div style="text-align: center; color: #00ff88; font-size: 11px; padding: 5px;"> Selected</div>' :
                                    `<button class="menu-button" onclick="selectParticle('${particle.id}')" style="width: 100%; padding: 8px; font-size: 12px;">Select</button>`
                            )}
                        </div>
                    `;
                }).join('');
            }
        }
        
        function purchaseColor(colorId) {
            const color = availableColors.find(c => c.id === colorId);
            if (!color) return;
            
            if (unlockedColors.includes(colorId)) {
                selectColor(colorId);
                return;
            }
            
            if (spendOrbs(color.price)) {
                unlockColor(colorId);
                updateShopDisplay();
                updateCustomizeDisplay();
                alert(`Unlocked ${color.name}!`);
            } else {
                alert('Not enough orbs!');
            }
        }
        
        function purchaseAura(auraId) {
            const aura = availableAuras.find(a => a.id === auraId);
            if (!aura) return;
            
            if (unlockedAuras.includes(auraId)) {
                selectAura(auraId);
                return;
            }
            
            if (spendOrbs(aura.price)) {
                unlockAura(auraId);
                updateShopDisplay();
                updateCustomizeDisplay();
                alert(`Unlocked ${aura.name}!`);
            } else {
                alert('Not enough orbs!');
            }
        }
        
        function purchaseParticle(particleId) {
            const particle = availableParticles.find(p => p.id === particleId);
            if (!particle) return;
            
            if (unlockedParticles.includes(particleId)) {
                selectParticle(particleId);
                return;
            }
            
            if (spendOrbs(particle.price)) {
                unlockParticle(particleId);
                updateShopDisplay();
                updateCustomizeDisplay();
                alert(`Unlocked ${particle.name}!`);
            } else {
                alert('Not enough orbs!');
            }
        }
        
        function selectColor(colorId) {
            if (unlockedColors.includes(colorId)) {
                selectedColorId = colorId;
                saveUnlockedColors();
                
                const color = availableColors.find(c => c.id === colorId);
                if (color && localPlayer) {
                    localPlayer.color = hexToHsl(color.hex);
                    // Save to localStorage
                    try {
                        localStorage.setItem('playerColor', color.hex);
                    } catch (e) {
                        console.warn('Could not save color:', e);
                    }
                }
                
                updateShopDisplay();
                updateCustomizeDisplay();
            }
        }
        
        function showCustomizeMenu() {
            hideAllScreens();
            document.getElementById('customizeScreen').classList.add('active');
            // Load saved name
            const nameInput = document.getElementById('playerNameInput');
            if (nameInput && localPlayer && localPlayer.name) {
                nameInput.value = localPlayer.name;
            }
            // Update image preview
            updateImagePreview();
            updateCustomizeDisplay();
        }
        
        function updateCustomizeDisplay() {
            // Update colors
            const colorContainer = document.getElementById('colorSelectionContainer');
            if (colorContainer) {
                // Ensure we have at least the default color unlocked
                if (unlockedColors.length === 0 || !unlockedColors.includes('default')) {
                    unlockedColors = ['default'];
                    saveUnlockedColors();
                }
                
                const unlockedColorList = availableColors.filter(color => unlockedColors.includes(color.id));
                
                if (unlockedColorList.length === 0) {
                    // Fallback: show at least the default color
                    const defaultColor = availableColors.find(c => c.id === 'default');
                    if (defaultColor) {
                        colorContainer.innerHTML = `
                            <div style="
                                position: relative;
                                width: 60px;
                                height: 60px;
                                border-radius: 50%;
                                background: ${defaultColor.hex};
                                border: 3px solid ${selectedColorId === 'default' ? '#ffd700' : '#fff'};
                                cursor: pointer;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                            " onclick="selectColor('default')" title="${defaultColor.name}">
                                ${selectedColorId === 'default' ? '<div style="font-size: 20px; color: #ffd700;"></div>' : ''}
                            </div>
                        `;
                    }
                } else {
                    colorContainer.innerHTML = unlockedColorList.map(color => {
                        const isSelected = selectedColorId === color.id;
                        return `
                            <div style="
                                position: relative;
                                width: 60px;
                                height: 60px;
                                border-radius: 50%;
                                background: ${color.hex};
                                border: 3px solid ${isSelected ? '#ffd700' : '#fff'};
                                cursor: pointer;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                            " onclick="selectColor('${color.id}')" title="${color.name}">
                                ${isSelected ? '<div style="font-size: 20px; color: #ffd700;"></div>' : ''}
                            </div>
                        `;
                    }).join('');
                }
            }
            
            // Update auras
            updateAuraDisplay();
            
            // Update particles
            updateParticleDisplay();
        }
        
        function updateImagePreview() {
            const preview = document.getElementById('imagePreview');
            const previewImg = document.getElementById('previewImg');
            if (localPlayer && localPlayer.image) {
                previewImg.src = localPlayer.image;
                preview.style.display = 'block';
            } else {
                preview.style.display = 'none';
            }
        }
        
        function clearImage() {
            if (localPlayer) {
                localPlayer.image = null;
                updateImagePreview();
                // Save to localStorage
                try {
                    localStorage.removeItem('playerImage');
                } catch (e) {
                    console.warn('Could not remove image from localStorage:', e);
                }
            }
        }
        
        function hideAllScreens() {
            const screens = document.querySelectorAll('.menu-screen');
            screens.forEach(screen => screen.classList.remove('active'));
        }
        
        function resumeGame() {
            toggleMenu();
        }
        
        function goToDiscord() {
            // Open Discord link in external browser
            if (window.electronAPI && window.electronAPI.openExternal) {
                window.electronAPI.openExternal('https://discord.gg/56kNp6JKV7');
            } else {
                // Fallback for browser - open in new tab
                window.open('https://discord.gg/56kNp6JKV7', '_blank');
            }
        }
        
        function quitApp() {
            // Quit the Electron application
            if (window.electronAPI && window.electronAPI.quit) {
                window.electronAPI.quit();
            } else {
                // Fallback if not running in Electron (for testing in browser)
                if (confirm('Quit the application?')) {
                    // In browser, we can't actually quit, but we can close the window
                    window.close();
                }
            }
        }
        
        // Color picker functionality
        function hexToHsl(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }
            
            return `hsl(${Math.round(h * 360)}, ${Math.round(s * 100)}%, ${Math.round(l * 100)}%)`;
        }
        
        function updatePlayerColor(color) {
            if (localPlayer) {
                localPlayer.color = hexToHsl(color);
                // Also update in players map
                if (localPlayerId) {
                    players.set(localPlayerId, localPlayer);
                }
                // Save color to localStorage
                try {
                    localStorage.setItem('playerColor', color);
                } catch (e) {
                    console.warn('Could not save color to localStorage:', e);
                }
                // Immediately broadcast color change to other players
                if (connections.size > 0) {
                    const colorState = {
                        type: 'state_medium',
                        id: localPlayerId,
                        scaleX: localPlayer.scaleX,
                        scaleY: localPlayer.scaleY,
                        rotation: localPlayer.rotation,
                        isDashing: localPlayer.isDashing,
                        dashCooldown: localPlayer.dashCooldown,
                        color: localPlayer.color,
                        name: localPlayer.name
                    };
                    broadcastToAll(colorState);
                }
            }
        }
        
        function loadSavedColor() {
            try {
                // Use selected color from unlockable system
                const color = availableColors.find(c => c.id === selectedColorId);
                if (color && localPlayer) {
                    localPlayer.color = hexToHsl(color.hex);
                    if (localPlayerId) {
                        players.set(localPlayerId, localPlayer);
                    }
                    return color.hex;
                }
            } catch (e) {
                console.warn('Could not load color from localStorage:', e);
            }
            return null;
        }
        
        window.addEventListener('keydown', (e) => {
            // Toggle menu with ESC or P
            if (e.key === 'Escape' || e.key.toLowerCase() === 'p') {
                e.preventDefault();
                toggleMenu();
                return;
            }
            
            // Always process game input - menu doesn't block keyboard
            keys[e.key.toLowerCase()] = true;
            if (e.key === ' ' && localPlayer && localPlayer.dashCooldown <= 0) {
                localPlayer.isDashing = true;
                localPlayer.dashCooldown = 30; // frames
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });
        
        canvas.addEventListener('mousedown', () => {
            mouseDown = true;
            
            // Double-click detection for dash
            const currentTime = Date.now();
            const timeSinceLastClick = currentTime - lastClickTime;
            
            if (timeSinceLastClick < DOUBLE_CLICK_DELAY && localPlayer && localPlayer.dashCooldown <= 0) {
                // Double-click detected - trigger dash
                localPlayer.isDashing = true;
                localPlayer.dashCooldown = 30; // frames
                lastClickTime = 0; // Reset to prevent triple-click from triggering again
            } else {
                lastClickTime = currentTime;
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
        });
        
        // Collision detection and resolution between players
        function resolvePlayerCollisions(player1, player2) {
            const dx = player2.x - player1.x;
            const dy = player2.y - player1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDistance = player1.baseRadius + player2.baseRadius;
            
            if (distance < minDistance && distance > 0) {
                // Prevent multiple damage from same collision (cooldown of 0.5 seconds)
                const now = Date.now();
                const collisionCooldown = 500; // 500ms cooldown
                
                // Calculate overlap
                const overlap = minDistance - distance;
                const separationX = (dx / distance) * overlap * 0.5;
                const separationY = (dy / distance) * overlap * 0.5;
                
                // Store velocities before collision to calculate recoil
                const player1VelBefore = Math.sqrt(player1.vx * player1.vx + player1.vy * player1.vy);
                const player2VelBefore = Math.sqrt(player2.vx * player2.vx + player2.vy * player2.vy);
                
                // Push players apart
                player1.x -= separationX;
                player1.y -= separationY;
                player2.x += separationX;
                player2.y += separationY;
                
                // Apply collision response (bounce effect)
                const normalX = dx / distance;
                const normalY = dy / distance;
                const relativeVx = player2.vx - player1.vx;
                const relativeVy = player2.vy - player1.vy;
                const relativeSpeed = relativeVx * normalX + relativeVy * normalY;
                
                // Only apply bounce if players are moving towards each other
                if (relativeSpeed < 0) {
                    const bounceStrength = 0.3; // How much velocity is transferred
                    const impulse = relativeSpeed * bounceStrength;
                    
                    const player1VxBefore = player1.vx;
                    const player1VyBefore = player1.vy;
                    const player2VxBefore = player2.vx;
                    const player2VyBefore = player2.vy;
                    
                    player1.vx += impulse * normalX;
                    player1.vy += impulse * normalY;
                    player2.vx -= impulse * normalX;
                    player2.vy -= impulse * normalY;
                    
                    // Calculate recoil (change in velocity magnitude)
                    const player1VelAfter = Math.sqrt(player1.vx * player1.vx + player1.vy * player1.vy);
                    const player2VelAfter = Math.sqrt(player2.vx * player2.vx + player2.vy * player2.vy);
                    
                    const player1Recoil = Math.abs(player1VelAfter - player1VelBefore);
                    const player2Recoil = Math.abs(player2VelAfter - player2VelBefore);
                    
                    // Apply damage to player with more recoil (only if cooldown has passed)
                    if (now - player1.lastCollisionTime > collisionCooldown && 
                        now - player2.lastCollisionTime > collisionCooldown) {
                        
                        if (player1Recoil > player2Recoil) {
                            // Player 1 takes damage
                            player1.health = Math.max(0, player1.health - 10);
                            player1.lastCollisionTime = now;
                            
                            // Check for death
                            if (player1.health <= 0 && !player1.dead) {
                                player1.dead = true;
                                player1.visible = false;
                            }
                            
                            // Update health bar if it's the local player
                            if (player1.id === localPlayerId && healthBar) {
                                healthBar.setHealth(player1.health);
                            }
                            
                            // Check for match victory
                            if (matchInProgress && (queueMode === '1v1' || queueMode === '2v2')) {
                                setTimeout(() => checkMatchVictory(), 500);
                            }
                            // Check for FreeForAll winner
                            if (freeForAllInProgress && currentGameMode === 'freeforall') {
                                setTimeout(() => checkFreeForAllWinner(), 500);
                            }
                        } else if (player2Recoil > player1Recoil) {
                            // Player 2 takes damage
                            player2.health = Math.max(0, player2.health - 10);
                            player2.lastCollisionTime = now;
                            
                            // Check for death
                            if (player2.health <= 0 && !player2.dead) {
                                player2.dead = true;
                                player2.visible = false;
                            }
                            
                            // Update health bar if it's the local player
                            if (player2.id === localPlayerId && healthBar) {
                                healthBar.setHealth(player2.health);
                            }
                            
                            // Check for match victory
                            if (matchInProgress && (queueMode === '1v1' || queueMode === '2v2')) {
                                setTimeout(() => checkMatchVictory(), 500);
                            }
                            // Check for FreeForAll winner
                            if (freeForAllInProgress && currentGameMode === 'freeforall') {
                                setTimeout(() => checkFreeForAllWinner(), 500);
                            }
                        }
                    }
                }
            }
        }
        
        function updatePlayer() {
            if (!localPlayer) return;
            
            const moveSpeed = DEFAULT_MOVE_SPEED;
            const dashMult = DEFAULT_DASH_MULT;
            const speed = localPlayer.isDashing ? moveSpeed * dashMult : moveSpeed;
            
            // Input handling
            let inputX = 0;
            let inputY = 0;
            
            if (keys['w'] || keys['arrowup']) inputY -= 1;
            if (keys['s'] || keys['arrowdown']) inputY += 1;
            if (keys['a'] || keys['arrowleft']) inputX -= 1;
            if (keys['d'] || keys['arrowright']) inputX += 1;
            
            // Mouse movement
            if (mouseDown) {
                const dx = mouseX - localPlayer.x;
                const dy = mouseY - localPlayer.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 10) {
                    inputX = dx / dist;
                    inputY = dy / dist;
                }
            }
            
            // Normalize diagonal movement
            if (inputX !== 0 && inputY !== 0) {
                const mag = Math.sqrt(inputX * inputX + inputY * inputY);
                inputX /= mag;
                inputY /= mag;
            }
            
            // Apply movement
            localPlayer.vx += inputX * speed * 0.3;
            localPlayer.vy += inputY * speed * 0.3;
            
            // Friction
            localPlayer.vx *= 0.9;
            localPlayer.vy *= 0.9;
            
            // Update position
            localPlayer.x += localPlayer.vx;
            localPlayer.y += localPlayer.vy;
            
            // Boundary collision with bounce
            const radius = localPlayer.baseRadius;
            const bounceDamping = 0.8; // Energy retained after bounce (0.8 = 80%)
            
            // Left wall
            if (localPlayer.x - radius < 0) {
                localPlayer.x = radius;
                localPlayer.vx = Math.abs(localPlayer.vx) * bounceDamping; // Bounce right
            }
            // Right wall
            if (localPlayer.x + radius > canvas.width) {
                localPlayer.x = canvas.width - radius;
                localPlayer.vx = -Math.abs(localPlayer.vx) * bounceDamping; // Bounce left
            }
            // Top wall
            if (localPlayer.y - radius < 0) {
                localPlayer.y = radius;
                localPlayer.vy = Math.abs(localPlayer.vy) * bounceDamping; // Bounce down
            }
            // Bottom wall
            if (localPlayer.y + radius > canvas.height) {
                localPlayer.y = canvas.height - radius;
                localPlayer.vy = -Math.abs(localPlayer.vy) * bounceDamping; // Bounce up
            }
            
            // Check collisions with other players
            players.forEach((otherPlayer, otherId) => {
                if (otherId !== localPlayerId && otherPlayer) {
                    resolvePlayerCollisions(localPlayer, otherPlayer);
                }
            });
            
            // Calculate squash and stretch
            const velocity = Math.sqrt(localPlayer.vx * localPlayer.vx + localPlayer.vy * localPlayer.vy);
            const maxVelocity = speed * 2;
            const velocityRatio = Math.min(velocity / maxVelocity, 1);
            
            // Stretch intensity: 1 for normal movement, 2 when dashing
            const stretchIntensity = localPlayer.isDashing ? 2 : 1;
            const squashIntensity = DEFAULT_SQUASH_INTENSITY;
            
            if (velocity > 0.5) {
                // Stretch in direction of movement
                const angle = Math.atan2(localPlayer.vy, localPlayer.vx);
                localPlayer.rotation = angle;
                
                // More velocity = more stretch
                localPlayer.targetScaleX = 1 + (stretchIntensity - 1) * velocityRatio;
                localPlayer.targetScaleY = 1 - (1 - squashIntensity) * velocityRatio;
            } else {
                // Return to normal when idle
                localPlayer.targetScaleX = 1;
                localPlayer.targetScaleY = 1;
                
                // Idle wobble
                if (DEFAULT_WOBBLE_ON_IDLE) {
                    const wobble = Math.sin(Date.now() * 0.003) * 0.05;
                    localPlayer.targetScaleX = 1 + wobble;
                    localPlayer.targetScaleY = 1 - wobble;
                }
            }
            
            // Smooth interpolation
            const deformSpeed = DEFAULT_DEFORM_SPEED;
            localPlayer.scaleX += (localPlayer.targetScaleX - localPlayer.scaleX) * deformSpeed;
            localPlayer.scaleY += (localPlayer.targetScaleY - localPlayer.scaleY) * deformSpeed;
            
            // Update dash and trail
            if (localPlayer.dashCooldown > 0) localPlayer.dashCooldown--;
            if (localPlayer.isDashing && localPlayer.dashCooldown <= 0) {
                localPlayer.isDashing = false;
            }
            
            // Trail
            if (DEFAULT_SHOW_TRAIL) {
                localPlayer.trail.push({ 
                    x: localPlayer.x, 
                    y: localPlayer.y, 
                    scaleX: localPlayer.scaleX,
                    scaleY: localPlayer.scaleY,
                    rotation: localPlayer.rotation,
                    alpha: 1 
                });
                
                if (localPlayer.trail.length > 15) {
                    localPlayer.trail.shift();
                }
                
                localPlayer.trail.forEach(t => {
                    t.alpha *= 0.9;
                });
            } else {
                localPlayer.trail = [];
            }
        }
        
        function drawBubble(x, y, scaleX, scaleY, rotation, alpha = 1, color = null, image = null) {
            const radius = DEFAULT_BUBBLE_SIZE;
            
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            ctx.scale(scaleX, scaleY);
            
            // Outer bubble - use custom color if provided, otherwise default
            let gradient;
            let highlightGradient;
            let rimColor;
            let highlightColor;
            
            if (color) {
                // Parse HSL color and create gradient
                const hslMatch = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                if (hslMatch) {
                    const h = parseInt(hslMatch[1]);
                    const s = parseInt(hslMatch[2]);
                    const l = parseInt(hslMatch[3]);
                    
                    // Enhanced radial gradient with more color stops for smoother look (more transparent)
                    const baseAlpha = 0.75 * alpha; // Make bubble more transparent
                    // Center the gradient at the center of the bubble
                    gradient = ctx.createRadialGradient(0, 0, radius * 0.15, 0, 0, radius);
                    gradient.addColorStop(0, `hsla(${h}, ${Math.min(s + 10, 100)}%, ${Math.min(l + 25, 100)}%, ${0.85 * baseAlpha})`);
                    gradient.addColorStop(0.3, `hsla(${h}, ${s}%, ${Math.min(l + 15, 100)}%, ${0.75 * baseAlpha})`);
                    gradient.addColorStop(0.6, `hsla(${h}, ${s}%, ${l}%, ${0.65 * baseAlpha})`);
                    gradient.addColorStop(0.85, `hsla(${h}, ${Math.max(s - 5, 0)}%, ${Math.max(l - 5, 0)}%, ${0.75 * baseAlpha})`);
                    gradient.addColorStop(1, `hsla(${h}, ${Math.max(s - 15, 0)}%, ${Math.max(l - 15, 0)}%, ${0.8 * baseAlpha})`);
                    
                    // Highlight gradient centered (more transparent)
                    highlightGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 0.4);
                    highlightGradient.addColorStop(0, `hsla(${h}, ${Math.min(s + 20, 100)}%, ${Math.min(l + 30, 100)}%, ${0.6 * baseAlpha})`);
                    highlightGradient.addColorStop(0.5, `hsla(${h}, ${s}%, ${Math.min(l + 10, 100)}%, ${0.3 * baseAlpha})`);
                    highlightGradient.addColorStop(1, `hsla(${h}, ${s}%, ${l}%, 0)`);
                    
                    rimColor = `hsla(${h}, ${Math.min(s + 15, 100)}%, ${Math.min(l + 15, 100)}%, ${0.6 * baseAlpha})`;
                    highlightColor = `hsla(${h}, ${Math.min(s + 25, 100)}%, ${Math.min(l + 35, 100)}%, ${0.4 * baseAlpha})`;
                } else {
                    // Fallback to default
                    gradient = ctx.createRadialGradient(-radius * 0.35, -radius * 0.35, radius * 0.15, 0, 0, radius);
                    gradient.addColorStop(0, `rgba(180, 220, 255, ${0.95 * alpha})`);
                    gradient.addColorStop(0.3, `rgba(150, 200, 255, ${0.85 * alpha})`);
                    gradient.addColorStop(0.6, `rgba(100, 150, 255, ${0.75 * alpha})`);
                    gradient.addColorStop(0.85, `rgba(70, 130, 246, ${0.85 * alpha})`);
                    gradient.addColorStop(1, `rgba(59, 130, 246, ${0.9 * alpha})`);
                    
                    highlightGradient = ctx.createRadialGradient(-radius * 0.25, -radius * 0.25, 0, -radius * 0.25, -radius * 0.25, radius * 0.4);
                    highlightGradient.addColorStop(0, `rgba(220, 240, 255, ${0.7 * alpha})`);
                    highlightGradient.addColorStop(0.5, `rgba(180, 220, 255, ${0.4 * alpha})`);
                    highlightGradient.addColorStop(1, `rgba(150, 200, 255, 0)`);
                    
                    rimColor = `rgba(220, 240, 255, ${0.7 * alpha})`;
                    highlightColor = `rgba(240, 250, 255, ${0.5 * alpha})`;
                }
            } else {
                // Enhanced default blue gradient (more transparent)
                const baseAlpha = 0.75 * alpha; // Make bubble more transparent
                // Center the gradient at the center of the bubble
                gradient = ctx.createRadialGradient(0, 0, radius * 0.15, 0, 0, radius);
                gradient.addColorStop(0, `rgba(180, 220, 255, ${0.85 * baseAlpha})`);
                gradient.addColorStop(0.3, `rgba(150, 200, 255, ${0.75 * baseAlpha})`);
                gradient.addColorStop(0.6, `rgba(100, 150, 255, ${0.65 * baseAlpha})`);
                gradient.addColorStop(0.85, `rgba(70, 130, 246, ${0.75 * baseAlpha})`);
                gradient.addColorStop(1, `rgba(59, 130, 246, ${0.8 * baseAlpha})`);
                
                // Highlight gradient centered (more transparent)
                highlightGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 0.4);
                highlightGradient.addColorStop(0, `rgba(220, 240, 255, ${0.6 * baseAlpha})`);
                highlightGradient.addColorStop(0.5, `rgba(180, 220, 255, ${0.3 * baseAlpha})`);
                highlightGradient.addColorStop(1, `rgba(150, 200, 255, 0)`);
                
                rimColor = `rgba(220, 240, 255, ${0.6 * baseAlpha})`;
                highlightColor = `rgba(240, 250, 255, ${0.4 * baseAlpha})`;
            }
            
            // Draw main bubble with enhanced gradient
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw highlight for more 3D bubble effect (centered)
            ctx.fillStyle = highlightGradient;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            // Small highlight spot removed (white dot)
            
            // Enhanced rim with glow effect
            ctx.shadowBlur = 8;
            ctx.shadowColor = rimColor;
            ctx.strokeStyle = rimColor;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, radius - 2, 0, Math.PI * 2);
            ctx.stroke();
            
            // Reset shadow
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            
            // Draw image inside bubble if provided
            if (image) {
                let imgObj = imageCache.get(image);
                if (!imgObj && typeof image === 'string' && image.startsWith('data:')) {
                    imgObj = new Image();
                    imgObj.onload = () => {
                        imageCache.set(image, imgObj);
                    };
                    imgObj.src = image;
                    imageCache.set(image, imgObj);
                }
                
                if (imgObj && imgObj.complete && imgObj.width > 0) {
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    const imgSize = radius * 0.6; // Image size is 60% of bubble radius
                    ctx.beginPath();
                    ctx.arc(0, 0, imgSize / 2, 0, Math.PI * 2);
                    ctx.clip();
                    ctx.drawImage(imgObj, -imgSize / 2, -imgSize / 2, imgSize, imgSize);
                    ctx.restore();
                }
            }
            
            ctx.restore();
        }
        
        // Particle system for particle effects
        let particleSystem = [];
        
        function drawAura(x, y, auraId) {
            if (!auraId || auraId === 'none') return;
            
            const aura = availableAuras.find(a => a.id === auraId);
            if (!aura || !aura.color) return;
            
            const radius = DEFAULT_BUBBLE_SIZE;
            ctx.save();
            ctx.translate(x, y);
            
            // Parse color
            const color = aura.color;
            const time = Date.now() * 0.001;
            
            if (auraId.startsWith('glow_')) {
                // Glow effect - pulsing outer glow
                const pulse = 1 + Math.sin(time * 2) * 0.1;
                const glowRadius = radius * (1.3 + pulse * 0.2);
                
                const gradient = ctx.createRadialGradient(0, 0, radius, 0, 0, glowRadius);
                gradient.addColorStop(0, color + '80');
                gradient.addColorStop(0.5, color + '40');
                gradient.addColorStop(1, color + '00');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, glowRadius, 0, Math.PI * 2);
                ctx.fill();
            } else if (auraId.startsWith('ring_')) {
                // Ring effect - rotating ring
                const ringRadius = radius * 1.2;
                const ringWidth = 5;
                ctx.strokeStyle = color;
                ctx.lineWidth = ringWidth;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Second ring
                ctx.beginPath();
                ctx.arc(0, 0, ringRadius * 0.85, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
            } else if (auraId.startsWith('halo_')) {
                // Halo effect - floating ring above
                const haloRadius = radius * 1.1;
                const haloY = -radius * 1.3;
                const gradient = ctx.createLinearGradient(0, haloY - haloRadius, 0, haloY + haloRadius);
                gradient.addColorStop(0, color + 'FF');
                gradient.addColorStop(0.5, color + 'AA');
                gradient.addColorStop(1, color + '00');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(0, haloY, haloRadius, haloRadius * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        function drawParticles(x, y, particleId) {
            if (!particleId || particleId === 'none') return;
            
            const particle = availableParticles.find(p => p.id === particleId);
            if (!particle || !particle.color) return;
            
            const radius = DEFAULT_BUBBLE_SIZE;
            const time = Date.now() * 0.001;
            
            if (particleId.startsWith('sparkles_')) {
                // Sparkles - random sparkles around player
                const sparkleCount = 8;
                for (let i = 0; i < sparkleCount; i++) {
                    const angle = (time * 2 + i * (Math.PI * 2 / sparkleCount)) % (Math.PI * 2);
                    const dist = radius * (1.2 + Math.sin(time * 3 + i) * 0.3);
                    const sparkleX = x + Math.cos(angle) * dist;
                    const sparkleY = y + Math.sin(angle) * dist;
                    const size = 3 + Math.sin(time * 5 + i) * 2;
                    
                    ctx.save();
                    ctx.globalAlpha = 0.6 + Math.sin(time * 4 + i) * 0.4;
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            } else if (particleId.startsWith('trail_')) {
                // Trail - particles following movement
                if (!particleSystem) particleSystem = [];
                
                // Add new particle
                if (Math.random() < 0.3) {
                    particleSystem.push({
                        x: x + (Math.random() - 0.5) * radius * 0.5,
                        y: y + (Math.random() - 0.5) * radius * 0.5,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        life: 1.0,
                        size: 2 + Math.random() * 3,
                        color: particle.color
                    });
                }
                
                // Update and draw particles
                particleSystem = particleSystem.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.02;
                    p.vy += 0.1; // Gravity
                    
                    ctx.save();
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    
                    return p.life > 0;
                });
            } else if (particleId === 'burst_rainbow') {
                // Rainbow burst - colorful particles
                const burstCount = 12;
                for (let i = 0; i < burstCount; i++) {
                    const angle = (i * (Math.PI * 2 / burstCount) + time) % (Math.PI * 2);
                    const dist = radius * (1.1 + Math.sin(time * 2) * 0.2);
                    const burstX = x + Math.cos(angle) * dist;
                    const burstY = y + Math.sin(angle) * dist;
                    
                    const hue = (i * 30 + time * 50) % 360;
                    ctx.save();
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = `hsl(${hue}, 100%, 60%)`;
                    ctx.beginPath();
                    ctx.arc(burstX, burstY, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
        }
        
        function draw(timestamp) {
            // Draw ocean background first
            if (oceanBackground) {
                oceanBackground.update(timestamp || 0);
                oceanBackground.draw(timestamp || 0);
            } else {
                // Fallback: clear canvas if ocean background not initialized
                ctx.fillStyle = '#0a0a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Draw FPS counter if enabled
            if (gameSettings.showFPS) {
                ctx.fillStyle = '#00ff00';
                ctx.font = 'bold 16px system-ui';
                ctx.textAlign = 'right';
                ctx.fillText(`FPS: ${currentFPS}`, canvas.width - 10, 20);
            }
            
            // Draw game mode elements (spikes, AI bots, targets, etc.)
            if (currentGameMode === 'spike_dodge') {
                drawSpikes();
            } else if (currentGameMode === 'dodge_mode') {
                drawBombs();
            } else if (currentGameMode === 'target_break') {
                drawTargets();
            } else if (currentGameMode === 'training') {
                drawTrainingAI();
            }
            
            // Draw challenge mode UI
            if (currentGameMode === 'spike_dodge' && !playerDead) {
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px system-ui';
                ctx.textAlign = 'left';
                ctx.fillText(`Spikes Dodged: ${spikesDodged}`, 20, 40);
            } else if (currentGameMode === 'dodge_mode' && !playerDead) {
                const survivalTime = Math.floor((Date.now() - dodgeModeStartTime) / 1000);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px system-ui';
                ctx.textAlign = 'left';
                ctx.fillText(`Time: ${survivalTime}s`, 20, 40);
                ctx.fillText(`Bombs: ${aiBombs.length}`, 20, 70);
            } else if (currentGameMode === 'freeforall' && !playerDead) {
                const survivalTime = Math.floor((Date.now() - freeForAllStartTime) / 1000);
                const aliveCount = Array.from(players.values()).filter(p => !p.dead && p.health > 0).length;
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px system-ui';
                ctx.textAlign = 'left';
                ctx.fillText(`FreeForAll - Time: ${survivalTime}s`, 20, 40);
                ctx.fillText(`Players Alive: ${aliveCount}`, 20, 70);
            } else if (currentGameMode === 'training' && !playerDead) {
                const aliveAICount = trainingAIBots.filter(ai => !ai.dead).length;
                const deadAICount = trainingAIBots.filter(ai => ai.dead).length;
                const respawnTimeLeft = deadAICount > 0 && aliveAICount === 0 ? 
                    Math.ceil((trainingRespawnDelay - trainingRespawnTimer) / 1000) : 0;
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px system-ui';
                ctx.textAlign = 'left';
                ctx.fillText(`Training Mode`, 20, 40);
                ctx.fillText(`AI Bots: ${aliveAICount}/${trainingSettings.aiCount}`, 20, 70);
                if (respawnTimeLeft > 0) {
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillText(`Resetting in: ${respawnTimeLeft}s`, 20, 100);
                }
            } else if (currentGameMode === 'target_break' && !playerDead && activeTargets.length > 0) {
                const remainingTargets = activeTargets.filter(t => !t.broken);
                const shortestTimeLeft = remainingTargets.length > 0 ? 
                    Math.min(...remainingTargets.map(t => Math.max(0, t.timeLimit - t.timer))) : 0;
                const timeLeftSeconds = (shortestTimeLeft / 1000).toFixed(1);
                ctx.fillStyle = shortestTimeLeft < 1000 ? '#ff0000' : '#fff';
                ctx.font = 'bold 24px system-ui';
                ctx.textAlign = 'left';
                ctx.fillText(`Targets Broken: ${targetsBroken}`, 20, 40);
                ctx.fillText(`Active Targets: ${remainingTargets.length}`, 20, 70);
                ctx.fillText(`Time Left: ${timeLeftSeconds}s`, 20, 100);
            }
            
            // Draw death particles
            if (deathParticles.length > 0) {
                drawDeathParticles();
            }
            
            // Draw all players (only if visible)
            players.forEach((player, peerId) => {
                // Draw trail
                if (DEFAULT_SHOW_TRAIL && player.trail) {
                    player.trail.forEach(t => {
                        drawBubble(t.x, t.y, t.scaleX, t.scaleY, t.rotation, t.alpha * 0.5, player.color, null);
                    });
                }
                
                // Draw aura (before bubble for glow effects)
                if (peerId === localPlayerId) {
                    drawAura(player.x, player.y, selectedAuraId);
                }
                
                // Draw main bubble
                drawBubble(player.x, player.y, player.scaleX, player.scaleY, player.rotation, 1, player.color, player.image);
                
                // Draw particle effects (after bubble)
                if (peerId === localPlayerId) {
                    drawParticles(player.x, player.y, selectedParticleId);
                }
                
                // Draw velocity vector (only for local player if enabled)
                if (peerId === localPlayerId && DEFAULT_SHOW_VELOCITY && (player.vx !== 0 || player.vy !== 0)) {
                    const velMag = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
                    const velX = (player.vx / velMag) * 100;
                    const velY = (player.vy / velMag) * 100;
                    
                    ctx.strokeStyle = '#00ff88';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(player.x, player.y);
                    ctx.lineTo(player.x + velX, player.y + velY);
                    ctx.stroke();
                    
                    // Arrowhead
                    const angle = Math.atan2(velY, velX);
                    ctx.fillStyle = '#00ff88';
                    ctx.beginPath();
                    ctx.moveTo(player.x + velX, player.y + velY);
                    ctx.lineTo(
                        player.x + velX - 10 * Math.cos(angle - Math.PI / 6),
                        player.y + velY - 10 * Math.sin(angle - Math.PI / 6)
                    );
                    ctx.lineTo(
                        player.x + velX - 10 * Math.cos(angle + Math.PI / 6),
                        player.y + velY - 10 * Math.sin(angle + Math.PI / 6)
                    );
                    ctx.closePath();
                    ctx.fill();
                }
            });
            
            // Update dash indicator light (only for local player)
            const dashIndicator = document.getElementById('dashIndicator');
            if (dashIndicator && localPlayer) {
                if (localPlayer.dashCooldown > 0) {
                    dashIndicator.classList.add('cooldown');
                } else {
                    dashIndicator.classList.remove('cooldown');
                }
            }
        }
        
        function updateRemotePlayers() {
            const now = Date.now();
            const deltaTime = 16; // ~60fps
            
            // Update remote players with interpolation
            players.forEach((player, peerId) => {
                if (peerId === localPlayerId) return; // Skip local player
                
                // Interpolate position for smooth movement
                const timeSinceUpdate = now - player.lastUpdateTime;
                const interpolationFactor = Math.min(timeSinceUpdate / 100, 1); // Cap at 100ms
                
                player.x = lerp(player.x, player.targetX, 0.2);
                player.y = lerp(player.y, player.targetY, 0.2);
                player.vx = lerp(player.vx, player.targetVx, 0.3);
                player.vy = lerp(player.vy, player.targetVy, 0.3);
                
                // Apply velocity to position
                player.x += player.vx * (deltaTime / 16);
                player.y += player.vy * (deltaTime / 16);
                
                // Boundary collision (same as local player)
                const radius = player.baseRadius;
                const bounceDamping = 0.8;
                
                if (player.x - radius < 0) {
                    player.x = radius;
                    player.vx = Math.abs(player.vx) * bounceDamping;
                }
                if (player.x + radius > canvas.width) {
                    player.x = canvas.width - radius;
                    player.vx = -Math.abs(player.vx) * bounceDamping;
                }
                if (player.y - radius < 0) {
                    player.y = radius;
                    player.vy = Math.abs(player.vy) * bounceDamping;
                }
                if (player.y + radius > canvas.height) {
                    player.y = canvas.height - radius;
                    player.vy = -Math.abs(player.vy) * bounceDamping;
                }
                
                // Check collisions with other players (including local player)
                players.forEach((otherPlayer, otherId) => {
                    if (otherId !== peerId && otherPlayer) {
                        resolvePlayerCollisions(player, otherPlayer);
                    }
                });
                
                // Calculate squash and stretch for remote players
                const velocity = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
                const maxVelocity = DEFAULT_MOVE_SPEED * 2;
                const velocityRatio = Math.min(velocity / maxVelocity, 1);
                
                // Stretch intensity: 1 for normal movement, 2 when dashing
                const stretchIntensity = player.isDashing ? 2 : 1;
                
                if (velocity > 0.5) {
                    const angle = Math.atan2(player.vy, player.vx);
                    player.rotation = angle;
                    player.targetScaleX = 1 + (stretchIntensity - 1) * velocityRatio;
                    player.targetScaleY = 1 - (1 - DEFAULT_SQUASH_INTENSITY) * velocityRatio;
                } else {
                    player.targetScaleX = 1;
                    player.targetScaleY = 1;
                    if (DEFAULT_WOBBLE_ON_IDLE) {
                        const wobble = Math.sin(Date.now() * 0.003) * 0.05;
                        player.targetScaleX = 1 + wobble;
                        player.targetScaleY = 1 - wobble;
                    }
                }
                
                const deformSpeed = DEFAULT_DEFORM_SPEED;
                player.scaleX += (player.targetScaleX - player.scaleX) * deformSpeed;
                player.scaleY += (player.targetScaleY - player.scaleY) * deformSpeed;
                
                // Update trail for remote players
                if (DEFAULT_SHOW_TRAIL) {
                    player.trail.push({ 
                        x: player.x, 
                        y: player.y, 
                        scaleX: player.scaleX,
                        scaleY: player.scaleY,
                        rotation: player.rotation,
                        alpha: 1 
                    });
                    
                    if (player.trail.length > 15) {
                        player.trail.shift();
                    }
                    
                    player.trail.forEach(t => {
                        t.alpha *= 0.9;
                    });
                }
            });
        }
        
        function lerp(start, end, factor) {
            return start + (end - start) * factor;
        }
        
        function syncGameState() {
            if (!localPlayer) return;
            
            const now = Date.now();
            
            // High priority sync (position, velocity) - 60fps
            if (now - lastSyncTime >= SYNC_INTERVAL) {
                const state = {
                    type: 'state',
                    id: localPlayerId,
                    x: localPlayer.x,
                    y: localPlayer.y,
                    vx: localPlayer.vx,
                    vy: localPlayer.vy
                };
                
                broadcastToAll(state);
                lastSyncTime = now;
            }
            
            // Medium priority sync (scale, rotation, color, name) - 30fps
            // Note: image is sent separately when it changes, not every frame
            if (now - lastSyncTimeMedium >= SYNC_INTERVAL_MEDIUM) {
                const state = {
                    type: 'state_medium',
                    id: localPlayerId,
                    scaleX: localPlayer.scaleX,
                    scaleY: localPlayer.scaleY,
                    rotation: localPlayer.rotation,
                    isDashing: localPlayer.isDashing,
                    dashCooldown: localPlayer.dashCooldown,
                    color: localPlayer.color, // Sync color to other players
                    name: localPlayer.name // Sync name
                    // image is NOT included here - sent separately via 'image_update' message
                };
                
                broadcastToAll(state);
                lastSyncTimeMedium = now;
            }
        }
        
        function broadcastToAll(data) {
            connections.forEach((conn, peerId) => {
                if (conn.open) {
                    conn.send(data);
                }
            });
        }
        
        let lastTime = 0;
        function gameLoop(timestamp) {
            // FPS limiting
            const now = timestamp || performance.now();
            
            // Initialize lastFrameTime on first call
            if (lastFrameTime === 0) {
                lastFrameTime = now;
                requestAnimationFrame(gameLoop);
                return;
            }
            
            const elapsed = now - lastFrameTime;
            
            if (targetFPS > 0 && elapsed < frameInterval) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            // Update lastFrameTime for next frame
            lastFrameTime = now - (elapsed % frameInterval);
            
            // Calculate FPS - count rendered frames
            fpsCounter++;
            fpsTime += elapsed;
            if (fpsTime >= 1000) {
                currentFPS = Math.round((fpsCounter * 1000) / fpsTime);
                fpsCounter = 0;
                fpsTime = 0;
            }
            
            // Use timestamp from requestAnimationFrame, or calculate delta
            const time = timestamp || (lastTime += 16);
            const deltaTime = time - (lastTime || time);
            lastTime = time;
            
            // Always update game - never pause
            updatePlayer();
            updateRemotePlayers();
            syncGameState();
            
            // Update game modes
            if (currentGameMode === 'spike_dodge') {
                updateSpikeDodge(deltaTime);
            } else if (currentGameMode === 'dodge_mode') {
                updateDodgeMode(deltaTime);
            } else if (currentGameMode === 'target_break') {
                updateTargetBreak(deltaTime);
            } else if (currentGameMode === 'freeforall') {
                // Check for FreeForAll winner every frame
                checkFreeForAllWinner();
            } else if (currentGameMode === 'training') {
                updateTrainingMode(deltaTime);
            }
            
            draw(time);
            requestAnimationFrame(gameLoop);
        }
        
        function resetPosition() {
            if (localPlayer) {
                localPlayer.x = canvas.width / 2;
                localPlayer.y = canvas.height / 2;
                localPlayer.vx = 0;
                localPlayer.vy = 0;
                localPlayer.scaleX = 1;
                localPlayer.scaleY = 1;
                localPlayer.trail = [];
            }
        }
        
        // Multiplayer functions
        function hostGame() {
            // Exit any game mode when hosting
            if (currentGameMode) {
                currentGameMode = null;
                spikes = [];
            }
            
            roomId = Math.random().toString(36).substring(2, 9);
            localPlayerId = roomId;
            isHost = true;
            
            // Update challenges button visibility
            updateChallengesButtonVisibility();
            
            peer = new Peer(roomId, {
                host: '0.peerjs.com',
                port: 443,
                path: '/',
                secure: true
            });
            
            peer.on('open', (id) => {
                console.log('Host peer opened with ID:', id);
                
                // Remove old local player if it exists
                if (players.has('local')) {
                    players.delete('local');
                }
                
                localPlayerId = id;
                localPlayer = createPlayer(id, true);
                // Apply color from unlockable system
                const color = availableColors.find(c => c.id === selectedColorId);
                if (color && localPlayer) {
                    localPlayer.color = hexToHsl(color.hex);
                }
                players.set(id, localPlayer);
                
                document.getElementById('roomIdDisplay').textContent = 'Room ID: ' + id;
                hideAllScreens();
                document.getElementById('gameScreen').classList.add('active');
                updatePlayerList();
            });
            
            peer.on('connection', (conn) => {
                console.log('New connection from:', conn.peer);
                setupConnection(conn);
            });
            
            peer.on('error', (err) => {
                console.error('Peer error:', err);
            });
        }
        
        function joinGame() {
            const inputRoomId = document.getElementById('roomIdInput').value.trim();
            if (!inputRoomId) {
                alert('Please enter a room ID');
                return;
            }
            
            // Save current player position BEFORE attempting connection
            let savedX = null;
            let savedY = null;
            if (localPlayer) {
                savedX = localPlayer.x;
                savedY = localPlayer.y;
            }
            
            roomId = inputRoomId;
            isHost = false;
            
            // Update challenges button visibility
            updateChallengesButtonVisibility();
            
            // Flag to track if connection failed
            let connectionFailed = false;
            
            peer = new Peer({
                host: '0.peerjs.com',
                port: 443,
                path: '/',
                secure: true
            });
            
            peer.on('open', (id) => {
                console.log('Client peer opened with ID:', id);
                
                // Don't proceed if connection already failed
                if (connectionFailed) {
                    return;
                }
                
                // Store the current player position before creating new player
                let savedX = null;
                let savedY = null;
                if (localPlayer) {
                    savedX = localPlayer.x;
                    savedY = localPlayer.y;
                }
                
                // Connect to host - don't create player or show game screen yet, wait for connection
                const conn = peer.connect(roomId);
                
                // Set up connection with error handling
                conn.on('open', () => {
                    // Don't proceed if connection already failed
                    if (connectionFailed) {
                        return;
                    }
                    
                    // Connection successful - NOW create player and set up multiplayer
                    // Remove old local player if it exists
                    if (players.has('local')) {
                        players.delete('local');
                    }
                    
                    localPlayerId = id;
                    localPlayer = createPlayer(id, true);
                    
                    // Restore position if we had one
                    if (savedX !== null && savedY !== null) {
                        localPlayer.x = savedX;
                        localPlayer.y = savedY;
                    }
                    
                    // Apply color from color picker
                    const colorPicker = document.getElementById('colorPicker');
                    if (colorPicker && localPlayer) {
                        const selectedColor = availableColors.find(c => c.id === selectedColorId);
                        if (selectedColor) {
                            localPlayer.color = hexToHsl(selectedColor.hex);
                        }
                    }
                    players.set(id, localPlayer);
                    
                    // Now show game screen
                    setupConnection(conn);
                    document.getElementById('roomIdDisplay').textContent = 'Room ID: ' + roomId;
                    hideAllScreens();
                    document.getElementById('gameScreen').classList.add('active');
                    updatePlayerList();
                });
                
                conn.on('error', (err) => {
                    console.error('Connection error:', err);
                    connectionFailed = true;
                    
                    // Close the connection
                    if (conn && !conn.destroyed) {
                        conn.close();
                    }
                    
                    // Clean up on connection error
                    if (peer) {
                        peer.destroy();
                        peer = null;
                    }
                    roomId = null;
                    isHost = false;
                    
                    // Don't reset player - restore original local player with saved position
                    // Just clear multiplayer state
                    if (localPlayerId && localPlayerId !== 'local') {
                        players.delete(localPlayerId);
                    }
                    connections.clear();
                    
                    // Restore to single player mode - use saved position from before connection attempt
                    localPlayerId = 'local';
                    localPlayer = createPlayer('local', true);
                    
                    // Restore position
                    if (savedX !== null && savedY !== null) {
                        localPlayer.x = savedX;
                        localPlayer.y = savedY;
                    }
                    
                    const colorPicker = document.getElementById('colorPicker');
                    if (colorPicker && localPlayer) {
                        const selectedColor = availableColors.find(c => c.id === selectedColorId);
                        if (selectedColor) {
                            localPlayer.color = hexToHsl(selectedColor.hex);
                        }
                    }
                    players.set('local', localPlayer);
                    
                    // Show error and return to join screen
                    alert('Room ID not found. Please check the room ID and try again.');
                    showJoinScreen();
                });
                
                // Also handle connection close (room might have closed)
                conn.on('close', () => {
                    console.log('Connection closed - room may not exist');
                    
                    // Only show error if we haven't successfully connected
                    if (!connections.has(conn.peer) && !connectionFailed) {
                        connectionFailed = true;
                        
                        // Clean up on connection close
                        if (peer) {
                            peer.destroy();
                            peer = null;
                        }
                        roomId = null;
                        isHost = false;
                        
                        // Don't reset player - restore original local player with saved position
                        // Just clear multiplayer state
                        if (localPlayerId && localPlayerId !== 'local') {
                            players.delete(localPlayerId);
                        }
                        connections.clear();
                        
                        // Restore to single player mode - use saved position from before connection attempt
                        localPlayerId = 'local';
                        localPlayer = createPlayer('local', true);
                        
                        // Restore position
                        if (savedX !== null && savedY !== null) {
                            localPlayer.x = savedX;
                            localPlayer.y = savedY;
                        }
                        
                        const colorPicker = document.getElementById('colorPicker');
                        if (colorPicker && localPlayer) {
                            const selectedColor = availableColors.find(c => c.id === selectedColorId);
                        if (selectedColor) {
                            localPlayer.color = hexToHsl(selectedColor.hex);
                        }
                        }
                        players.set('local', localPlayer);
                        
                        alert('Room ID not found. Please check the room ID and try again.');
                        showJoinScreen();
                    }
                });
            });
            
            peer.on('error', (err) => {
                console.error('Peer error:', err);
                connectionFailed = true;
                
                // Clean up on peer error
                if (peer) {
                    peer.destroy();
                    peer = null;
                }
                roomId = null;
                isHost = false;
                
                // Don't reset player - restore original local player with saved position
                // Just clear multiplayer state
                if (localPlayerId && localPlayerId !== 'local') {
                    players.delete(localPlayerId);
                }
                connections.clear();
                
                // Restore to single player mode - use saved position from before connection attempt
                localPlayerId = 'local';
                localPlayer = createPlayer('local', true);
                
                // Restore position
                if (savedX !== null && savedY !== null) {
                    localPlayer.x = savedX;
                    localPlayer.y = savedY;
                }
                
                const colorPicker = document.getElementById('colorPicker');
                if (colorPicker && localPlayer) {
                    localPlayer.color = hexToHsl(colorPicker.value);
                }
                players.set('local', localPlayer);
                
                // Show error message
                if (err.type === 'peer-unavailable') {
                    alert('Room ID not found. Please check the room ID and try again.');
                } else {
                    alert('Failed to connect. Please try again.');
                }
                showJoinScreen();
            });
        }
        
        function setupConnection(conn) {
            // Connection is already open when this is called from joinGame
            console.log('Setting up connection with:', conn.peer);
            connections.set(conn.peer, conn);
            
            // Send initial state to new connection
            if (localPlayer) {
                conn.send({
                    type: 'state',
                    id: localPlayerId,
                    x: localPlayer.x,
                    y: localPlayer.y,
                    vx: localPlayer.vx,
                    vy: localPlayer.vy
                });
                conn.send({
                    type: 'state_medium',
                    id: localPlayerId,
                    scaleX: localPlayer.scaleX,
                    scaleY: localPlayer.scaleY,
                    rotation: localPlayer.rotation,
                    isDashing: localPlayer.isDashing,
                    dashCooldown: localPlayer.dashCooldown,
                    color: localPlayer.color, // Send color to new connection
                    name: localPlayer.name // Send name to new connection
                });
                
                // Send image separately if it exists (to avoid large messages)
                if (localPlayer.image) {
                    conn.send({
                        type: 'image_update',
                        id: localPlayerId,
                        image: localPlayer.image
                    });
                }
            }
            
            // If we're the host, also connect this new player to existing players
            if (isHost) {
                connections.forEach((existingConn, peerId) => {
                    if (peerId !== conn.peer && existingConn.open) {
                        // Tell existing player about new player
                        existingConn.send({
                            type: 'new_player',
                            id: conn.peer
                        });
                        // Tell new player about existing player
                        conn.send({
                            type: 'new_player',
                            id: peerId
                        });
                    }
                });
            }
            
            updatePlayerList();
            
            conn.on('data', (data) => {
                handleNetworkData(data, conn.peer);
            });
            
            conn.on('close', () => {
                console.log('Connection closed with:', conn.peer);
                connections.delete(conn.peer);
                players.delete(conn.peer);
                updatePlayerList();
            });
            
            conn.on('error', (err) => {
                console.error('Connection error:', err);
            });
        }
        
        function handleNetworkData(data, peerId) {
            if (!data || !data.id) return;
            
            let player = players.get(data.id);
            
            if (data.type === 'state') {
                // High priority state update
                if (!player) {
                    player = createPlayer(data.id, false);
                    players.set(data.id, player);
                }
                
                player.targetX = data.x;
                player.targetY = data.y;
                player.targetVx = data.vx;
                player.targetVy = data.vy;
                player.lastUpdateTime = Date.now();
            } else if (data.type === 'state_medium') {
                // Medium priority state update
                if (!player) {
                    player = createPlayer(data.id, false);
                    players.set(data.id, player);
                }
                
                player.scaleX = data.scaleX;
                player.scaleY = data.scaleY;
                player.rotation = data.rotation;
                player.isDashing = data.isDashing;
                player.dashCooldown = data.dashCooldown;
                // Update color if provided
                if (data.color) {
                    player.color = data.color;
                }
                // Update name if provided
                if (data.name !== undefined) {
                    player.name = data.name;
                }
            } else if (data.type === 'image_update') {
                // Separate message type for image updates (to handle large data)
                if (!player) {
                    player = createPlayer(data.id, false);
                    players.set(data.id, player);
                }
                if (data.image !== undefined) {
                    player.image = data.image;
                }
            } else if (data.type === 'new_player') {
                // Another player joined - if we're not host, we might want to connect to them too
                // For now, just acknowledge
                console.log('New player in room:', data.id);
            }
        }
        
        function updatePlayerList() {
            const playerListEl = document.getElementById('playerList');
            if (!playerListEl) return;
            
                playerListEl.innerHTML = '<strong>Players (' + players.size + '):</strong><br>';
            players.forEach((player, peerId) => {
                const isLocal = peerId === localPlayerId;
                const statusClass = isLocal ? 'connected' : '';
                const displayName = player.name || `Player ${peerId.substring(0, 6)}`;
                playerListEl.innerHTML += `
                    <div class="player-list-item">
                        <span class="connection-status ${statusClass}"></span>
                        ${displayName}${isLocal ? ' (You)' : ''}
                    </div>
                `;
            });
        }
        
        function leaveGame() {
            // Close all connections
            connections.forEach((conn) => {
                conn.close();
            });
            connections.clear();
            
            // Close peer
            if (peer) {
                peer.destroy();
                peer = null;
            }
            
            // Clear players (keep local player for single player mode)
            players.clear();
            localPlayer = null;
            localPlayerId = null;
            isHost = false;
            roomId = null;
            
            // Exit any game mode when leaving
            if (currentGameMode) {
                currentGameMode = null;
                spikes = [];
            }
            
            // Update challenges button visibility
            updateChallengesButtonVisibility();
            
            // Recreate local player for single player
            localPlayerId = 'local';
            localPlayer = createPlayer('local', true);
            // Reset color from color picker
            const colorPicker = document.getElementById('colorPicker');
            if (colorPicker && localPlayer) {
                localPlayer.color = hexToHsl(colorPicker.value);
            }
            players.set('local', localPlayer);
            
            // Show main menu
            showMainMenu();
            updatePlayerList();
        }
        
        // Circular Health Bar Class
        class CircularHealthBar {
            constructor(containerId, options = {}) {
                // Configuration
                this.maxHealth = options.maxHealth || 100;
                this.currentHealth = options.currentHealth || this.maxHealth;
                this.radius = options.radius || 60;
                this.lineWidth = options.lineWidth || 12;
                this.glowSize = 20; // Size of the glow effect
                // Add extra padding for glow effect to prevent cutoff
                this.size = (this.radius + this.lineWidth + this.glowSize) * 2;
                
                // Colors
                this.bgColor = options.bgColor || '#1a1a2e';
                this.startColor = options.startColor || '#667eea';
                this.endColor = options.endColor || '#764ba2';
                this.glowColor = options.glowColor || '#667eea';
                
                // Animation
                this.animationDuration = options.animationDuration || 300; // ms
                this.animationStartTime = null;
                this.animationStartHealth = this.currentHealth;
                this.animationTargetHealth = this.currentHealth;
                this.isAnimating = false;
                
                // Create elements
                this.container = document.getElementById(containerId);
                this.container.className = 'health-bar-circular';
                this.container.style.width = this.size + 'px';
                this.container.style.height = this.size + 'px';
                
                // Create canvas
                this.canvas = document.createElement('canvas');
                this.canvas.width = this.size;
                this.canvas.height = this.size;
                this.ctx = this.canvas.getContext('2d');
                this.container.appendChild(this.canvas);
                
                // Create text overlay
                this.textContainer = document.createElement('div');
                this.textContainer.className = 'health-text';
                this.textContainer.innerHTML = `
                    <div class="health-value">${Math.round(this.currentHealth)}</div>
                    <div class="health-label">HP</div>
                `;
                this.container.appendChild(this.textContainer);
                
                // Initial draw
                this.draw();
            }
            
            draw() {
                const ctx = this.ctx;
                const centerX = this.size / 2;
                const centerY = this.size / 2;
                
                // Clear canvas
                ctx.clearRect(0, 0, this.size, this.size);
                
                // Calculate percentage
                const percentage = this.currentHealth / this.maxHealth;
                const endAngle = Math.PI * 2 * percentage;
                
                // Background circle removed - no box around health bar
                
                if (percentage > 0) {
                    // Draw health arc with gradient
                    const gradient = ctx.createLinearGradient(
                        centerX - this.radius, 
                        centerY, 
                        centerX + this.radius, 
                        centerY
                    );
                    gradient.addColorStop(0, this.startColor);
                    gradient.addColorStop(1, this.endColor);
                    
                    // Set glow effect
                    ctx.shadowBlur = this.glowSize;
                    ctx.shadowColor = this.glowColor;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, this.radius, -Math.PI / 2, -Math.PI / 2 + endAngle);
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = this.lineWidth;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                    
                    // Reset shadow
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                }
            }
            
            updateText() {
                const healthValue = this.textContainer.querySelector('.health-value');
                healthValue.textContent = Math.round(this.currentHealth);
                
                // Color based on health percentage
                const percentage = this.currentHealth / this.maxHealth;
                if (percentage > 0.5) {
                    healthValue.style.textShadow = '0 0 10px rgba(102, 126, 234, 0.8)';
                } else if (percentage > 0.25) {
                    healthValue.style.textShadow = '0 0 10px rgba(255, 200, 0, 0.8)';
                } else {
                    healthValue.style.textShadow = '0 0 10px rgba(255, 100, 100, 0.8)';
                }
            }
            
            animate(timestamp) {
                if (!this.animationStartTime) {
                    this.animationStartTime = timestamp;
                }
                
                const elapsed = timestamp - this.animationStartTime;
                const progress = Math.min(elapsed / this.animationDuration, 1);
                
                // Easing function (ease out)
                const eased = 1 - Math.pow(1 - progress, 3);
                
                // Interpolate health
                this.currentHealth = this.animationStartHealth + 
                    (this.animationTargetHealth - this.animationStartHealth) * eased;
                
                this.draw();
                this.updateText();
                
                if (progress < 1) {
                    requestAnimationFrame((t) => this.animate(t));
                } else {
                    this.currentHealth = this.animationTargetHealth;
                    this.isAnimating = false;
                    this.animationStartTime = null;
                }
            }
            
            setHealth(value, animate = true) {
                const newHealth = Math.max(0, Math.min(this.maxHealth, value));
                
                if (animate) {
                    this.animationStartHealth = this.currentHealth;
                    this.animationTargetHealth = newHealth;
                    
                    if (!this.isAnimating) {
                        this.isAnimating = true;
                        requestAnimationFrame((t) => this.animate(t));
                    }
                } else {
                    this.currentHealth = newHealth;
                    this.draw();
                    this.updateText();
                }
                
                // Check for death
                if (this.currentHealth <= 0 && !playerDead) {
                    playerDead = true;
                    if (localPlayer) {
                        localPlayer.dead = true;
                    }
                    triggerDeathEffect();
                    
                    // Check for match victory in VS modes
                    if (matchInProgress && (queueMode === '1v1' || queueMode === '2v2')) {
                        setTimeout(() => checkMatchVictory(), 500);
                    }
                    // Check for FreeForAll winner
                    if (freeForAllInProgress && currentGameMode === 'freeforall') {
                        setTimeout(() => checkFreeForAllWinner(), 500);
                    }
                }
            }
            
            takeDamage(amount) {
                this.setHealth(this.currentHealth - amount);
            }
            
            heal(amount) {
                this.setHealth(this.currentHealth + amount);
            }
            
            // Get current health percentage (useful for game logic)
            getPercentage() {
                return this.currentHealth / this.maxHealth;
            }
            
            // Change colors dynamically
            setColors(startColor, endColor, glowColor) {
                this.startColor = startColor;
                this.endColor = endColor;
                if (glowColor) this.glowColor = glowColor;
                this.draw();
            }
        }
        
        // Create health bar instance
        const healthBar = new CircularHealthBar('healthBar', {
            maxHealth: 100,
            currentHealth: 100,
            radius: 60,
            lineWidth: 12,
            startColor: '#667eea',
            endColor: '#764ba2',
            glowColor: '#667eea'
        });
        
        // Store health bar globally for scaling
        window.healthBar = healthBar;
        
        // Color is now handled by unlockable system - initialize selected color
        const initColor = availableColors.find(c => c.id === selectedColorId);
        if (initColor && localPlayer) {
            localPlayer.color = hexToHsl(initColor.hex);
        }
        
        // Setup name input
        const nameInput = document.getElementById('playerNameInput');
        if (nameInput) {
            nameInput.addEventListener('input', (e) => {
                if (localPlayer) {
                    localPlayer.name = e.target.value.trim() || null;
                    // Save to localStorage
                    try {
                        if (localPlayer.name) {
                            localStorage.setItem('playerName', localPlayer.name);
                        } else {
                            localStorage.removeItem('playerName');
                        }
                    } catch (err) {
                        console.warn('Could not save name to localStorage:', err);
                    }
                    // Update in players map
                    if (localPlayerId) {
                        players.set(localPlayerId, localPlayer);
                    }
                    // Broadcast name change immediately
                    if (connections.size > 0) {
                        const nameState = {
                            type: 'state_medium',
                            id: localPlayerId,
                            scaleX: localPlayer.scaleX,
                            scaleY: localPlayer.scaleY,
                            rotation: localPlayer.rotation,
                            isDashing: localPlayer.isDashing,
                            dashCooldown: localPlayer.dashCooldown,
                            color: localPlayer.color,
                            name: localPlayer.name
                        };
                        broadcastToAll(nameState);
                    }
                }
            });
        }
        
        // Setup image upload
        const imageInput = document.getElementById('actorImageInput');
        if (imageInput) {
            imageInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    // Resize and compress image before sending
                    const maxSize = 200; // Max width/height in pixels
                    const maxFileSize = 50000; // Max file size in bytes (50KB)
                    
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            // Create canvas to resize image
                            const canvas = document.createElement('canvas');
                            let width = img.width;
                            let height = img.height;
                            
                            // Resize if too large
                            if (width > maxSize || height > maxSize) {
                                if (width > height) {
                                    height = (height / width) * maxSize;
                                    width = maxSize;
                                } else {
                                    width = (width / height) * maxSize;
                                    height = maxSize;
                                }
                            }
                            
                            canvas.width = width;
                            canvas.height = height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, width, height);
                            
                            // Convert to data URL with compression
                            let imageData = canvas.toDataURL('image/jpeg', 0.7); // 70% quality
                            
                            // If still too large, reduce quality further
                            if (imageData.length > maxFileSize) {
                                imageData = canvas.toDataURL('image/jpeg', 0.5); // 50% quality
                            }
                            
                            if (imageData.length > maxFileSize) {
                                imageData = canvas.toDataURL('image/jpeg', 0.3); // 30% quality
                            }
                            
                            if (localPlayer) {
                                localPlayer.image = imageData;
                                // Save to localStorage
                                try {
                                    localStorage.setItem('playerImage', imageData);
                                } catch (err) {
                                    console.warn('Could not save image to localStorage:', err);
                                }
                                // Update in players map
                                if (localPlayerId) {
                                    players.set(localPlayerId, localPlayer);
                                }
                                updateImagePreview();
                                // Broadcast image change immediately using separate message type
                                if (connections.size > 0) {
                                    const imageState = {
                                        type: 'image_update',
                                        id: localPlayerId,
                                        image: localPlayer.image
                                    };
                                    broadcastToAll(imageState);
                                }
                            }
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            });
        }
        
        // Initialize local player for single player mode
        localPlayerId = 'local';
        localPlayer = createPlayer('local', true);
        // Set color from saved preference or color picker default
        const defaultColorPicker = document.getElementById('colorPicker');
        if (defaultColorPicker && localPlayer) {
            localPlayer.color = hexToHsl(defaultColorPicker.value);
        }
        players.set('local', localPlayer);
        
        // Initialize ocean background (after canvas is resized)
        if (canvas.width > 0 && canvas.height > 0) {
            oceanBackground = new OceanComplete(canvas);
        } else {
            // If canvas not ready, initialize on next frame
            setTimeout(() => {
                if (canvas.width > 0 && canvas.height > 0) {
                    oceanBackground = new OceanComplete(canvas);
                }
            }, 100);
        }
        
        // Start game loop
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>

