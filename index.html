<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Squash & Stretch Physics Demo</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            font-family: system-ui, -apple-system, sans-serif;
            color: #fff;
            overflow: hidden;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .canvas-container {
            flex: 1;
            position: relative;
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
            border: 2px solid #333;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(100, 150, 255, 0.3);
            image-rendering: -webkit-optimize-contrast;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        .controls {
            width: 300px;
            background: rgba(20, 20, 30, 0.9);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #333;
            max-height: 90vh;
            overflow-y: auto;
        }
        h2 {
            margin: 0 0 20px 0;
            color: #667eea;
            font-size: 20px;
        }
        .info {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 12px;
            color: #93c5fd;
        }
        label {
            display: block;
            margin: 15px 0 5px 0;
            font-size: 13px;
            color: #aaa;
        }
        input[type="range"] {
            width: 100%;
        }
        .value-display {
            float: right;
            color: #667eea;
            font-weight: 600;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            width: 100%;
            margin: 5px 0;
            transition: transform 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        .checkbox-container input[type="checkbox"] {
            width: auto;
            margin-right: 10px;
        }
        .instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
            transition: opacity 0.3s, visibility 0.3s;
        }
        
        .instructions.hidden {
            opacity: 0;
            visibility: hidden;
        }
        .key {
            display: inline-block;
            background: #667eea;
            padding: 2px 8px;
            border-radius: 4px;
            margin: 0 2px;
            font-weight: 600;
        }
        
        .health-bar-container {
            position: absolute;
            bottom: 40px;
            right: 40px;
            z-index: 10;
            background: transparent;
        }
        
        .health-bar-circular {
            position: relative;
            width: 150px;
            height: 150px;
            background: transparent;
        }
        
        .health-bar-circular canvas {
            display: block;
            background: transparent !important;
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
        }
        
        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
        }
        
        .health-value {
            font-size: 32px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px rgba(102, 126, 234, 0.8);
        }
        
        .health-label {
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .dash-indicator {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
            transition: background 0.2s, box-shadow 0.2s;
        }
        
        .dash-indicator.cooldown {
            background: #ff0000;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
        }
        .multiplayer-ui {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(20, 20, 30, 0.95);
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #667eea;
            display: block;
            transition: opacity 0.3s, visibility 0.3s;
        }
        
        .multiplayer-ui.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        
        .multiplayer-ui h3 {
            margin: 0 0 15px 0;
            color: #667eea;
            font-size: 18px;
        }
        
        .multiplayer-ui button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin: 5px;
            transition: transform 0.2s;
        }
        
        .multiplayer-ui button:hover {
            transform: translateY(-2px);
        }
        
        .multiplayer-ui input {
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            margin: 5px;
            width: 200px;
        }
        
        .room-id-display {
            margin: 10px 0;
            padding: 10px;
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 4px;
            font-family: monospace;
            font-size: 16px;
            color: #667eea;
        }
        
        .player-list {
            margin-top: 15px;
            font-size: 12px;
            color: #aaa;
        }
        
        .player-list-item {
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .connection-status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            background: #ff0000;
        }
        
        .connection-status.connected {
            background: #00ff00;
        }
        
        .color-picker-widget {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 20, 30, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #667eea;
            z-index: 100;
            transition: opacity 0.3s, visibility 0.3s;
        }
        
        .color-picker-widget.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        
        .color-picker-widget h4 {
            margin: 0 0 10px 0;
            color: #667eea;
            font-size: 14px;
        }
        
        .color-picker-widget input[type="color"] {
            width: 60px;
            height: 60px;
            border: 2px solid #667eea;
            border-radius: 8px;
            cursor: pointer;
            background: none;
        }
        
        .color-picker-widget label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-top: 8px;
        }
        
        /* Menu Widget - Small compact design */
        .menu-widget {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 200;
            background: rgba(20, 20, 30, 0.95);
            border-radius: 8px;
            border: 2px solid #667eea;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .menu-widget.collapsed {
            width: 280px;
        }
        
        .menu-widget.expanded {
            width: 280px;
            min-height: 200px;
        }
        
        .menu-toggle-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            width: 100%;
            transition: transform 0.2s;
        }
        
        .menu-toggle-button:hover {
            transform: translateY(-2px);
        }
        
        .menu-content {
            display: none;
            padding: 15px;
        }
        
        .menu-widget.expanded .menu-content {
            display: block;
        }
        
        .menu-screen {
            display: none;
        }
        
        .menu-screen.active {
            display: block;
        }
        
        .menu-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            width: 100%;
            margin: 6px 0;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .menu-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.4);
        }
        
        .menu-button:active {
            transform: translateY(0);
        }
        
        .menu-input {
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 13px;
            width: calc(100% - 24px);
            margin: 8px 0;
        }
        
        .menu-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 5px rgba(102, 126, 234, 0.3);
        }
        
        .menu-widget .room-id-display {
            margin: 10px 0;
            padding: 10px;
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            color: #667eea;
            text-align: center;
            word-break: break-all;
        }
        
        .menu-widget .player-list {
            margin: 10px 0;
            font-size: 11px;
            color: #aaa;
            max-height: 120px;
            overflow-y: auto;
        }
        
        .menu-widget .player-list-item {
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .menu-widget .connection-status {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            margin-right: 6px;
            background: #ff0000;
        }
        
        .menu-widget .connection-status.connected {
            background: #00ff00;
        }
        
        .menu-widget .controls-info {
            background: rgba(10, 10, 20, 0.5);
            padding: 12px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 12px;
            line-height: 1.6;
        }
        
        .menu-widget .controls-info .key {
            display: inline-block;
            background: #667eea;
            padding: 2px 6px;
            border-radius: 3px;
            margin: 0 2px;
            font-weight: 600;
            font-size: 11px;
        }
        
        .menu-widget .color-picker-container {
            text-align: center;
            margin: 15px 0;
        }
        
        .menu-widget .color-picker-container h4 {
            margin: 0 0 10px 0;
            color: #667eea;
            font-size: 14px;
        }
        
        .menu-widget .color-picker-container input[type="color"] {
            width: 60px;
            height: 60px;
            border: 2px solid #667eea;
            border-radius: 8px;
            cursor: pointer;
            background: none;
        }
        
        .menu-widget .color-picker-container label {
            display: block;
            font-size: 11px;
            color: #aaa;
            margin-top: 8px;
        }
        
        .menu-widget h3 {
            margin: 0 0 12px 0;
            color: #667eea;
            font-size: 16px;
        }
        
        .version-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 10;
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            font-family: monospace;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="menu-widget collapsed" id="menuWidget">
        <button class="menu-toggle-button" onclick="toggleMenuWidget()">Menu</button>
        <div class="menu-content">
            <!-- Main Menu Screen -->
            <div class="menu-screen active" id="mainMenuScreen">
                <button class="menu-button" onclick="resumeGame()">Resume</button>
                <button class="menu-button" onclick="showVSMenu()">VS</button>
                <button class="menu-button" onclick="showMultiplayerMenu()">Multiplayer</button>
                <button class="menu-button" id="challengesButton" onclick="showChallengesMenu()" style="display: none;">Challenges</button>
                <button class="menu-button" onclick="showStatsMenu()">Stats</button>
                <button class="menu-button" onclick="showControlsMenu()">Controls</button>
                <button class="menu-button" onclick="showCustomizeMenu()">Customize</button>
                <button class="menu-button" onclick="goToShangkoStudio()">HomePage</button>
            </div>
            
            <!-- Multiplayer Menu Screen -->
            <div class="menu-screen" id="multiplayerMenuScreen">
                <h3>Multiplayer</h3>
                <button class="menu-button" onclick="hostGame()">Host Game</button>
                <button class="menu-button" onclick="showJoinScreen()">Join Game</button>
                <button class="menu-button" onclick="showMainMenu()">Back</button>
            </div>
            
            <!-- Join Game Screen -->
            <div class="menu-screen" id="joinGameScreen">
                <h3>Join Game</h3>
                <input type="text" class="menu-input" id="roomIdInput" placeholder="Enter Room ID">
                <button class="menu-button" onclick="joinGame()">Connect</button>
                <button class="menu-button" onclick="showMultiplayerMenu()">Back</button>
            </div>
            
            <!-- Game Screen (when in multiplayer) -->
            <div class="menu-screen" id="gameScreen">
                <h3>Multiplayer</h3>
                <div class="room-id-display" id="roomIdDisplay"></div>
                <div class="player-list" id="playerList"></div>
                <button class="menu-button" onclick="leaveGame()">Leave Game</button>
                <button class="menu-button" onclick="showMainMenu()">Back to Menu</button>
            </div>
            
            <!-- Controls Screen -->
            <div class="menu-screen" id="controlsScreen">
                <h3>Controls</h3>
                <div class="controls-info">
                    <div><strong>Movement:</strong></div>
                    <div><span class="key">W A S D</span> or <span class="key">Arrow Keys</span> - Move</div>
                    <div><span class="key">Space</span> or <span class="key">Double Click</span> - Dash</div>
                    <div><span class="key">Click</span> - Move to mouse</div>
                    <div style="margin-top: 10px;"><strong>Menu:</strong></div>
                    <div><span class="key">ESC</span> or <span class="key">P</span> - Toggle Menu</div>
                </div>
                <button class="menu-button" onclick="showMainMenu()">Back</button>
            </div>
            
            <!-- Customize Screen -->
            <div class="menu-screen" id="customizeScreen">
                <h3>Customize</h3>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; color: #aaa; font-size: 12px; margin-bottom: 5px;">Player Name</label>
                    <input type="text" class="menu-input" id="playerNameInput" placeholder="Enter your name" maxlength="20">
                </div>
                <div class="color-picker-container">
                    <h4>Player Color</h4>
                    <input type="color" id="colorPicker" value="#3b82f6">
                    <label>Choose your bubble color</label>
                </div>
                <div style="margin-top: 15px;">
                    <label style="display: block; color: #aaa; font-size: 12px; margin-bottom: 5px;">Actor Image</label>
                    <input type="file" id="actorImageInput" accept="image/*" style="display: none;">
                    <button class="menu-button" onclick="document.getElementById('actorImageInput').click()" style="margin: 0;">Choose Image</button>
                    <div id="imagePreview" style="margin-top: 10px; text-align: center; display: none;">
                        <img id="previewImg" style="max-width: 60px; max-height: 60px; border-radius: 4px; border: 2px solid #667eea;">
                        <button class="menu-button" onclick="clearImage()" style="margin-top: 5px; padding: 5px 10px; font-size: 12px;">Remove Image</button>
                    </div>
                </div>
                <button class="menu-button" onclick="showMainMenu()">Back</button>
            </div>
            
            <!-- VS Menu Screen -->
            <div class="menu-screen" id="vsMenuScreen">
                <h3>VS Matchmaking</h3>
                <div id="queueStatus" style="color: #aaa; font-size: 12px; margin-bottom: 10px; text-align: center;">Not in queue</div>
                <div id="rankingInfo" style="background: rgba(102, 126, 234, 0.1); padding: 10px; border-radius: 6px; margin-bottom: 10px; font-size: 11px; text-align: center;">
                    <div id="rankTierDisplay" style="font-weight: 600; margin-bottom: 3px;"></div>
                    <div id="rankRatingDisplay" style="color: #aaa;"></div>
                </div>
                <button class="menu-button" id="queue1v1Button" onclick="joinQueue('1v1')">1v1</button>
                <button class="menu-button" id="queue2v2Button" onclick="joinQueue('2v2')">2v2</button>
                <button class="menu-button" id="cancelQueueButton" onclick="cancelQueue()" style="display: none;">Cancel Queue</button>
                <button class="menu-button" onclick="showStatsMenu()">Stats</button>
                <button class="menu-button" onclick="showMainMenu()">Back</button>
            </div>
            
            <!-- Stats Menu Screen -->
            <div class="menu-screen" id="statsMenuScreen">
                <h3>Player Stats</h3>
                <div id="statsDisplay" style="background: rgba(10, 10, 20, 0.5); padding: 15px; border-radius: 6px; margin-bottom: 10px; font-size: 12px; max-height: 400px; overflow-y: auto;">
                    <!-- Stats will be populated by JavaScript -->
                </div>
                <button class="menu-button" onclick="showMainMenu()">Back to Menu</button>
            </div>
            
            <!-- Challenges Menu Screen -->
            <div class="menu-screen" id="challengesMenuScreen">
                <h3>Challenges</h3>
                <button class="menu-button" onclick="startSpikeDodge()">Spike Dodge</button>
                <div style="color: #aaa; font-size: 11px; margin-top: 10px; text-align: center;">
                    Dodge falling spikes!<br>
                    They get faster and more numerous over time.<br><br>
                    <span style="color: #ffd700;">Best Score: <span id="spikeDodgeBestScoreDisplay">0</span></span>
                </div>
                <button class="menu-button" onclick="showMainMenu()">Back</button>
            </div>
        </div>
    </div>
    
    <div class="container">
        <div class="canvas-container">
            <canvas id="gameCanvas"></canvas>
            <div class="health-bar-container">
                <div id="healthBar"></div>
                <div id="dashIndicator" class="dash-indicator"></div>
            </div>
            <div class="version-info" id="versionInfo">v1.0.0</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Default values
        const DEFAULT_STRETCH_INTENSITY = 2;
        const DEFAULT_SQUASH_INTENSITY = 0.7;
        const DEFAULT_DEFORM_SPEED = 0.25;
        const DEFAULT_MOVE_SPEED = 5;
        const DEFAULT_DASH_MULT = 2.5;
        const DEFAULT_BUBBLE_SIZE = 50;
        const DEFAULT_SHOW_VELOCITY = false;
        const DEFAULT_SHOW_TRAIL = true;
        const DEFAULT_WOBBLE_ON_IDLE = true;
        
        // Ocean background variable (declared early so resizeCanvas can access it)
        let oceanBackground = null;
        
        // Base resolution for the game (maintains consistent game logic)
        const BASE_WIDTH = 1920;
        const BASE_HEIGHT = 1080;
        const BASE_ASPECT_RATIO = BASE_WIDTH / BASE_HEIGHT;
        
        // Global scale factor for UI elements
        let currentScale = 1;
        let canvasDisplayWidth = BASE_WIDTH;
        let canvasDisplayHeight = BASE_HEIGHT;
        let canvasOffsetX = 0;
        let canvasOffsetY = 0;
        
        // Set canvas size to match container with proper scaling
        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            const containerAspectRatio = containerWidth / containerHeight;
            
            const oldWidth = canvas.width;
            const oldHeight = canvas.height;
            
            // Calculate scale to fill container while maintaining aspect ratio
            // Use the larger scale to ensure it fills the screen
            let scale, displayWidth, displayHeight;
            
            const scaleX = containerWidth / BASE_WIDTH;
            const scaleY = containerHeight / BASE_HEIGHT;
            
            // Use the smaller scale to ensure it fits (letterbox/pillarbox)
            // This ensures the game always fits and maintains aspect ratio
            scale = Math.min(scaleX, scaleY);
            
            displayWidth = BASE_WIDTH * scale;
            displayHeight = BASE_HEIGHT * scale;
            
            // Store scale and dimensions for UI positioning
            currentScale = scale;
            canvasDisplayWidth = displayWidth;
            canvasDisplayHeight = displayHeight;
            canvasOffsetX = (containerWidth - displayWidth) / 2;
            canvasOffsetY = (containerHeight - displayHeight) / 2;
            
            // Set canvas internal resolution (always use base resolution for game logic)
            canvas.width = BASE_WIDTH;
            canvas.height = BASE_HEIGHT;
            
            // Set canvas display size (scaled to fit container)
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            
            // Always center the canvas
            canvas.style.marginLeft = canvasOffsetX + 'px';
            canvas.style.marginTop = canvasOffsetY + 'px';
            canvas.style.marginRight = 'auto';
            canvas.style.marginBottom = 'auto';
            
            // Update UI element positions and sizes
            updateUIPositions();
            
            // Reinitialize ocean background if size changed
            if (oceanBackground && (oldWidth !== canvas.width || oldHeight !== canvas.height)) {
                oceanBackground.resize();
            }
        }
        
        // Update UI element positions and sizes based on canvas scale
        function updateUIPositions() {
            const container = canvas.parentElement;
            
            // Update menu widget
            const menuWidget = document.getElementById('menuWidget');
            if (menuWidget) {
                // Scale menu size
                const baseMenuWidth = 280;
                menuWidget.style.width = (baseMenuWidth * currentScale) + 'px';
                
                // Scale all menu elements
                const menuButtons = menuWidget.querySelectorAll('.menu-button, .menu-toggle-button');
                menuButtons.forEach(button => {
                    button.style.fontSize = (14 * currentScale) + 'px';
                    button.style.padding = (12 * currentScale) + 'px ' + (20 * currentScale) + 'px';
                    button.style.borderRadius = (6 * currentScale) + 'px';
                });
                
                // Scale menu content
                const menuContent = menuWidget.querySelector('.menu-content');
                if (menuContent) {
                    menuContent.style.padding = (15 * currentScale) + 'px';
                }
                
                // Scale menu headings
                const menuHeadings = menuWidget.querySelectorAll('h3');
                menuHeadings.forEach(heading => {
                    heading.style.fontSize = (16 * currentScale) + 'px';
                    heading.style.marginBottom = (12 * currentScale) + 'px';
                });
                
                // Scale menu inputs
                const menuInputs = menuWidget.querySelectorAll('.menu-input');
                menuInputs.forEach(input => {
                    input.style.fontSize = (13 * currentScale) + 'px';
                    input.style.padding = (8 * currentScale) + 'px ' + (12 * currentScale) + 'px';
                    input.style.borderRadius = (4 * currentScale) + 'px';
                });
                
                // Scale other text elements
                const infoTexts = menuWidget.querySelectorAll('.controls-info, .room-id-display, .player-list');
                infoTexts.forEach(text => {
                    text.style.fontSize = (12 * currentScale) + 'px';
                });
                
                // Position relative to canvas display area
                menuWidget.style.left = (canvasOffsetX + 20 * currentScale) + 'px';
                menuWidget.style.top = (canvasOffsetY + 20 * currentScale) + 'px';
            }
            
            // Update health bar container
            const healthBarContainer = document.querySelector('.health-bar-container');
            if (healthBarContainer) {
                const baseHealthSize = 150;
                healthBarContainer.style.width = (baseHealthSize * currentScale) + 'px';
                healthBarContainer.style.height = (baseHealthSize * currentScale) + 'px';
                healthBarContainer.style.right = (canvasOffsetX + 40 * currentScale) + 'px';
                healthBarContainer.style.bottom = (canvasOffsetY + 40 * currentScale) + 'px';
                
                // Update health bar size
                const healthBar = document.getElementById('healthBar');
                if (healthBar && healthBar.querySelector('.health-bar-circular')) {
                    const healthBarCircular = healthBar.querySelector('.health-bar-circular');
                    healthBarCircular.style.width = (baseHealthSize * currentScale) + 'px';
                    healthBarCircular.style.height = (baseHealthSize * currentScale) + 'px';
                    
                    // Update health bar canvas - need to recreate with new scale
                    const healthCanvas = healthBarCircular.querySelector('canvas');
                    if (healthCanvas && window.healthBar) {
                        const baseRadius = 60;
                        const baseLineWidth = 12;
                        const baseGlowSize = 20;
                        const newSize = (baseRadius + baseLineWidth + baseGlowSize) * 2 * currentScale;
                        const newRadius = baseRadius * currentScale;
                        const newLineWidth = baseLineWidth * currentScale;
                        
                        // Update health bar properties
                        window.healthBar.radius = newRadius;
                        window.healthBar.lineWidth = newLineWidth;
                        window.healthBar.glowSize = baseGlowSize * currentScale;
                        window.healthBar.size = newSize;
                        
                        healthCanvas.width = newSize;
                        healthCanvas.height = newSize;
                        healthCanvas.style.width = newSize + 'px';
                        healthCanvas.style.height = newSize + 'px';
                        
                        // Redraw health bar
                        window.healthBar.draw();
                    }
                    
                    // Update health text size
                    const healthText = healthBarCircular.querySelector('.health-text');
                    if (healthText) {
                        const healthValue = healthText.querySelector('.health-value');
                        const healthLabel = healthText.querySelector('.health-label');
                        if (healthValue) {
                            healthValue.style.fontSize = (32 * currentScale) + 'px';
                        }
                        if (healthLabel) {
                            healthLabel.style.fontSize = (12 * currentScale) + 'px';
                        }
                    }
                }
                
                // Update dash indicator
                const dashIndicator = document.getElementById('dashIndicator');
                if (dashIndicator) {
                    dashIndicator.style.width = (20 * currentScale) + 'px';
                    dashIndicator.style.height = (20 * currentScale) + 'px';
                    dashIndicator.style.bottom = (10 * currentScale) + 'px';
                }
            }
            
            // Update version info
            const versionInfo = document.getElementById('versionInfo');
            if (versionInfo) {
                versionInfo.style.fontSize = (12 * currentScale) + 'px';
                versionInfo.style.right = (canvasOffsetX + 20 * currentScale) + 'px';
                versionInfo.style.bottom = (canvasOffsetY + 20 * currentScale) + 'px';
            }
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Multiplayer state
        let peer = null;
        let connections = new Map(); // peerId -> DataConnection
        let players = new Map(); // peerId -> player data
        let localPlayerId = null;
        let isHost = false;
        let roomId = null;
        let lastSyncTime = 0;
        const SYNC_INTERVAL = 1000 / 60; // 60fps for position/velocity
        const SYNC_INTERVAL_MEDIUM = 1000 / 30; // 30fps for scale/rotation
        let lastSyncTimeMedium = 0;
        
        // Image cache for player images
        const imageCache = new Map(); // imageData -> Image object
        
        // Matchmaking state
        let inQueue = false;
        let queueMode = null; // '1v1' or '2v2'
        let matchmakingPeer = null;
        let matchmakingConnections = new Map();
        let matchInProgress = false;
        let playerTeams = new Map(); // playerId -> team (1 or 2)
        let team1Players = [];
        let team2Players = [];
        
        // Ranking system
        let playerRanking = {
            rating: 1000, // Starting ELO rating
            wins: 0,
            losses: 0,
            draws: 0,
            winStreak: 0,
            bestWinStreak: 0,
            totalMatches: 0,
            // Spike Dodge Challenge stats
            spikeDodge: {
                bestScore: 0,
                totalPlayed: 0,
                totalSpikesDodged: 0,
                averageScore: 0
            }
        };
        
        // Load ranking from localStorage
        function loadRanking() {
            try {
                const saved = localStorage.getItem('playerRanking');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    playerRanking = { ...playerRanking, ...parsed };
                }
            } catch (e) {
                console.warn('Could not load ranking from localStorage:', e);
            }
        }
        
        // Save ranking to localStorage
        function saveRanking() {
            try {
                localStorage.setItem('playerRanking', JSON.stringify(playerRanking));
            } catch (e) {
                console.warn('Could not save ranking to localStorage:', e);
            }
        }
        
        // Calculate ELO rating change
        function calculateELOChange(myRating, opponentRating, result) {
            // result: 1 = win, 0.5 = draw, 0 = loss
            const K = 32; // K-factor (how much rating changes per game)
            const expectedScore = 1 / (1 + Math.pow(10, (opponentRating - myRating) / 400));
            const ratingChange = Math.round(K * (result - expectedScore));
            return ratingChange;
        }
        
        // Update ranking after match result
        function updateRanking(result, opponentRating = null) {
            // result: 'win', 'loss', 'draw'
            if (result === 'win') {
                playerRanking.wins++;
                playerRanking.winStreak++;
                if (playerRanking.winStreak > playerRanking.bestWinStreak) {
                    playerRanking.bestWinStreak = playerRanking.winStreak;
                }
                // Estimate opponent rating if not provided (average of all players)
                const estimatedOpponentRating = opponentRating || playerRanking.rating;
                const ratingChange = calculateELOChange(playerRanking.rating, estimatedOpponentRating, 1);
                playerRanking.rating += ratingChange;
            } else if (result === 'loss') {
                playerRanking.losses++;
                playerRanking.winStreak = 0;
                const estimatedOpponentRating = opponentRating || playerRanking.rating;
                const ratingChange = calculateELOChange(playerRanking.rating, estimatedOpponentRating, 0);
                playerRanking.rating += ratingChange;
            } else if (result === 'draw') {
                playerRanking.draws++;
                playerRanking.winStreak = 0;
                const estimatedOpponentRating = opponentRating || playerRanking.rating;
                const ratingChange = calculateELOChange(playerRanking.rating, estimatedOpponentRating, 0.5);
                playerRanking.rating += ratingChange;
            }
            
            playerRanking.totalMatches++;
            playerRanking.rating = Math.max(0, Math.round(playerRanking.rating)); // Ensure rating doesn't go negative
            saveRanking();
            return playerRanking;
        }
        
        // Get rank tier based on rating
        function getRankTier(rating) {
            if (rating >= 2000) return { name: 'Grandmaster', color: '#ff00ff' };
            if (rating >= 1800) return { name: 'Master', color: '#ff6600' };
            if (rating >= 1600) return { name: 'Diamond', color: '#00ccff' };
            if (rating >= 1400) return { name: 'Platinum', color: '#00ffcc' };
            if (rating >= 1200) return { name: 'Gold', color: '#ffd700' };
            if (rating >= 1000) return { name: 'Silver', color: '#c0c0c0' };
            return { name: 'Bronze', color: '#cd7f32' };
        }
        
        // Load ranking on startup
        loadRanking();
        let matchmakingRoomId = null;
        let isMatchmakingHost = false;
        let matchmakingCheckInterval = null;
        
        // Challenges/Game modes state
        let currentGameMode = null; // 'spike_dodge' or null
        let spikes = [];
        let spikeSpawnTimer = 0;
        let spikeSpeed = 2;
        let spikeSpawnRate = 2000; // milliseconds
        let gameStartTime = 0;
        let spikesDodged = 0;
        let playerDead = false;
        let deathParticles = [];
        
        // Player bubble - initialize after canvas is resized
        function createPlayer(id, isLocal = false) {
            const player = {
                id: id,
                x: canvas.width / 2 + (Math.random() - 0.5) * 100,
                y: canvas.height / 2 + (Math.random() - 0.5) * 100,
                vx: 0,
                vy: 0,
                baseRadius: DEFAULT_BUBBLE_SIZE,
                scaleX: 1,
                scaleY: 1,
                targetScaleX: 1,
                targetScaleY: 1,
                rotation: 0,
                isDashing: false,
                dashCooldown: 0,
                trail: [],
                color: isLocal ? null : generatePlayerColor(id), // Local player uses default, others get unique colors
                name: null,
                image: null,
                health: 100,
                maxHealth: 100,
                lastCollisionTime: 0, // Prevent multiple damage from same collision
                dead: false,
                // Interpolation for smooth remote player movement
                targetX: 0,
                targetY: 0,
                targetVx: 0,
                targetVy: 0,
                lastUpdateTime: Date.now()
            };
            
            // Load saved name and image for local player
            if (isLocal) {
                try {
                    const savedName = localStorage.getItem('playerName');
                    if (savedName) {
                        player.name = savedName;
                    }
                    const savedImage = localStorage.getItem('playerImage');
                    if (savedImage) {
                        player.image = savedImage;
                    }
                } catch (e) {
                    console.warn('Could not load player data from localStorage:', e);
                }
            }
            
            return player;
        }
        
        function generatePlayerColor(id) {
            // Generate consistent color based on player ID
            const hue = (id.charCodeAt(0) * 137.508) % 360;
            return `hsl(${hue}, 70%, 60%)`;
        }
        
        let localPlayer = null;
        
        // Ocean Background
        class OceanComplete {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = ctx; // Use the global ctx instead of creating a new one
                this.initParticles();
            }
            
            initParticles() {
                this.particles = [];
                const particleCount = 80; // Number of background particles
                
                for (let i = 0; i < particleCount; i++) {
                    this.particles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        radius: 1 + Math.random() * 2,
                        speedX: (Math.random() - 0.5) * 0.5,
                        speedY: (Math.random() - 0.5) * 0.5,
                        opacity: 0.3 + Math.random() * 0.4,
                        color: this.getRandomParticleColor()
                    });
                }
            }
            
            getRandomParticleColor() {
                const colors = [
                    'rgba(100, 200, 255, ', // Light blue
                    'rgba(150, 220, 255, ', // Cyan
                    'rgba(200, 240, 255, ', // Very light blue
                    'rgba(100, 180, 255, ', // Medium blue
                    'rgba(59, 130, 246, '   // Blue
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            updateParticles() {
                this.particles.forEach(particle => {
                    // Update position
                    particle.x += particle.speedX;
                    particle.y += particle.speedY;
                    
                    // Wrap around edges
                    if (particle.x < 0) particle.x = this.canvas.width;
                    if (particle.x > this.canvas.width) particle.x = 0;
                    if (particle.y < 0) particle.y = this.canvas.height;
                    if (particle.y > this.canvas.height) particle.y = 0;
                    
                    // Subtle opacity variation
                    particle.opacity += (Math.random() - 0.5) * 0.02;
                    particle.opacity = Math.max(0.2, Math.min(0.7, particle.opacity));
                });
            }
            
            drawParticles() {
                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.opacity;
                    this.ctx.fillStyle = particle.color + particle.opacity + ')';
                    
                    // Draw particle with glow effect
                    this.ctx.shadowBlur = 5;
                    this.ctx.shadowColor = particle.color + particle.opacity + ')';
                    
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                });
            }
            
            // === WAVES ===
            initWaves() {
                this.waves = [];
                this.colors = [
                    { top: '#001a33', bottom: '#003d5c' },
                    { top: '#002a44', bottom: '#004d6d' },
                    { top: '#003355', bottom: '#005577' }
                ];
                
                for (let i = 0; i < 5; i++) {
                    this.waves.push({
                        amplitude: 30 + Math.random() * 40,
                        frequency: 0.003 + Math.random() * 0.002,
                        speed: 0.0005 + Math.random() * 0.001,
                        offset: Math.random() * Math.PI * 2,
                        yPosition: this.canvas.height * (0.3 + i * 0.15),
                        color: this.colors[i % this.colors.length],
                        phase: 0
                    });
                }
            }
            
            updateWaves(time) {
                this.waves.forEach(wave => {
                    wave.phase = time * wave.speed;
                });
            }
            
            drawWaves() {
                // Draw waves from back to front
                this.waves.forEach((wave, index) => {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, this.canvas.height);
                    
                    for (let x = 0; x <= this.canvas.width; x += 5) {
                        const y = wave.yPosition + 
                            Math.sin(x * wave.frequency + wave.phase + wave.offset) * wave.amplitude;
                        this.ctx.lineTo(x, y);
                    }
                    
                    this.ctx.lineTo(this.canvas.width, this.canvas.height);
                    this.ctx.closePath();
                    
                    const waveGradient = this.ctx.createLinearGradient(0, wave.yPosition - 50, 0, this.canvas.height);
                    waveGradient.addColorStop(0, wave.color.top);
                    waveGradient.addColorStop(1, wave.color.bottom);
                    
                    this.ctx.fillStyle = waveGradient;
                    this.ctx.fill();
                    
                    // Wave highlights
                    this.ctx.strokeStyle = `rgba(0, 200, 255, ${0.2 - index * 0.03})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                });
            }
            
            // === BUBBLES ===
            initBubbles() {
                this.bubbles = [];
                // Reduced from 50 to 30 for better performance
                for (let i = 0; i < 30; i++) {
                    this.bubbles.push(this.createBubble());
                }
            }
            
            createBubble() {
                return {
                    x: Math.random() * this.canvas.width,
                    y: this.canvas.height + Math.random() * 200,
                    radius: 3 + Math.random() * 15,
                    speed: 0.5 + Math.random() * 1.5,
                    wobble: Math.random() * 0.02,
                    wobbleOffset: Math.random() * Math.PI * 2,
                    opacity: 0.3 + Math.random() * 0.4
                };
            }
            
            updateBubbles() {
                this.bubbles.forEach(bubble => {
                    bubble.y -= bubble.speed;
                    bubble.x += Math.sin(bubble.y * bubble.wobble + bubble.wobbleOffset) * 0.5;
                    
                    if (bubble.y < -bubble.radius * 2) {
                        Object.assign(bubble, this.createBubble());
                        bubble.y = this.canvas.height + Math.random() * 200;
                    }
                });
            }
            
            drawBubbles() {
                this.bubbles.forEach(bubble => {
                    // Bubble gradient
                    const bubbleGradient = this.ctx.createRadialGradient(
                        bubble.x - bubble.radius * 0.3,
                        bubble.y - bubble.radius * 0.3,
                        0,
                        bubble.x,
                        bubble.y,
                        bubble.radius
                    );
                    bubbleGradient.addColorStop(0, `rgba(200, 240, 255, ${bubble.opacity})`);
                    bubbleGradient.addColorStop(0.7, `rgba(100, 200, 255, ${bubble.opacity * 0.5})`);
                    bubbleGradient.addColorStop(1, `rgba(0, 150, 255, 0)`);
                    
                    this.ctx.fillStyle = bubbleGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Highlight
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${bubble.opacity * 0.6})`;
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x - bubble.radius * 0.3, bubble.y - bubble.radius * 0.3, bubble.radius * 0.3, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Rim
                    this.ctx.strokeStyle = `rgba(200, 240, 255, ${bubble.opacity * 0.4})`;
                    this.ctx.lineWidth = 1.5;
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                });
            }
            
            // === CAUSTIC LIGHT ===
            initCaustics() {
                this.caustics = [];
                // Reduced from 10 to 6 for better performance
                for (let i = 0; i < 6; i++) {
                    this.caustics.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        radius: 100 + Math.random() * 200,
                        speed: 0.0002 + Math.random() * 0.0003,
                        phase: Math.random() * Math.PI * 2
                    });
                }
            }
            
            updateCaustics(time) {
                this.caustics.forEach(c => {
                    c.phase = time * c.speed;
                });
            }
            
            drawCaustics() {
                this.ctx.globalCompositeOperation = 'lighter';
                
                this.caustics.forEach(c => {
                    const x = c.x + Math.sin(c.phase) * 50;
                    const y = c.y + Math.cos(c.phase * 0.7) * 30;
                    
                    const causticGradient = this.ctx.createRadialGradient(x, y, 0, x, y, c.radius);
                    causticGradient.addColorStop(0, 'rgba(100, 220, 255, 0.3)');
                    causticGradient.addColorStop(0.5, 'rgba(0, 200, 255, 0.1)');
                    causticGradient.addColorStop(1, 'rgba(0, 150, 255, 0)');
                    
                    this.ctx.fillStyle = causticGradient;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                });
                
                this.ctx.globalCompositeOperation = 'source-over';
            }
            
            // === MAIN UPDATE & DRAW ===
            update(time) {
                this.updateParticles();
            }
            
            draw(time) {
                // Smooth blue gradient background with multiple color stops
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#004d6d');      // Light blue at top
                gradient.addColorStop(0.3, '#003d5c');    // Medium-light blue
                gradient.addColorStop(0.6, '#002a44');    // Medium blue
                gradient.addColorStop(0.85, '#001f33');   // Medium-dark blue
                gradient.addColorStop(1, '#001a33');      // Dark blue at bottom
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw particles on top of gradient
                this.drawParticles();
            }
            
            // Reinitialize when canvas resizes
            resize() {
                // Reinitialize particles with new canvas size
                this.initParticles();
            }
        }
        
        // Input handling
        const keys = {};
        let mouseX = 0;
        let mouseY = 0;
        let mouseDown = false;
        let lastClickTime = 0;
        const DOUBLE_CLICK_DELAY = 300; // milliseconds
        
        // UI visibility state
        let uiVisible = true;
        
        // Menu state - Game is never paused, menu is just an overlay
        let menuVisible = false;
        
        function toggleMenuWidget() {
            const menuWidget = document.getElementById('menuWidget');
            if (!menuWidget) return;
            
            menuVisible = !menuVisible;
            
            if (menuVisible) {
                menuWidget.classList.remove('collapsed');
                menuWidget.classList.add('expanded');
                showMainMenu();
            } else {
                menuWidget.classList.remove('expanded');
                menuWidget.classList.add('collapsed');
            }
        }
        
        function toggleMenu() {
            toggleMenuWidget();
        }
        
        function showMainMenu() {
            hideAllScreens();
            document.getElementById('mainMenuScreen').classList.add('active');
            updateChallengesButtonVisibility();
        }
        
        function showVSMenu() {
            hideAllScreens();
            document.getElementById('vsMenuScreen').classList.add('active');
            updateQueueStatus();
            updateRankingDisplay();
        }
        
        function showStatsMenu() {
            hideAllScreens();
            document.getElementById('statsMenuScreen').classList.add('active');
            updateStatsDisplay();
        }
        
        function updateRankingDisplay() {
            const tier = getRankTier(playerRanking.rating);
            const rankTierDisplay = document.getElementById('rankTierDisplay');
            const rankRatingDisplay = document.getElementById('rankRatingDisplay');
            
            if (rankTierDisplay) {
                rankTierDisplay.textContent = tier.name;
                rankTierDisplay.style.color = tier.color;
            }
            if (rankRatingDisplay) {
                rankRatingDisplay.textContent = `Rating: ${playerRanking.rating} | W: ${playerRanking.wins} L: ${playerRanking.losses}`;
            }
        }
        
        function updateStatsDisplay() {
            const statsDisplay = document.getElementById('statsDisplay');
            if (!statsDisplay) return;
            
            const tier = getRankTier(playerRanking.rating);
            const winRate = playerRanking.totalMatches > 0 
                ? ((playerRanking.wins / playerRanking.totalMatches) * 100).toFixed(1) 
                : '0.0';
            
            const avgSpikeScore = playerRanking.spikeDodge.totalPlayed > 0
                ? Math.round(playerRanking.spikeDodge.totalSpikesDodged / playerRanking.spikeDodge.totalPlayed)
                : 0;
            
            // Get other players' stats for comparison
            let otherPlayersStats = [];
            players.forEach((player, playerId) => {
                if (playerId !== localPlayerId && player.name) {
                    // Try to get their stats from localStorage (if we've stored them)
                    // For now, we'll just show their name and rating if available
                    otherPlayersStats.push({
                        name: player.name || `Player ${playerId.substring(0, 6)}`,
                        id: playerId
                    });
                }
            });
            
            statsDisplay.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <div style="font-size: 18px; font-weight: 600; color: ${tier.color}; margin-bottom: 8px; text-align: center;">${tier.name}</div>
                    <div style="font-size: 14px; color: #aaa; text-align: center;">Rating: <span style="color: #fff; font-weight: 600;">${playerRanking.rating}</span></div>
                </div>
                
                <div style="background: rgba(102, 126, 234, 0.1); padding: 12px; border-radius: 6px; margin-bottom: 15px; border: 1px solid rgba(102, 126, 234, 0.3);">
                    <div style="font-size: 14px; font-weight: 600; color: #667eea; margin-bottom: 10px;">VS Match Stats</div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                        <span style="color: #aaa; font-size: 11px;">Total Matches:</span>
                        <span style="color: #fff; font-weight: 600; font-size: 11px;">${playerRanking.totalMatches}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                        <span style="color: #aaa; font-size: 11px;">Wins:</span>
                        <span style="color: #00ff88; font-weight: 600; font-size: 11px;">${playerRanking.wins}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                        <span style="color: #aaa; font-size: 11px;">Losses:</span>
                        <span style="color: #ff4444; font-weight: 600; font-size: 11px;">${playerRanking.losses}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                        <span style="color: #aaa; font-size: 11px;">Draws:</span>
                        <span style="color: #ffaa00; font-weight: 600; font-size: 11px;">${playerRanking.draws}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                        <span style="color: #aaa; font-size: 11px;">Win Rate:</span>
                        <span style="color: #fff; font-weight: 600; font-size: 11px;">${winRate}%</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                        <span style="color: #aaa; font-size: 11px;">Current Streak:</span>
                        <span style="color: ${playerRanking.winStreak > 0 ? '#ffd700' : '#fff'}; font-weight: 600; font-size: 11px;">
                            ${playerRanking.winStreak > 0 ? ' ' : ''}${playerRanking.winStreak}
                        </span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #aaa; font-size: 11px;">Best Streak:</span>
                        <span style="color: #ffd700; font-weight: 600; font-size: 11px;"> ${playerRanking.bestWinStreak}</span>
                    </div>
                </div>
                
                <div style="background: rgba(255, 165, 0, 0.1); padding: 12px; border-radius: 6px; margin-bottom: 15px; border: 1px solid rgba(255, 165, 0, 0.3);">
                    <div style="font-size: 14px; font-weight: 600; color: #ffaa00; margin-bottom: 10px;">Spike Dodge Challenge</div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                        <span style="color: #aaa; font-size: 11px;">Best Score:</span>
                        <span style="color: #ffd700; font-weight: 600; font-size: 11px;">${playerRanking.spikeDodge.bestScore}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                        <span style="color: #aaa; font-size: 11px;">Times Played:</span>
                        <span style="color: #fff; font-weight: 600; font-size: 11px;">${playerRanking.spikeDodge.totalPlayed}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                        <span style="color: #aaa; font-size: 11px;">Total Spikes Dodged:</span>
                        <span style="color: #fff; font-weight: 600; font-size: 11px;">${playerRanking.spikeDodge.totalSpikesDodged}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #aaa; font-size: 11px;">Average Score:</span>
                        <span style="color: #fff; font-weight: 600; font-size: 11px;">${avgSpikeScore}</span>
                    </div>
                </div>
                
                ${otherPlayersStats.length > 0 ? `
                    <div style="background: rgba(100, 200, 255, 0.1); padding: 12px; border-radius: 6px; border: 1px solid rgba(100, 200, 255, 0.3);">
                        <div style="font-size: 14px; font-weight: 600; color: #64c8ff; margin-bottom: 10px;">Other Players in Game</div>
                        ${otherPlayersStats.map(p => `
                            <div style="display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 11px;">
                                <span style="color: #aaa;">${p.name}:</span>
                                <span style="color: #fff;">Connected</span>
                            </div>
                        `).join('')}
                        <div style="color: #888; font-size: 10px; margin-top: 8px; font-style: italic;">
                            Note: Rankings are stored locally. Each player has their own ranking.
                        </div>
                    </div>
                ` : `
                    <div style="background: rgba(100, 100, 100, 0.1); padding: 12px; border-radius: 6px; border: 1px solid rgba(100, 100, 100, 0.3);">
                        <div style="font-size: 12px; color: #888; text-align: center; font-style: italic;">
                            No other players connected. Rankings are stored locally on each device.
                        </div>
                    </div>
                `}
            `;
        }
        
        function showChallengesMenu() {
            hideAllScreens();
            document.getElementById('challengesMenuScreen').classList.add('active');
            // Update best score display
            const bestScoreEl = document.getElementById('spikeDodgeBestScoreDisplay');
            if (bestScoreEl) {
                bestScoreEl.textContent = playerRanking.spikeDodge.bestScore;
            }
        }
        
        function updateChallengesButtonVisibility() {
            const challengesButton = document.getElementById('challengesButton');
            if (challengesButton) {
                const isAlone = (!isHost && !roomId && players.size <= 1);
                const isHosting = isHost;
                challengesButton.style.display = (isAlone || isHosting) ? 'block' : 'none';
            }
        }
        
        // Matchmaking functions
        function joinQueue(mode) {
            if (inQueue) {
                cancelQueue();
            }
            
            queueMode = mode;
            inQueue = true;
            updateQueueStatus();
            
            // Create a matchmaking room ID based on the queue mode
            // This allows players in the same queue to find each other
            matchmakingRoomId = `matchmaking-${mode}-${Date.now()}`;
            
            // Try to connect to an existing matchmaking room first
            // If no room exists, become the host
            attemptMatchmakingConnection(mode);
            
            // Update UI
            document.getElementById('queue1v1Button').style.display = 'none';
            document.getElementById('queue2v2Button').style.display = 'none';
            document.getElementById('cancelQueueButton').style.display = 'block';
        }
        
        function attemptMatchmakingConnection(mode) {
            // Use a fixed room ID for matchmaking - first player becomes host, others connect
            const matchmakingRoomId = `matchmaking-${mode}`;
            
            // Try to become host first
            matchmakingPeer = new Peer(matchmakingRoomId, {
                secure: true
            });
            
            matchmakingPeer.on('open', (id) => {
                console.log('Matchmaking peer opened as host:', id);
                isMatchmakingHost = true;
                updateQueueStatus();
            });
            
            matchmakingPeer.on('connection', (conn) => {
                console.log('Player connected to matchmaking:', conn.peer);
                conn.on('open', () => {
                    matchmakingConnections.set(conn.peer, conn);
                    handleMatchmakingConnection(conn);
                });
                
                conn.on('error', (err) => {
                    console.error('Matchmaking connection error:', err);
                });
            });
            
            matchmakingPeer.on('error', (err) => {
                console.log('Could not become host, trying to connect as client...', err);
                // If we can't become host (room already exists), connect as client
                if (err.type === 'peer-unavailable' || err.type === 'unavailable-id') {
                    connectAsMatchmakingClient(mode);
                } else {
                    // Retry after delay
                    setTimeout(() => {
                        if (inQueue) {
                            attemptMatchmakingConnection(mode);
                        }
                    }, 2000);
                }
            });
        }
        
        function connectAsMatchmakingClient(mode) {
            const matchmakingRoomId = `matchmaking-${mode}`;
            
            // Create a new peer as client
            if (matchmakingPeer) {
                matchmakingPeer.destroy();
            }
            
            matchmakingPeer = new Peer({
                secure: true
            });
            
            matchmakingPeer.on('open', (myId) => {
                console.log('Matchmaking client peer opened:', myId);
                isMatchmakingHost = false;
                
                // Try to connect to the matchmaking room
                const conn = matchmakingPeer.connect(matchmakingRoomId);
                
                conn.on('open', () => {
                    console.log('Connected to matchmaking room as client');
                    matchmakingConnections.set(conn.peer, conn);
                    handleMatchmakingConnection(conn);
                });
                
                conn.on('error', (err) => {
                    console.error('Failed to connect to matchmaking room:', err);
                    // Retry connection
                    setTimeout(() => {
                        if (inQueue) {
                            connectAsMatchmakingClient(mode);
                        }
                    }, 2000);
                });
            });
            
            matchmakingPeer.on('error', (err) => {
                console.error('Matchmaking client peer error:', err);
                setTimeout(() => {
                    if (inQueue) {
                        connectAsMatchmakingClient(mode);
                    }
                }, 2000);
            });
        }
        
        function handleMatchmakingConnection(conn) {
            conn.on('data', (data) => {
                console.log('Matchmaking data received:', data);
                
                if (data.type === 'queue_request') {
                    // Another player is looking for a match
                    const requiredPlayers = queueMode === '1v1' ? 2 : 4;
                    const currentPlayers = matchmakingConnections.size + 1; // +1 for host
                    
                    if (currentPlayers >= requiredPlayers) {
                        // We have enough players, start the match
                        startMatchmakingMatch();
                    } else {
                        // Send queue status
                        conn.send({
                            type: 'queue_status',
                            currentPlayers: currentPlayers,
                            requiredPlayers: requiredPlayers
                        });
                    }
                } else if (data.type === 'queue_status') {
                    // Update queue status
                    updateQueueStatus();
                } else if (data.type === 'match_start') {
                    // Match is starting
                    startMatchmakingMatch();
                }
            });
            
            // Send queue request
            conn.send({
                type: 'queue_request',
                mode: queueMode,
                playerId: localPlayerId
            });
            
            // Check if we have enough players to start
            const requiredPlayers = queueMode === '1v1' ? 2 : 4;
            const currentPlayers = matchmakingConnections.size + 1; // +1 for self
            
            if (currentPlayers >= requiredPlayers) {
                // Broadcast match start to all connected players
                matchmakingConnections.forEach((c) => {
                    c.send({
                        type: 'match_start',
                        mode: queueMode
                    });
                });
                startMatchmakingMatch();
            }
        }
        
        function startMatchmakingMatch() {
            console.log('Starting matchmaking match!');
            
            // Clear matchmaking check interval
            if (matchmakingCheckInterval) {
                clearInterval(matchmakingCheckInterval);
                matchmakingCheckInterval = null;
            }
            
            // Close matchmaking connections and set up game connections
            const matchPlayers = Array.from(matchmakingConnections.keys());
            
            // Initialize teams
            initializeMatchTeams();
            
            // Convert matchmaking connections to game connections
            // For now, we'll use the existing multiplayer system
            // Set up the game as a hosted match
            roomId = `match-${Date.now()}`;
            isHost = isMatchmakingHost;
            
            if (isMatchmakingHost) {
                // Host creates the game room
                localPlayerId = roomId;
                
                // Create game peer
                if (peer) {
                    peer.destroy();
                }
                
                peer = new Peer(roomId, {
                    secure: true
                });
                
                peer.on('open', (id) => {
                    console.log('Game host opened:', id);
                    // Players will connect via matchmaking connections
                    matchmakingConnections.forEach((conn, peerId) => {
                        // Set up game connection
                        setupConnection(conn);
                    });
                });
            } else {
                // Client connects to host
                const hostConn = Array.from(matchmakingConnections.values())[0];
                if (hostConn) {
                    setupConnection(hostConn);
                }
            }
            
            // Hide queue UI and show game
            inQueue = false;
            updateQueueStatus();
            document.getElementById('queue1v1Button').style.display = 'block';
            document.getElementById('queue2v2Button').style.display = 'block';
            document.getElementById('cancelQueueButton').style.display = 'none';
            
            // Close matchmaking menu and show game
            hideAllScreens();
            document.getElementById('gameScreen').classList.add('active');
            updatePlayerList();
        }
        
        function cancelQueue() {
            inQueue = false;
            queueMode = null;
            isMatchmakingHost = false;
            matchmakingRoomId = null;
            
            if (matchmakingCheckInterval) {
                clearInterval(matchmakingCheckInterval);
                matchmakingCheckInterval = null;
            }
            
            if (matchmakingPeer) {
                matchmakingPeer.destroy();
                matchmakingPeer = null;
            }
            matchmakingConnections.clear();
            
            updateQueueStatus();
            document.getElementById('queue1v1Button').style.display = 'block';
            document.getElementById('queue2v2Button').style.display = 'block';
            document.getElementById('cancelQueueButton').style.display = 'none';
        }
        
        function updateQueueStatus() {
            const statusEl = document.getElementById('queueStatus');
            if (statusEl) {
                if (inQueue) {
                    statusEl.textContent = `Searching for ${queueMode} match...`;
                    statusEl.style.color = '#667eea';
                } else {
                    statusEl.textContent = 'Not in queue';
                    statusEl.style.color = '#aaa';
                }
            }
        }
        
        
        // Challenges/Game Modes
        function startSpikeDodge() {
            // Reset game state
            currentGameMode = 'spike_dodge';
            spikes = [];
            spikeSpawnTimer = 0;
            spikeSpeed = 2;
            spikeSpawnRate = 2000;
            gameStartTime = Date.now();
            spikesDodged = 0;
            playerDead = false;
            deathParticles = [];
            
            // Reset player position to center
            if (localPlayer) {
                localPlayer.x = canvas.width / 2;
                localPlayer.y = canvas.height / 2;
                localPlayer.vx = 0;
                localPlayer.vy = 0;
                localPlayer.visible = true;
                localPlayer.dead = false;
                localPlayer.health = 100;
                localPlayer.maxHealth = 100;
            }
            
            // Reset health
            if (healthBar) {
                healthBar.setHealth(100);
            }
            
            // Hide menu
            resumeGame();
        }
        
        function updateSpikeDodge(deltaTime) {
            if (currentGameMode !== 'spike_dodge' || playerDead) return;
            
            const elapsed = (Date.now() - gameStartTime) / 1000; // seconds
            
            // Increase difficulty over time
            spikeSpeed = 2 + elapsed * 0.5;
            spikeSpawnRate = Math.max(500, 2000 - elapsed * 50);
            
            // Spawn spikes
            spikeSpawnTimer += deltaTime;
            if (spikeSpawnTimer >= spikeSpawnRate) {
                spikeSpawnTimer = 0;
                spawnSpike();
            }
            
            // Update spikes
            for (let i = spikes.length - 1; i >= 0; i--) {
                const spike = spikes[i];
                
                // Store current position in trail for shadow effect
                spike.trail.push({ x: spike.x, y: spike.y, alpha: 1.0 });
                
                // Limit trail length and fade out older positions
                if (spike.trail.length > 8) {
                    spike.trail.shift();
                }
                spike.trail.forEach(t => {
                    t.alpha *= 0.85; // Fade out trail
                });
                
                spike.y += spikeSpeed;
                
                // Remove if off screen
                if (spike.y > canvas.height + 20) {
                    spikes.splice(i, 1);
                    spikesDodged++; // Count dodged spikes
                    continue;
                }
                
                // Check collision with player (only if player is alive and visible)
                if (localPlayer && !playerDead && localPlayer.visible !== false) {
                    const dx = spike.x - localPlayer.x;
                    const dy = spike.y - localPlayer.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const collisionDist = spike.radius + localPlayer.baseRadius;
                    
                    if (dist < collisionDist) {
                        // Player hit!
                        if (healthBar) {
                            healthBar.takeDamage(20);
                        }
                        // Remove spike
                        spikes.splice(i, 1);
                    }
                }
            }
            
            // Update death particles
            updateDeathParticles();
        }
        
        function spawnSpike() {
            const spike = {
                x: Math.random() * canvas.width,
                y: -20,
                radius: 8 + Math.random() * 12,
                color: `hsl(${Math.random() * 60 + 0}, 70%, 50%)`, // Red to orange
                trail: [] // Store previous positions for shadow effect
            };
            spikes.push(spike);
        }
        
        function drawSpikes() {
            if (currentGameMode !== 'spike_dodge') return;
            
            spikes.forEach(spike => {
                const size = spike.radius;
                
                // Draw shadow trail (after shadow effect)
                if (spike.trail && spike.trail.length > 1) {
                    for (let i = spike.trail.length - 1; i >= 0; i--) {
                        const trailPos = spike.trail[i];
                        if (trailPos.alpha > 0.05) {
                            ctx.save();
                            ctx.translate(trailPos.x, trailPos.y);
                            ctx.globalAlpha = trailPos.alpha * 0.4; // Make shadow more transparent
                            
                            // Draw shadow spike (slightly larger and darker)
                            const shadowSize = size * (1 + (1 - trailPos.alpha) * 0.3); // Slightly larger as it fades
                            const shadowColor = spike.color.replace('50%)', `${Math.max(10, 50 * trailPos.alpha)}%)`);
                            
                            ctx.fillStyle = shadowColor;
                            ctx.beginPath();
                            ctx.moveTo(0, shadowSize);
                            ctx.lineTo(-shadowSize * 0.6, -shadowSize * 0.3);
                            ctx.lineTo(shadowSize * 0.6, -shadowSize * 0.3);
                            ctx.closePath();
                            ctx.fill();
                            
                            // Add blur effect to shadow
                            ctx.shadowBlur = 10 * trailPos.alpha;
                            ctx.shadowColor = shadowColor;
                            ctx.strokeStyle = shadowColor;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(0, shadowSize);
                            ctx.lineTo(-shadowSize * 0.6, -shadowSize * 0.3);
                            ctx.lineTo(shadowSize * 0.6, -shadowSize * 0.3);
                            ctx.closePath();
                            ctx.stroke();
                            
                            ctx.restore();
                        }
                    }
                }
                
                // Draw main spike
                ctx.save();
                ctx.translate(spike.x, spike.y);
                
                // Draw 3D spike pointing downward
                // Main triangle (pointing down)
                ctx.fillStyle = spike.color;
                ctx.beginPath();
                ctx.moveTo(0, size); // Bottom point
                ctx.lineTo(-size * 0.6, -size * 0.3); // Top left
                ctx.lineTo(size * 0.6, -size * 0.3); // Top right
                ctx.closePath();
                ctx.fill();
                
                // Add darker side for 3D effect
                const darkerColor = spike.color.replace('50%)', '35%)');
                ctx.fillStyle = darkerColor;
                ctx.beginPath();
                ctx.moveTo(0, size);
                ctx.lineTo(-size * 0.6, -size * 0.3);
                ctx.lineTo(-size * 0.4, -size * 0.1);
                ctx.closePath();
                ctx.fill();
                
                // Highlight for 3D effect
                const lighterColor = spike.color.replace('50%)', '65%)');
                ctx.fillStyle = lighterColor;
                ctx.beginPath();
                ctx.moveTo(0, size);
                ctx.lineTo(size * 0.6, -size * 0.3);
                ctx.lineTo(size * 0.4, -size * 0.1);
                ctx.closePath();
                ctx.fill();
                
                // Add glow
                ctx.shadowBlur = 15;
                ctx.shadowColor = spike.color;
                ctx.strokeStyle = spike.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, size);
                ctx.lineTo(-size * 0.6, -size * 0.3);
                ctx.lineTo(size * 0.6, -size * 0.3);
                ctx.closePath();
                ctx.stroke();
                
                ctx.restore();
            });
        }
        
        function triggerDeathEffect() {
            if (!localPlayer) return;
            
            // Create death particles
            for (let i = 0; i < 30; i++) {
                const angle = (Math.PI * 2 * i) / 30;
                const speed = 2 + Math.random() * 3;
                deathParticles.push({
                    x: localPlayer.x,
                    y: localPlayer.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.03,
                    size: 3 + Math.random() * 5,
                    color: localPlayer.color || 'hsl(200, 70%, 60%)'
                });
            }
            
            // Hide player
            if (localPlayer) {
                localPlayer.visible = false;
            }
            
            // Show death screen if in challenge mode
            if (currentGameMode === 'spike_dodge') {
                setTimeout(() => {
                    showDeathScreen();
                }, 1000);
            }
        }
        
        function updateDeathParticles() {
            for (let i = deathParticles.length - 1; i >= 0; i--) {
                const particle = deathParticles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= particle.decay;
                particle.vx *= 0.98;
                particle.vy *= 0.98;
                
                if (particle.life <= 0) {
                    deathParticles.splice(i, 1);
                }
            }
        }
        
        function drawDeathParticles() {
            deathParticles.forEach(particle => {
                ctx.save();
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }
        
        function showDeathScreen() {
            // Update spike dodge stats
            const wasNewRecord = spikesDodged > playerRanking.spikeDodge.bestScore;
            if (wasNewRecord) {
                playerRanking.spikeDodge.bestScore = spikesDodged;
            }
            playerRanking.spikeDodge.totalPlayed++;
            playerRanking.spikeDodge.totalSpikesDodged += spikesDodged;
            playerRanking.spikeDodge.averageScore = Math.round(playerRanking.spikeDodge.totalSpikesDodged / playerRanking.spikeDodge.totalPlayed);
            saveRanking();
            
            // Create death screen overlay
            const deathScreen = document.getElementById('deathScreen');
            if (deathScreen) {
                deathScreen.style.display = 'block';
                document.getElementById('spikesDodgedCount').textContent = spikesDodged;
                const bestScoreEl = document.getElementById('bestScoreDisplay');
                if (bestScoreEl) {
                    bestScoreEl.textContent = playerRanking.spikeDodge.bestScore;
                }
                const newRecordEl = document.getElementById('newRecordDisplay');
                if (newRecordEl) {
                    newRecordEl.style.display = wasNewRecord ? 'block' : 'none';
                }
            } else {
                // Create death screen if it doesn't exist
                const screen = document.createElement('div');
                screen.id = 'deathScreen';
                screen.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                    color: white;
                    font-family: system-ui, -apple-system, sans-serif;
                `;
                screen.innerHTML = `
                    <h2 style="font-size: 32px; margin-bottom: 20px;">Game Over!</h2>
                    <div id="newRecordDisplay" style="font-size: 20px; color: #ffd700; margin-bottom: 15px; font-weight: 600; text-shadow: 0 0 10px rgba(255, 215, 0, 0.8); ${wasNewRecord ? '' : 'display: none;'}">
                         NEW RECORD! 
                    </div>
                    <p style="font-size: 18px; margin-bottom: 10px;">Spikes Dodged: <span id="spikesDodgedCount" style="color: #667eea; font-weight: 600;">${spikesDodged}</span></p>
                    <p style="font-size: 14px; color: #aaa; margin-bottom: 30px;">Best Score: <span id="bestScoreDisplay" style="color: #ffd700; font-weight: 600;">${playerRanking.spikeDodge.bestScore}</span></p>
                    <button onclick="retrySpikeDodge()" style="
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                        border: none;
                        padding: 15px 30px;
                        border-radius: 8px;
                        font-size: 16px;
                        font-weight: 600;
                        cursor: pointer;
                        margin: 10px;
                    ">Try Again</button>
                    <button onclick="exitSpikeDodge()" style="
                        background: rgba(100, 100, 100, 0.5);
                        color: white;
                        border: none;
                        padding: 15px 30px;
                        border-radius: 8px;
                        font-size: 16px;
                        font-weight: 600;
                        cursor: pointer;
                        margin: 10px;
                    ">Go Back to Lobby</button>
                `;
                document.body.appendChild(screen);
            }
        }
        
        function retrySpikeDodge() {
            // Hide death screen
            const deathScreen = document.getElementById('deathScreen');
            if (deathScreen) {
                deathScreen.style.display = 'none';
            }
            
            // IMPORTANT: Reset player dead state FIRST before anything else
            playerDead = false;
            
            // Reset all game state before restarting
            deathParticles = [];
            spikesDodged = 0;
            spikes = [];
            spikeSpawnTimer = 0;
            
            // Reset player state completely
            if (localPlayer) {
                localPlayer.visible = true;
                localPlayer.dead = false;
                localPlayer.health = 100;
                localPlayer.maxHealth = 100;
                localPlayer.x = canvas.width / 2;
                localPlayer.y = canvas.height / 2;
                localPlayer.vx = 0;
                localPlayer.vy = 0;
            }
            
            // Reset health bar
            if (healthBar) {
                healthBar.setHealth(100, false); // Set without animation for instant reset
            }
            
            // Restart the game mode - ensure it's set properly
            currentGameMode = 'spike_dodge';
            spikeSpeed = 2;
            spikeSpawnRate = 2000;
            gameStartTime = Date.now();
            
            // Close menu if open
            const menuWidget = document.getElementById('menuWidget');
            if (menuWidget && menuWidget.classList.contains('expanded')) {
                menuWidget.classList.remove('expanded');
                menuWidget.classList.add('collapsed');
                menuVisible = false;
            }
            
            // Force a small delay to ensure state is fully reset before game continues
            // This ensures playerDead check in updateSpikeDodge passes
            setTimeout(() => {
                // Double-check playerDead is false
                playerDead = false;
                if (localPlayer) {
                    localPlayer.dead = false;
                    localPlayer.visible = true;
                }
            }, 10);
        }
        
        function exitSpikeDodge() {
            // Hide death screen
            const deathScreen = document.getElementById('deathScreen');
            if (deathScreen) {
                deathScreen.style.display = 'none';
            }
            
            // Exit game mode
            currentGameMode = null;
            spikes = [];
            playerDead = false;
            deathParticles = [];
            spikesDodged = 0;
            
            // Reset player
            if (localPlayer) {
                localPlayer.visible = true;
                localPlayer.x = canvas.width / 2;
                localPlayer.y = canvas.height / 2;
                localPlayer.vx = 0;
                localPlayer.vy = 0;
            }
            
            // Reset health
            if (healthBar) {
                healthBar.setHealth(100);
            }
            
            // Go back to lobby
            goBackToLobby();
        }
        
        function goBackToLobby() {
            // If in a hosted game, all players stay in the game
            if (isHost || roomId) {
                // Just close the menu and return to game
                const menuWidget = document.getElementById('menuWidget');
                if (menuWidget) {
                    menuWidget.classList.remove('expanded');
                    menuWidget.classList.add('collapsed');
                    menuVisible = false;
                }
            } else {
                // If alone, return to main menu
                const menuWidget = document.getElementById('menuWidget');
                if (menuWidget) {
                    menuWidget.classList.remove('expanded');
                    menuWidget.classList.add('collapsed');
                    menuVisible = false;
                }
                showMainMenu();
            }
        }
        
        function checkMatchVictory() {
            // Check if all players on one team are dead
            let team1Alive = 0;
            let team2Alive = 0;
            let winnerName = null;
            let winnerPlayer = null;
            let isLocalPlayerWinner = false;
            
            players.forEach((player, playerId) => {
                const team = playerTeams.get(playerId);
                if (!player.dead && player.health > 0) {
                    if (team === 1) {
                        team1Alive++;
                    } else if (team === 2) {
                        team2Alive++;
                    }
                }
            });
            
            // Determine winner
            if (team1Alive === 0 && team2Alive > 0) {
                // Team 2 wins - find first alive player from team 2
                players.forEach((player, playerId) => {
                    if (playerTeams.get(playerId) === 2 && !player.dead && player.health > 0 && !winnerPlayer) {
                        winnerPlayer = player;
                        if (playerId === localPlayerId) {
                            isLocalPlayerWinner = true;
                        }
                    }
                });
                if (winnerPlayer) {
                    winnerName = winnerPlayer.name || 'Team 2 Player';
                }
            } else if (team2Alive === 0 && team1Alive > 0) {
                // Team 1 wins - find first alive player from team 1
                players.forEach((player, playerId) => {
                    if (playerTeams.get(playerId) === 1 && !player.dead && player.health > 0 && !winnerPlayer) {
                        winnerPlayer = player;
                        if (playerId === localPlayerId) {
                            isLocalPlayerWinner = true;
                        }
                    }
                });
                if (winnerPlayer) {
                    winnerName = winnerPlayer.name || 'Team 1 Player';
                }
            }
            
            if (winnerName) {
                // Update ranking for local player
                if (matchInProgress && (queueMode === '1v1' || queueMode === '2v2')) {
                    const oldRating = playerRanking.rating;
                    if (isLocalPlayerWinner) {
                        updateRanking('win');
                    } else {
                        // Check if local player is dead
                        const localPlayerDead = localPlayer && (localPlayer.dead || localPlayer.health <= 0);
                        if (localPlayerDead) {
                            updateRanking('loss');
                        }
                    }
                }
                showVictoryScreen(winnerName, isLocalPlayerWinner);
            }
        }
        
        function showVictoryScreen(winnerName, isLocalPlayerWinner = false) {
            // Create or show victory screen
            const victoryScreen = document.getElementById('victoryScreen');
            const tier = getRankTier(playerRanking.rating);
            const ratingChange = isLocalPlayerWinner ? '+' : '-';
            
            if (victoryScreen) {
                victoryScreen.style.display = 'flex';
                document.getElementById('winnerName').textContent = winnerName;
                // Update ranking display if it exists
                const rankingDisplay = document.getElementById('rankingDisplay');
                if (rankingDisplay) {
                    rankingDisplay.innerHTML = `
                        <div style="margin: 20px 0; padding: 15px; background: rgba(102, 126, 234, 0.1); border-radius: 8px; border: 1px solid rgba(102, 126, 234, 0.3);">
                            <div style="font-size: 18px; margin-bottom: 10px; color: ${tier.color}; font-weight: 600;">${tier.name}</div>
                            <div style="font-size: 14px; color: #aaa;">Rating: ${playerRanking.rating} ${ratingChange}</div>
                            <div style="font-size: 12px; color: #888; margin-top: 5px;">W: ${playerRanking.wins} | L: ${playerRanking.losses} | D: ${playerRanking.draws}</div>
                        </div>
                    `;
                }
            } else {
                // Create victory screen if it doesn't exist
                const screen = document.createElement('div');
                screen.id = 'victoryScreen';
                screen.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.9);
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    z-index: 10001;
                    color: white;
                    font-family: system-ui, -apple-system, sans-serif;
                `;
                screen.innerHTML = `
                    <h2 style="font-size: 48px; margin-bottom: 20px; color: #667eea; text-shadow: 0 0 20px rgba(102, 126, 234, 0.8);">${isLocalPlayerWinner ? 'Victory!' : 'Defeat'}</h2>
                    <p style="font-size: 24px; margin-bottom: 20px;"><span id="winnerName">${winnerName}</span> ${isLocalPlayerWinner ? 'Won!' : 'Won the match!'}</p>
                    <div id="rankingDisplay" style="margin: 20px 0; padding: 15px; background: rgba(102, 126, 234, 0.1); border-radius: 8px; border: 1px solid rgba(102, 126, 234, 0.3); text-align: center;">
                        <div style="font-size: 18px; margin-bottom: 10px; color: ${tier.color}; font-weight: 600;">${tier.name}</div>
                        <div style="font-size: 14px; color: #aaa;">Rating: ${playerRanking.rating}</div>
                        <div style="font-size: 12px; color: #888; margin-top: 5px;">W: ${playerRanking.wins} | L: ${playerRanking.losses} | D: ${playerRanking.draws}</div>
                        ${playerRanking.winStreak > 0 ? `<div style="font-size: 12px; color: #ffd700; margin-top: 5px;"> Win Streak: ${playerRanking.winStreak}</div>` : ''}
                    </div>
                    <button onclick="goBackToLobbyFromVictory()" style="
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                        border: none;
                        padding: 15px 30px;
                        border-radius: 8px;
                        font-size: 16px;
                        font-weight: 600;
                        cursor: pointer;
                        margin: 10px;
                    ">Go Back to Lobby</button>
                    <button onclick="searchNewGame()" style="
                        background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
                        color: white;
                        border: none;
                        padding: 15px 30px;
                        border-radius: 8px;
                        font-size: 16px;
                        font-weight: 600;
                        cursor: pointer;
                        margin: 10px;
                    ">Search for a New Game</button>
                `;
                document.body.appendChild(screen);
            }
        }
        
        function goBackToLobbyFromVictory() {
            // Hide victory screen
            const victoryScreen = document.getElementById('victoryScreen');
            if (victoryScreen) {
                victoryScreen.style.display = 'none';
            }
            
            // Reset match state
            matchInProgress = false;
            playerTeams.clear();
            team1Players = [];
            team2Players = [];
            
            // Reset all players
            players.forEach((player, playerId) => {
                player.health = 100;
                player.visible = true;
                player.dead = false;
                if (healthBar && playerId === localPlayerId) {
                    healthBar.setHealth(100);
                }
            });
            
            playerDead = false;
            
            // Go back to lobby
            goBackToLobby();
        }
        
        function searchNewGame() {
            // Hide victory screen
            const victoryScreen = document.getElementById('victoryScreen');
            if (victoryScreen) {
                victoryScreen.style.display = 'none';
            }
            
            // Reset match state
            matchInProgress = false;
            playerTeams.clear();
            team1Players = [];
            team2Players = [];
            
            // Reset all players
            players.forEach((player, playerId) => {
                player.health = 100;
                player.visible = true;
                player.dead = false;
                if (healthBar && playerId === localPlayerId) {
                    healthBar.setHealth(100);
                }
            });
            
            playerDead = false;
            
            // Show VS menu to search again
            showVSMenu();
        }
        
        // Initialize teams when match starts (placeholder - would be set by matchmaking)
        function initializeMatchTeams() {
            if (queueMode === '1v1') {
                // Assign teams for 1v1
                let team = 1;
                players.forEach((player, playerId) => {
                    playerTeams.set(playerId, team);
                    if (team === 1) {
                        team1Players.push(playerId);
                    } else {
                        team2Players.push(playerId);
                    }
                    team = 2;
                });
            } else if (queueMode === '2v2') {
                // Assign teams for 2v2
                let team = 1;
                players.forEach((player, playerId) => {
                    playerTeams.set(playerId, team);
                    if (team === 1) {
                        team1Players.push(playerId);
                    } else {
                        team2Players.push(playerId);
                    }
                    // Alternate teams every 2 players
                    if (team1Players.length === 2) {
                        team = 2;
                    }
                });
            }
            matchInProgress = true;
        }
        
        function showMultiplayerMenu() {
            hideAllScreens();
            // If already in a game, show the game screen instead
            if (isHost || roomId) {
                // Update room ID display
                const roomIdDisplay = document.getElementById('roomIdDisplay');
                if (roomIdDisplay && roomId) {
                    roomIdDisplay.textContent = 'Room ID: ' + roomId;
                }
                document.getElementById('gameScreen').classList.add('active');
                updatePlayerList();
            } else {
                document.getElementById('multiplayerMenuScreen').classList.add('active');
            }
        }
        
        function showJoinScreen() {
            hideAllScreens();
            document.getElementById('joinGameScreen').classList.add('active');
        }
        
        function showControlsMenu() {
            hideAllScreens();
            document.getElementById('controlsScreen').classList.add('active');
        }
        
        function showCustomizeMenu() {
            hideAllScreens();
            document.getElementById('customizeScreen').classList.add('active');
            // Load saved name
            const nameInput = document.getElementById('playerNameInput');
            if (nameInput && localPlayer && localPlayer.name) {
                nameInput.value = localPlayer.name;
            }
            // Update image preview
            updateImagePreview();
        }
        
        function updateImagePreview() {
            const preview = document.getElementById('imagePreview');
            const previewImg = document.getElementById('previewImg');
            if (localPlayer && localPlayer.image) {
                previewImg.src = localPlayer.image;
                preview.style.display = 'block';
            } else {
                preview.style.display = 'none';
            }
        }
        
        function clearImage() {
            if (localPlayer) {
                localPlayer.image = null;
                updateImagePreview();
                // Save to localStorage
                try {
                    localStorage.removeItem('playerImage');
                } catch (e) {
                    console.warn('Could not remove image from localStorage:', e);
                }
            }
        }
        
        function hideAllScreens() {
            const screens = document.querySelectorAll('.menu-screen');
            screens.forEach(screen => screen.classList.remove('active'));
        }
        
        function resumeGame() {
            toggleMenu();
        }
        
        function goToShangkoStudio() {
            // Navigate to ShangkoStudio homepage in the current tab
            window.location.href = 'https://www.shangkostudio.com/';
        }
        
        // Color picker functionality
        function hexToHsl(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }
            
            return `hsl(${Math.round(h * 360)}, ${Math.round(s * 100)}%, ${Math.round(l * 100)}%)`;
        }
        
        function updatePlayerColor(color) {
            if (localPlayer) {
                localPlayer.color = hexToHsl(color);
                // Also update in players map
                if (localPlayerId) {
                    players.set(localPlayerId, localPlayer);
                }
                // Save color to localStorage
                try {
                    localStorage.setItem('playerColor', color);
                } catch (e) {
                    console.warn('Could not save color to localStorage:', e);
                }
                // Immediately broadcast color change to other players
                if (connections.size > 0) {
                    const colorState = {
                        type: 'state_medium',
                        id: localPlayerId,
                        scaleX: localPlayer.scaleX,
                        scaleY: localPlayer.scaleY,
                        rotation: localPlayer.rotation,
                        isDashing: localPlayer.isDashing,
                        dashCooldown: localPlayer.dashCooldown,
                        color: localPlayer.color,
                        name: localPlayer.name
                    };
                    broadcastToAll(colorState);
                }
            }
        }
        
        function loadSavedColor() {
            try {
                const savedColor = localStorage.getItem('playerColor');
                if (savedColor) {
                    const colorPicker = document.getElementById('colorPicker');
                    if (colorPicker) {
                        colorPicker.value = savedColor;
                        if (localPlayer) {
                            localPlayer.color = hexToHsl(savedColor);
                            if (localPlayerId) {
                                players.set(localPlayerId, localPlayer);
                            }
                        }
                    }
                    return savedColor;
                }
            } catch (e) {
                console.warn('Could not load color from localStorage:', e);
            }
            return null;
        }
        
        window.addEventListener('keydown', (e) => {
            // Toggle menu with ESC or P
            if (e.key === 'Escape' || e.key.toLowerCase() === 'p') {
                e.preventDefault();
                toggleMenu();
                return;
            }
            
            // Always process game input - menu doesn't block keyboard
            keys[e.key.toLowerCase()] = true;
            if (e.key === ' ' && localPlayer && localPlayer.dashCooldown <= 0) {
                localPlayer.isDashing = true;
                localPlayer.dashCooldown = 30; // frames
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });
        
        canvas.addEventListener('mousedown', () => {
            mouseDown = true;
            
            // Double-click detection for dash
            const currentTime = Date.now();
            const timeSinceLastClick = currentTime - lastClickTime;
            
            if (timeSinceLastClick < DOUBLE_CLICK_DELAY && localPlayer && localPlayer.dashCooldown <= 0) {
                // Double-click detected - trigger dash
                localPlayer.isDashing = true;
                localPlayer.dashCooldown = 30; // frames
                lastClickTime = 0; // Reset to prevent triple-click from triggering again
            } else {
                lastClickTime = currentTime;
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
        });
        
        // Collision detection and resolution between players
        function resolvePlayerCollisions(player1, player2) {
            const dx = player2.x - player1.x;
            const dy = player2.y - player1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDistance = player1.baseRadius + player2.baseRadius;
            
            if (distance < minDistance && distance > 0) {
                // Prevent multiple damage from same collision (cooldown of 0.5 seconds)
                const now = Date.now();
                const collisionCooldown = 500; // 500ms cooldown
                
                // Calculate overlap
                const overlap = minDistance - distance;
                const separationX = (dx / distance) * overlap * 0.5;
                const separationY = (dy / distance) * overlap * 0.5;
                
                // Store velocities before collision to calculate recoil
                const player1VelBefore = Math.sqrt(player1.vx * player1.vx + player1.vy * player1.vy);
                const player2VelBefore = Math.sqrt(player2.vx * player2.vx + player2.vy * player2.vy);
                
                // Push players apart
                player1.x -= separationX;
                player1.y -= separationY;
                player2.x += separationX;
                player2.y += separationY;
                
                // Apply collision response (bounce effect)
                const normalX = dx / distance;
                const normalY = dy / distance;
                const relativeVx = player2.vx - player1.vx;
                const relativeVy = player2.vy - player1.vy;
                const relativeSpeed = relativeVx * normalX + relativeVy * normalY;
                
                // Only apply bounce if players are moving towards each other
                if (relativeSpeed < 0) {
                    const bounceStrength = 0.3; // How much velocity is transferred
                    const impulse = relativeSpeed * bounceStrength;
                    
                    const player1VxBefore = player1.vx;
                    const player1VyBefore = player1.vy;
                    const player2VxBefore = player2.vx;
                    const player2VyBefore = player2.vy;
                    
                    player1.vx += impulse * normalX;
                    player1.vy += impulse * normalY;
                    player2.vx -= impulse * normalX;
                    player2.vy -= impulse * normalY;
                    
                    // Calculate recoil (change in velocity magnitude)
                    const player1VelAfter = Math.sqrt(player1.vx * player1.vx + player1.vy * player1.vy);
                    const player2VelAfter = Math.sqrt(player2.vx * player2.vx + player2.vy * player2.vy);
                    
                    const player1Recoil = Math.abs(player1VelAfter - player1VelBefore);
                    const player2Recoil = Math.abs(player2VelAfter - player2VelBefore);
                    
                    // Apply damage to player with more recoil (only if cooldown has passed)
                    if (now - player1.lastCollisionTime > collisionCooldown && 
                        now - player2.lastCollisionTime > collisionCooldown) {
                        
                        if (player1Recoil > player2Recoil) {
                            // Player 1 takes damage
                            player1.health = Math.max(0, player1.health - 10);
                            player1.lastCollisionTime = now;
                            
                            // Check for death
                            if (player1.health <= 0 && !player1.dead) {
                                player1.dead = true;
                                player1.visible = false;
                            }
                            
                            // Update health bar if it's the local player
                            if (player1.id === localPlayerId && healthBar) {
                                healthBar.setHealth(player1.health);
                            }
                            
                            // Check for match victory
                            if (matchInProgress && (queueMode === '1v1' || queueMode === '2v2')) {
                                setTimeout(() => checkMatchVictory(), 500);
                            }
                        } else if (player2Recoil > player1Recoil) {
                            // Player 2 takes damage
                            player2.health = Math.max(0, player2.health - 10);
                            player2.lastCollisionTime = now;
                            
                            // Check for death
                            if (player2.health <= 0 && !player2.dead) {
                                player2.dead = true;
                                player2.visible = false;
                            }
                            
                            // Update health bar if it's the local player
                            if (player2.id === localPlayerId && healthBar) {
                                healthBar.setHealth(player2.health);
                            }
                            
                            // Check for match victory
                            if (matchInProgress && (queueMode === '1v1' || queueMode === '2v2')) {
                                setTimeout(() => checkMatchVictory(), 500);
                            }
                        }
                    }
                }
            }
        }
        
        function updatePlayer() {
            if (!localPlayer) return;
            
            const moveSpeed = DEFAULT_MOVE_SPEED;
            const dashMult = DEFAULT_DASH_MULT;
            const speed = localPlayer.isDashing ? moveSpeed * dashMult : moveSpeed;
            
            // Input handling
            let inputX = 0;
            let inputY = 0;
            
            if (keys['w'] || keys['arrowup']) inputY -= 1;
            if (keys['s'] || keys['arrowdown']) inputY += 1;
            if (keys['a'] || keys['arrowleft']) inputX -= 1;
            if (keys['d'] || keys['arrowright']) inputX += 1;
            
            // Mouse movement
            if (mouseDown) {
                const dx = mouseX - localPlayer.x;
                const dy = mouseY - localPlayer.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 10) {
                    inputX = dx / dist;
                    inputY = dy / dist;
                }
            }
            
            // Normalize diagonal movement
            if (inputX !== 0 && inputY !== 0) {
                const mag = Math.sqrt(inputX * inputX + inputY * inputY);
                inputX /= mag;
                inputY /= mag;
            }
            
            // Apply movement
            localPlayer.vx += inputX * speed * 0.3;
            localPlayer.vy += inputY * speed * 0.3;
            
            // Friction
            localPlayer.vx *= 0.9;
            localPlayer.vy *= 0.9;
            
            // Update position
            localPlayer.x += localPlayer.vx;
            localPlayer.y += localPlayer.vy;
            
            // Boundary collision with bounce
            const radius = localPlayer.baseRadius;
            const bounceDamping = 0.8; // Energy retained after bounce (0.8 = 80%)
            
            // Left wall
            if (localPlayer.x - radius < 0) {
                localPlayer.x = radius;
                localPlayer.vx = Math.abs(localPlayer.vx) * bounceDamping; // Bounce right
            }
            // Right wall
            if (localPlayer.x + radius > canvas.width) {
                localPlayer.x = canvas.width - radius;
                localPlayer.vx = -Math.abs(localPlayer.vx) * bounceDamping; // Bounce left
            }
            // Top wall
            if (localPlayer.y - radius < 0) {
                localPlayer.y = radius;
                localPlayer.vy = Math.abs(localPlayer.vy) * bounceDamping; // Bounce down
            }
            // Bottom wall
            if (localPlayer.y + radius > canvas.height) {
                localPlayer.y = canvas.height - radius;
                localPlayer.vy = -Math.abs(localPlayer.vy) * bounceDamping; // Bounce up
            }
            
            // Check collisions with other players
            players.forEach((otherPlayer, otherId) => {
                if (otherId !== localPlayerId && otherPlayer) {
                    resolvePlayerCollisions(localPlayer, otherPlayer);
                }
            });
            
            // Calculate squash and stretch
            const velocity = Math.sqrt(localPlayer.vx * localPlayer.vx + localPlayer.vy * localPlayer.vy);
            const maxVelocity = speed * 2;
            const velocityRatio = Math.min(velocity / maxVelocity, 1);
            
            // Stretch intensity: 1 for normal movement, 2 when dashing
            const stretchIntensity = localPlayer.isDashing ? 2 : 1;
            const squashIntensity = DEFAULT_SQUASH_INTENSITY;
            
            if (velocity > 0.5) {
                // Stretch in direction of movement
                const angle = Math.atan2(localPlayer.vy, localPlayer.vx);
                localPlayer.rotation = angle;
                
                // More velocity = more stretch
                localPlayer.targetScaleX = 1 + (stretchIntensity - 1) * velocityRatio;
                localPlayer.targetScaleY = 1 - (1 - squashIntensity) * velocityRatio;
            } else {
                // Return to normal when idle
                localPlayer.targetScaleX = 1;
                localPlayer.targetScaleY = 1;
                
                // Idle wobble
                if (DEFAULT_WOBBLE_ON_IDLE) {
                    const wobble = Math.sin(Date.now() * 0.003) * 0.05;
                    localPlayer.targetScaleX = 1 + wobble;
                    localPlayer.targetScaleY = 1 - wobble;
                }
            }
            
            // Smooth interpolation
            const deformSpeed = DEFAULT_DEFORM_SPEED;
            localPlayer.scaleX += (localPlayer.targetScaleX - localPlayer.scaleX) * deformSpeed;
            localPlayer.scaleY += (localPlayer.targetScaleY - localPlayer.scaleY) * deformSpeed;
            
            // Update dash and trail
            if (localPlayer.dashCooldown > 0) localPlayer.dashCooldown--;
            if (localPlayer.isDashing && localPlayer.dashCooldown <= 0) {
                localPlayer.isDashing = false;
            }
            
            // Trail
            if (DEFAULT_SHOW_TRAIL) {
                localPlayer.trail.push({ 
                    x: localPlayer.x, 
                    y: localPlayer.y, 
                    scaleX: localPlayer.scaleX,
                    scaleY: localPlayer.scaleY,
                    rotation: localPlayer.rotation,
                    alpha: 1 
                });
                
                if (localPlayer.trail.length > 15) {
                    localPlayer.trail.shift();
                }
                
                localPlayer.trail.forEach(t => {
                    t.alpha *= 0.9;
                });
            } else {
                localPlayer.trail = [];
            }
        }
        
        function drawBubble(x, y, scaleX, scaleY, rotation, alpha = 1, color = null, image = null) {
            const radius = DEFAULT_BUBBLE_SIZE;
            
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            ctx.scale(scaleX, scaleY);
            
            // Outer bubble - use custom color if provided, otherwise default
            let gradient;
            let highlightGradient;
            let rimColor;
            let highlightColor;
            
            if (color) {
                // Parse HSL color and create gradient
                const hslMatch = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                if (hslMatch) {
                    const h = parseInt(hslMatch[1]);
                    const s = parseInt(hslMatch[2]);
                    const l = parseInt(hslMatch[3]);
                    
                    // Enhanced radial gradient with more color stops for smoother look (more transparent)
                    const baseAlpha = 0.75 * alpha; // Make bubble more transparent
                    // Center the gradient at the center of the bubble
                    gradient = ctx.createRadialGradient(0, 0, radius * 0.15, 0, 0, radius);
                    gradient.addColorStop(0, `hsla(${h}, ${Math.min(s + 10, 100)}%, ${Math.min(l + 25, 100)}%, ${0.85 * baseAlpha})`);
                    gradient.addColorStop(0.3, `hsla(${h}, ${s}%, ${Math.min(l + 15, 100)}%, ${0.75 * baseAlpha})`);
                    gradient.addColorStop(0.6, `hsla(${h}, ${s}%, ${l}%, ${0.65 * baseAlpha})`);
                    gradient.addColorStop(0.85, `hsla(${h}, ${Math.max(s - 5, 0)}%, ${Math.max(l - 5, 0)}%, ${0.75 * baseAlpha})`);
                    gradient.addColorStop(1, `hsla(${h}, ${Math.max(s - 15, 0)}%, ${Math.max(l - 15, 0)}%, ${0.8 * baseAlpha})`);
                    
                    // Highlight gradient centered (more transparent)
                    highlightGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 0.4);
                    highlightGradient.addColorStop(0, `hsla(${h}, ${Math.min(s + 20, 100)}%, ${Math.min(l + 30, 100)}%, ${0.6 * baseAlpha})`);
                    highlightGradient.addColorStop(0.5, `hsla(${h}, ${s}%, ${Math.min(l + 10, 100)}%, ${0.3 * baseAlpha})`);
                    highlightGradient.addColorStop(1, `hsla(${h}, ${s}%, ${l}%, 0)`);
                    
                    rimColor = `hsla(${h}, ${Math.min(s + 15, 100)}%, ${Math.min(l + 15, 100)}%, ${0.6 * baseAlpha})`;
                    highlightColor = `hsla(${h}, ${Math.min(s + 25, 100)}%, ${Math.min(l + 35, 100)}%, ${0.4 * baseAlpha})`;
                } else {
                    // Fallback to default
                    gradient = ctx.createRadialGradient(-radius * 0.35, -radius * 0.35, radius * 0.15, 0, 0, radius);
                    gradient.addColorStop(0, `rgba(180, 220, 255, ${0.95 * alpha})`);
                    gradient.addColorStop(0.3, `rgba(150, 200, 255, ${0.85 * alpha})`);
                    gradient.addColorStop(0.6, `rgba(100, 150, 255, ${0.75 * alpha})`);
                    gradient.addColorStop(0.85, `rgba(70, 130, 246, ${0.85 * alpha})`);
                    gradient.addColorStop(1, `rgba(59, 130, 246, ${0.9 * alpha})`);
                    
                    highlightGradient = ctx.createRadialGradient(-radius * 0.25, -radius * 0.25, 0, -radius * 0.25, -radius * 0.25, radius * 0.4);
                    highlightGradient.addColorStop(0, `rgba(220, 240, 255, ${0.7 * alpha})`);
                    highlightGradient.addColorStop(0.5, `rgba(180, 220, 255, ${0.4 * alpha})`);
                    highlightGradient.addColorStop(1, `rgba(150, 200, 255, 0)`);
                    
                    rimColor = `rgba(220, 240, 255, ${0.7 * alpha})`;
                    highlightColor = `rgba(240, 250, 255, ${0.5 * alpha})`;
                }
            } else {
                // Enhanced default blue gradient (more transparent)
                const baseAlpha = 0.75 * alpha; // Make bubble more transparent
                // Center the gradient at the center of the bubble
                gradient = ctx.createRadialGradient(0, 0, radius * 0.15, 0, 0, radius);
                gradient.addColorStop(0, `rgba(180, 220, 255, ${0.85 * baseAlpha})`);
                gradient.addColorStop(0.3, `rgba(150, 200, 255, ${0.75 * baseAlpha})`);
                gradient.addColorStop(0.6, `rgba(100, 150, 255, ${0.65 * baseAlpha})`);
                gradient.addColorStop(0.85, `rgba(70, 130, 246, ${0.75 * baseAlpha})`);
                gradient.addColorStop(1, `rgba(59, 130, 246, ${0.8 * baseAlpha})`);
                
                // Highlight gradient centered (more transparent)
                highlightGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 0.4);
                highlightGradient.addColorStop(0, `rgba(220, 240, 255, ${0.6 * baseAlpha})`);
                highlightGradient.addColorStop(0.5, `rgba(180, 220, 255, ${0.3 * baseAlpha})`);
                highlightGradient.addColorStop(1, `rgba(150, 200, 255, 0)`);
                
                rimColor = `rgba(220, 240, 255, ${0.6 * baseAlpha})`;
                highlightColor = `rgba(240, 250, 255, ${0.4 * baseAlpha})`;
            }
            
            // Draw main bubble with enhanced gradient
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw highlight for more 3D bubble effect (centered)
            ctx.fillStyle = highlightGradient;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            // Small highlight spot removed (white dot)
            
            // Enhanced rim with glow effect
            ctx.shadowBlur = 8;
            ctx.shadowColor = rimColor;
            ctx.strokeStyle = rimColor;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, radius - 2, 0, Math.PI * 2);
            ctx.stroke();
            
            // Reset shadow
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            
            // Draw image inside bubble if provided
            if (image) {
                let imgObj = imageCache.get(image);
                if (!imgObj && typeof image === 'string' && image.startsWith('data:')) {
                    imgObj = new Image();
                    imgObj.onload = () => {
                        imageCache.set(image, imgObj);
                    };
                    imgObj.src = image;
                    imageCache.set(image, imgObj);
                }
                
                if (imgObj && imgObj.complete && imgObj.width > 0) {
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    const imgSize = radius * 0.6; // Image size is 60% of bubble radius
                    ctx.beginPath();
                    ctx.arc(0, 0, imgSize / 2, 0, Math.PI * 2);
                    ctx.clip();
                    ctx.drawImage(imgObj, -imgSize / 2, -imgSize / 2, imgSize, imgSize);
                    ctx.restore();
                }
            }
            
            ctx.restore();
        }
        
        function draw(timestamp) {
            // Draw ocean background first
            if (oceanBackground) {
                oceanBackground.update(timestamp || 0);
                oceanBackground.draw(timestamp || 0);
            } else {
                // Fallback: clear canvas if ocean background not initialized
                ctx.fillStyle = '#0a0a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Draw game mode elements (spikes, etc.)
            if (currentGameMode === 'spike_dodge') {
                drawSpikes();
            }
            
            // Draw death particles
            if (deathParticles.length > 0) {
                drawDeathParticles();
            }
            
            // Draw all players (only if visible)
            players.forEach((player, peerId) => {
                // Draw trail
                if (DEFAULT_SHOW_TRAIL && player.trail) {
                    player.trail.forEach(t => {
                        drawBubble(t.x, t.y, t.scaleX, t.scaleY, t.rotation, t.alpha * 0.5, player.color, null);
                    });
                }
                
                // Draw main bubble
                drawBubble(player.x, player.y, player.scaleX, player.scaleY, player.rotation, 1, player.color, player.image);
                
                // Draw velocity vector (only for local player if enabled)
                if (peerId === localPlayerId && DEFAULT_SHOW_VELOCITY && (player.vx !== 0 || player.vy !== 0)) {
                    const velMag = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
                    const velX = (player.vx / velMag) * 100;
                    const velY = (player.vy / velMag) * 100;
                    
                    ctx.strokeStyle = '#00ff88';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(player.x, player.y);
                    ctx.lineTo(player.x + velX, player.y + velY);
                    ctx.stroke();
                    
                    // Arrowhead
                    const angle = Math.atan2(velY, velX);
                    ctx.fillStyle = '#00ff88';
                    ctx.beginPath();
                    ctx.moveTo(player.x + velX, player.y + velY);
                    ctx.lineTo(
                        player.x + velX - 10 * Math.cos(angle - Math.PI / 6),
                        player.y + velY - 10 * Math.sin(angle - Math.PI / 6)
                    );
                    ctx.lineTo(
                        player.x + velX - 10 * Math.cos(angle + Math.PI / 6),
                        player.y + velY - 10 * Math.sin(angle + Math.PI / 6)
                    );
                    ctx.closePath();
                    ctx.fill();
                }
            });
            
            // Update dash indicator light (only for local player)
            const dashIndicator = document.getElementById('dashIndicator');
            if (dashIndicator && localPlayer) {
                if (localPlayer.dashCooldown > 0) {
                    dashIndicator.classList.add('cooldown');
                } else {
                    dashIndicator.classList.remove('cooldown');
                }
            }
        }
        
        function updateRemotePlayers() {
            const now = Date.now();
            const deltaTime = 16; // ~60fps
            
            // Update remote players with interpolation
            players.forEach((player, peerId) => {
                if (peerId === localPlayerId) return; // Skip local player
                
                // Interpolate position for smooth movement
                const timeSinceUpdate = now - player.lastUpdateTime;
                const interpolationFactor = Math.min(timeSinceUpdate / 100, 1); // Cap at 100ms
                
                player.x = lerp(player.x, player.targetX, 0.2);
                player.y = lerp(player.y, player.targetY, 0.2);
                player.vx = lerp(player.vx, player.targetVx, 0.3);
                player.vy = lerp(player.vy, player.targetVy, 0.3);
                
                // Apply velocity to position
                player.x += player.vx * (deltaTime / 16);
                player.y += player.vy * (deltaTime / 16);
                
                // Boundary collision (same as local player)
                const radius = player.baseRadius;
                const bounceDamping = 0.8;
                
                if (player.x - radius < 0) {
                    player.x = radius;
                    player.vx = Math.abs(player.vx) * bounceDamping;
                }
                if (player.x + radius > canvas.width) {
                    player.x = canvas.width - radius;
                    player.vx = -Math.abs(player.vx) * bounceDamping;
                }
                if (player.y - radius < 0) {
                    player.y = radius;
                    player.vy = Math.abs(player.vy) * bounceDamping;
                }
                if (player.y + radius > canvas.height) {
                    player.y = canvas.height - radius;
                    player.vy = -Math.abs(player.vy) * bounceDamping;
                }
                
                // Check collisions with other players (including local player)
                players.forEach((otherPlayer, otherId) => {
                    if (otherId !== peerId && otherPlayer) {
                        resolvePlayerCollisions(player, otherPlayer);
                    }
                });
                
                // Calculate squash and stretch for remote players
                const velocity = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
                const maxVelocity = DEFAULT_MOVE_SPEED * 2;
                const velocityRatio = Math.min(velocity / maxVelocity, 1);
                
                // Stretch intensity: 1 for normal movement, 2 when dashing
                const stretchIntensity = player.isDashing ? 2 : 1;
                
                if (velocity > 0.5) {
                    const angle = Math.atan2(player.vy, player.vx);
                    player.rotation = angle;
                    player.targetScaleX = 1 + (stretchIntensity - 1) * velocityRatio;
                    player.targetScaleY = 1 - (1 - DEFAULT_SQUASH_INTENSITY) * velocityRatio;
                } else {
                    player.targetScaleX = 1;
                    player.targetScaleY = 1;
                    if (DEFAULT_WOBBLE_ON_IDLE) {
                        const wobble = Math.sin(Date.now() * 0.003) * 0.05;
                        player.targetScaleX = 1 + wobble;
                        player.targetScaleY = 1 - wobble;
                    }
                }
                
                const deformSpeed = DEFAULT_DEFORM_SPEED;
                player.scaleX += (player.targetScaleX - player.scaleX) * deformSpeed;
                player.scaleY += (player.targetScaleY - player.scaleY) * deformSpeed;
                
                // Update trail for remote players
                if (DEFAULT_SHOW_TRAIL) {
                    player.trail.push({ 
                        x: player.x, 
                        y: player.y, 
                        scaleX: player.scaleX,
                        scaleY: player.scaleY,
                        rotation: player.rotation,
                        alpha: 1 
                    });
                    
                    if (player.trail.length > 15) {
                        player.trail.shift();
                    }
                    
                    player.trail.forEach(t => {
                        t.alpha *= 0.9;
                    });
                }
            });
        }
        
        function lerp(start, end, factor) {
            return start + (end - start) * factor;
        }
        
        function syncGameState() {
            if (!localPlayer) return;
            
            const now = Date.now();
            
            // High priority sync (position, velocity) - 60fps
            if (now - lastSyncTime >= SYNC_INTERVAL) {
                const state = {
                    type: 'state',
                    id: localPlayerId,
                    x: localPlayer.x,
                    y: localPlayer.y,
                    vx: localPlayer.vx,
                    vy: localPlayer.vy
                };
                
                broadcastToAll(state);
                lastSyncTime = now;
            }
            
            // Medium priority sync (scale, rotation, color, name) - 30fps
            // Note: image is sent separately when it changes, not every frame
            if (now - lastSyncTimeMedium >= SYNC_INTERVAL_MEDIUM) {
                const state = {
                    type: 'state_medium',
                    id: localPlayerId,
                    scaleX: localPlayer.scaleX,
                    scaleY: localPlayer.scaleY,
                    rotation: localPlayer.rotation,
                    isDashing: localPlayer.isDashing,
                    dashCooldown: localPlayer.dashCooldown,
                    color: localPlayer.color, // Sync color to other players
                    name: localPlayer.name // Sync name
                    // image is NOT included here - sent separately via 'image_update' message
                };
                
                broadcastToAll(state);
                lastSyncTimeMedium = now;
            }
        }
        
        function broadcastToAll(data) {
            connections.forEach((conn, peerId) => {
                if (conn.open) {
                    conn.send(data);
                }
            });
        }
        
        let lastTime = 0;
        function gameLoop(timestamp) {
            // Use timestamp from requestAnimationFrame, or calculate delta
            const time = timestamp || (lastTime += 16);
            const deltaTime = time - (lastTime || time);
            lastTime = time;
            
            // Always update game - never pause
            updatePlayer();
            updateRemotePlayers();
            syncGameState();
            
            // Update game modes
            if (currentGameMode === 'spike_dodge') {
                updateSpikeDodge(deltaTime);
            }
            
            draw(time);
            requestAnimationFrame(gameLoop);
        }
        
        function resetPosition() {
            if (localPlayer) {
                localPlayer.x = canvas.width / 2;
                localPlayer.y = canvas.height / 2;
                localPlayer.vx = 0;
                localPlayer.vy = 0;
                localPlayer.scaleX = 1;
                localPlayer.scaleY = 1;
                localPlayer.trail = [];
            }
        }
        
        // Multiplayer functions
        function hostGame() {
            // Exit any game mode when hosting
            if (currentGameMode) {
                currentGameMode = null;
                spikes = [];
            }
            
            roomId = Math.random().toString(36).substring(2, 9);
            localPlayerId = roomId;
            isHost = true;
            
            // Update challenges button visibility
            updateChallengesButtonVisibility();
            
            peer = new Peer(roomId, {
                host: '0.peerjs.com',
                port: 443,
                path: '/',
                secure: true
            });
            
            peer.on('open', (id) => {
                console.log('Host peer opened with ID:', id);
                
                // Remove old local player if it exists
                if (players.has('local')) {
                    players.delete('local');
                }
                
                localPlayerId = id;
                localPlayer = createPlayer(id, true);
                // Apply color from color picker
                const colorPicker = document.getElementById('colorPicker');
                if (colorPicker && localPlayer) {
                    localPlayer.color = hexToHsl(colorPicker.value);
                }
                players.set(id, localPlayer);
                
                document.getElementById('roomIdDisplay').textContent = 'Room ID: ' + id;
                hideAllScreens();
                document.getElementById('gameScreen').classList.add('active');
                updatePlayerList();
            });
            
            peer.on('connection', (conn) => {
                console.log('New connection from:', conn.peer);
                setupConnection(conn);
            });
            
            peer.on('error', (err) => {
                console.error('Peer error:', err);
            });
        }
        
        function joinGame() {
            const inputRoomId = document.getElementById('roomIdInput').value.trim();
            if (!inputRoomId) {
                alert('Please enter a room ID');
                return;
            }
            
            // Save current player position BEFORE attempting connection
            let savedX = null;
            let savedY = null;
            if (localPlayer) {
                savedX = localPlayer.x;
                savedY = localPlayer.y;
            }
            
            roomId = inputRoomId;
            isHost = false;
            
            // Update challenges button visibility
            updateChallengesButtonVisibility();
            
            // Flag to track if connection failed
            let connectionFailed = false;
            
            peer = new Peer({
                host: '0.peerjs.com',
                port: 443,
                path: '/',
                secure: true
            });
            
            peer.on('open', (id) => {
                console.log('Client peer opened with ID:', id);
                
                // Don't proceed if connection already failed
                if (connectionFailed) {
                    return;
                }
                
                // Store the current player position before creating new player
                let savedX = null;
                let savedY = null;
                if (localPlayer) {
                    savedX = localPlayer.x;
                    savedY = localPlayer.y;
                }
                
                // Connect to host - don't create player or show game screen yet, wait for connection
                const conn = peer.connect(roomId);
                
                // Set up connection with error handling
                conn.on('open', () => {
                    // Don't proceed if connection already failed
                    if (connectionFailed) {
                        return;
                    }
                    
                    // Connection successful - NOW create player and set up multiplayer
                    // Remove old local player if it exists
                    if (players.has('local')) {
                        players.delete('local');
                    }
                    
                    localPlayerId = id;
                    localPlayer = createPlayer(id, true);
                    
                    // Restore position if we had one
                    if (savedX !== null && savedY !== null) {
                        localPlayer.x = savedX;
                        localPlayer.y = savedY;
                    }
                    
                    // Apply color from color picker
                    const colorPicker = document.getElementById('colorPicker');
                    if (colorPicker && localPlayer) {
                        localPlayer.color = hexToHsl(colorPicker.value);
                    }
                    players.set(id, localPlayer);
                    
                    // Now show game screen
                    setupConnection(conn);
                    document.getElementById('roomIdDisplay').textContent = 'Room ID: ' + roomId;
                    hideAllScreens();
                    document.getElementById('gameScreen').classList.add('active');
                    updatePlayerList();
                });
                
                conn.on('error', (err) => {
                    console.error('Connection error:', err);
                    connectionFailed = true;
                    
                    // Close the connection
                    if (conn && !conn.destroyed) {
                        conn.close();
                    }
                    
                    // Clean up on connection error
                    if (peer) {
                        peer.destroy();
                        peer = null;
                    }
                    roomId = null;
                    isHost = false;
                    
                    // Don't reset player - restore original local player with saved position
                    // Just clear multiplayer state
                    if (localPlayerId && localPlayerId !== 'local') {
                        players.delete(localPlayerId);
                    }
                    connections.clear();
                    
                    // Restore to single player mode - use saved position from before connection attempt
                    localPlayerId = 'local';
                    localPlayer = createPlayer('local', true);
                    
                    // Restore position
                    if (savedX !== null && savedY !== null) {
                        localPlayer.x = savedX;
                        localPlayer.y = savedY;
                    }
                    
                    const colorPicker = document.getElementById('colorPicker');
                    if (colorPicker && localPlayer) {
                        localPlayer.color = hexToHsl(colorPicker.value);
                    }
                    players.set('local', localPlayer);
                    
                    // Show error and return to join screen
                    alert('Room ID not found. Please check the room ID and try again.');
                    showJoinScreen();
                });
                
                // Also handle connection close (room might have closed)
                conn.on('close', () => {
                    console.log('Connection closed - room may not exist');
                    
                    // Only show error if we haven't successfully connected
                    if (!connections.has(conn.peer) && !connectionFailed) {
                        connectionFailed = true;
                        
                        // Clean up on connection close
                        if (peer) {
                            peer.destroy();
                            peer = null;
                        }
                        roomId = null;
                        isHost = false;
                        
                        // Don't reset player - restore original local player with saved position
                        // Just clear multiplayer state
                        if (localPlayerId && localPlayerId !== 'local') {
                            players.delete(localPlayerId);
                        }
                        connections.clear();
                        
                        // Restore to single player mode - use saved position from before connection attempt
                        localPlayerId = 'local';
                        localPlayer = createPlayer('local', true);
                        
                        // Restore position
                        if (savedX !== null && savedY !== null) {
                            localPlayer.x = savedX;
                            localPlayer.y = savedY;
                        }
                        
                        const colorPicker = document.getElementById('colorPicker');
                        if (colorPicker && localPlayer) {
                            localPlayer.color = hexToHsl(colorPicker.value);
                        }
                        players.set('local', localPlayer);
                        
                        alert('Room ID not found. Please check the room ID and try again.');
                        showJoinScreen();
                    }
                });
            });
            
            peer.on('error', (err) => {
                console.error('Peer error:', err);
                connectionFailed = true;
                
                // Clean up on peer error
                if (peer) {
                    peer.destroy();
                    peer = null;
                }
                roomId = null;
                isHost = false;
                
                // Don't reset player - restore original local player with saved position
                // Just clear multiplayer state
                if (localPlayerId && localPlayerId !== 'local') {
                    players.delete(localPlayerId);
                }
                connections.clear();
                
                // Restore to single player mode - use saved position from before connection attempt
                localPlayerId = 'local';
                localPlayer = createPlayer('local', true);
                
                // Restore position
                if (savedX !== null && savedY !== null) {
                    localPlayer.x = savedX;
                    localPlayer.y = savedY;
                }
                
                const colorPicker = document.getElementById('colorPicker');
                if (colorPicker && localPlayer) {
                    localPlayer.color = hexToHsl(colorPicker.value);
                }
                players.set('local', localPlayer);
                
                // Show error message
                if (err.type === 'peer-unavailable') {
                    alert('Room ID not found. Please check the room ID and try again.');
                } else {
                    alert('Failed to connect. Please try again.');
                }
                showJoinScreen();
            });
        }
        
        function setupConnection(conn) {
            // Connection is already open when this is called from joinGame
            console.log('Setting up connection with:', conn.peer);
            connections.set(conn.peer, conn);
            
            // Send initial state to new connection
            if (localPlayer) {
                conn.send({
                    type: 'state',
                    id: localPlayerId,
                    x: localPlayer.x,
                    y: localPlayer.y,
                    vx: localPlayer.vx,
                    vy: localPlayer.vy
                });
                conn.send({
                    type: 'state_medium',
                    id: localPlayerId,
                    scaleX: localPlayer.scaleX,
                    scaleY: localPlayer.scaleY,
                    rotation: localPlayer.rotation,
                    isDashing: localPlayer.isDashing,
                    dashCooldown: localPlayer.dashCooldown,
                    color: localPlayer.color, // Send color to new connection
                    name: localPlayer.name // Send name to new connection
                });
                
                // Send image separately if it exists (to avoid large messages)
                if (localPlayer.image) {
                    conn.send({
                        type: 'image_update',
                        id: localPlayerId,
                        image: localPlayer.image
                    });
                }
            }
            
            // If we're the host, also connect this new player to existing players
            if (isHost) {
                connections.forEach((existingConn, peerId) => {
                    if (peerId !== conn.peer && existingConn.open) {
                        // Tell existing player about new player
                        existingConn.send({
                            type: 'new_player',
                            id: conn.peer
                        });
                        // Tell new player about existing player
                        conn.send({
                            type: 'new_player',
                            id: peerId
                        });
                    }
                });
            }
            
            updatePlayerList();
            
            conn.on('data', (data) => {
                handleNetworkData(data, conn.peer);
            });
            
            conn.on('close', () => {
                console.log('Connection closed with:', conn.peer);
                connections.delete(conn.peer);
                players.delete(conn.peer);
                updatePlayerList();
            });
            
            conn.on('error', (err) => {
                console.error('Connection error:', err);
            });
        }
        
        function handleNetworkData(data, peerId) {
            if (!data || !data.id) return;
            
            let player = players.get(data.id);
            
            if (data.type === 'state') {
                // High priority state update
                if (!player) {
                    player = createPlayer(data.id, false);
                    players.set(data.id, player);
                }
                
                player.targetX = data.x;
                player.targetY = data.y;
                player.targetVx = data.vx;
                player.targetVy = data.vy;
                player.lastUpdateTime = Date.now();
            } else if (data.type === 'state_medium') {
                // Medium priority state update
                if (!player) {
                    player = createPlayer(data.id, false);
                    players.set(data.id, player);
                }
                
                player.scaleX = data.scaleX;
                player.scaleY = data.scaleY;
                player.rotation = data.rotation;
                player.isDashing = data.isDashing;
                player.dashCooldown = data.dashCooldown;
                // Update color if provided
                if (data.color) {
                    player.color = data.color;
                }
                // Update name if provided
                if (data.name !== undefined) {
                    player.name = data.name;
                }
            } else if (data.type === 'image_update') {
                // Separate message type for image updates (to handle large data)
                if (!player) {
                    player = createPlayer(data.id, false);
                    players.set(data.id, player);
                }
                if (data.image !== undefined) {
                    player.image = data.image;
                }
            } else if (data.type === 'new_player') {
                // Another player joined - if we're not host, we might want to connect to them too
                // For now, just acknowledge
                console.log('New player in room:', data.id);
            }
        }
        
        function updatePlayerList() {
            const playerListEl = document.getElementById('playerList');
            if (!playerListEl) return;
            
                playerListEl.innerHTML = '<strong>Players (' + players.size + '):</strong><br>';
            players.forEach((player, peerId) => {
                const isLocal = peerId === localPlayerId;
                const statusClass = isLocal ? 'connected' : '';
                const displayName = player.name || `Player ${peerId.substring(0, 6)}`;
                playerListEl.innerHTML += `
                    <div class="player-list-item">
                        <span class="connection-status ${statusClass}"></span>
                        ${displayName}${isLocal ? ' (You)' : ''}
                    </div>
                `;
            });
        }
        
        function leaveGame() {
            // Close all connections
            connections.forEach((conn) => {
                conn.close();
            });
            connections.clear();
            
            // Close peer
            if (peer) {
                peer.destroy();
                peer = null;
            }
            
            // Clear players (keep local player for single player mode)
            players.clear();
            localPlayer = null;
            localPlayerId = null;
            isHost = false;
            roomId = null;
            
            // Exit any game mode when leaving
            if (currentGameMode) {
                currentGameMode = null;
                spikes = [];
            }
            
            // Update challenges button visibility
            updateChallengesButtonVisibility();
            
            // Recreate local player for single player
            localPlayerId = 'local';
            localPlayer = createPlayer('local', true);
            // Reset color from color picker
            const colorPicker = document.getElementById('colorPicker');
            if (colorPicker && localPlayer) {
                localPlayer.color = hexToHsl(colorPicker.value);
            }
            players.set('local', localPlayer);
            
            // Show main menu
            showMainMenu();
            updatePlayerList();
        }
        
        // Circular Health Bar Class
        class CircularHealthBar {
            constructor(containerId, options = {}) {
                // Configuration
                this.maxHealth = options.maxHealth || 100;
                this.currentHealth = options.currentHealth || this.maxHealth;
                this.radius = options.radius || 60;
                this.lineWidth = options.lineWidth || 12;
                this.glowSize = 20; // Size of the glow effect
                // Add extra padding for glow effect to prevent cutoff
                this.size = (this.radius + this.lineWidth + this.glowSize) * 2;
                
                // Colors
                this.bgColor = options.bgColor || '#1a1a2e';
                this.startColor = options.startColor || '#667eea';
                this.endColor = options.endColor || '#764ba2';
                this.glowColor = options.glowColor || '#667eea';
                
                // Animation
                this.animationDuration = options.animationDuration || 300; // ms
                this.animationStartTime = null;
                this.animationStartHealth = this.currentHealth;
                this.animationTargetHealth = this.currentHealth;
                this.isAnimating = false;
                
                // Create elements
                this.container = document.getElementById(containerId);
                this.container.className = 'health-bar-circular';
                this.container.style.width = this.size + 'px';
                this.container.style.height = this.size + 'px';
                
                // Create canvas
                this.canvas = document.createElement('canvas');
                this.canvas.width = this.size;
                this.canvas.height = this.size;
                this.ctx = this.canvas.getContext('2d');
                this.container.appendChild(this.canvas);
                
                // Create text overlay
                this.textContainer = document.createElement('div');
                this.textContainer.className = 'health-text';
                this.textContainer.innerHTML = `
                    <div class="health-value">${Math.round(this.currentHealth)}</div>
                    <div class="health-label">HP</div>
                `;
                this.container.appendChild(this.textContainer);
                
                // Initial draw
                this.draw();
            }
            
            draw() {
                const ctx = this.ctx;
                const centerX = this.size / 2;
                const centerY = this.size / 2;
                
                // Clear canvas
                ctx.clearRect(0, 0, this.size, this.size);
                
                // Calculate percentage
                const percentage = this.currentHealth / this.maxHealth;
                const endAngle = Math.PI * 2 * percentage;
                
                // Background circle removed - no box around health bar
                
                if (percentage > 0) {
                    // Draw health arc with gradient
                    const gradient = ctx.createLinearGradient(
                        centerX - this.radius, 
                        centerY, 
                        centerX + this.radius, 
                        centerY
                    );
                    gradient.addColorStop(0, this.startColor);
                    gradient.addColorStop(1, this.endColor);
                    
                    // Set glow effect
                    ctx.shadowBlur = this.glowSize;
                    ctx.shadowColor = this.glowColor;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, this.radius, -Math.PI / 2, -Math.PI / 2 + endAngle);
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = this.lineWidth;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                    
                    // Reset shadow
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                }
            }
            
            updateText() {
                const healthValue = this.textContainer.querySelector('.health-value');
                healthValue.textContent = Math.round(this.currentHealth);
                
                // Color based on health percentage
                const percentage = this.currentHealth / this.maxHealth;
                if (percentage > 0.5) {
                    healthValue.style.textShadow = '0 0 10px rgba(102, 126, 234, 0.8)';
                } else if (percentage > 0.25) {
                    healthValue.style.textShadow = '0 0 10px rgba(255, 200, 0, 0.8)';
                } else {
                    healthValue.style.textShadow = '0 0 10px rgba(255, 100, 100, 0.8)';
                }
            }
            
            animate(timestamp) {
                if (!this.animationStartTime) {
                    this.animationStartTime = timestamp;
                }
                
                const elapsed = timestamp - this.animationStartTime;
                const progress = Math.min(elapsed / this.animationDuration, 1);
                
                // Easing function (ease out)
                const eased = 1 - Math.pow(1 - progress, 3);
                
                // Interpolate health
                this.currentHealth = this.animationStartHealth + 
                    (this.animationTargetHealth - this.animationStartHealth) * eased;
                
                this.draw();
                this.updateText();
                
                if (progress < 1) {
                    requestAnimationFrame((t) => this.animate(t));
                } else {
                    this.currentHealth = this.animationTargetHealth;
                    this.isAnimating = false;
                    this.animationStartTime = null;
                }
            }
            
            setHealth(value, animate = true) {
                const newHealth = Math.max(0, Math.min(this.maxHealth, value));
                
                if (animate) {
                    this.animationStartHealth = this.currentHealth;
                    this.animationTargetHealth = newHealth;
                    
                    if (!this.isAnimating) {
                        this.isAnimating = true;
                        requestAnimationFrame((t) => this.animate(t));
                    }
                } else {
                    this.currentHealth = newHealth;
                    this.draw();
                    this.updateText();
                }
                
                // Check for death
                if (this.currentHealth <= 0 && !playerDead) {
                    playerDead = true;
                    if (localPlayer) {
                        localPlayer.dead = true;
                    }
                    triggerDeathEffect();
                    
                    // Check for match victory in VS modes
                    if (matchInProgress && (queueMode === '1v1' || queueMode === '2v2')) {
                        setTimeout(() => checkMatchVictory(), 500);
                    }
                }
            }
            
            takeDamage(amount) {
                this.setHealth(this.currentHealth - amount);
            }
            
            heal(amount) {
                this.setHealth(this.currentHealth + amount);
            }
            
            // Get current health percentage (useful for game logic)
            getPercentage() {
                return this.currentHealth / this.maxHealth;
            }
            
            // Change colors dynamically
            setColors(startColor, endColor, glowColor) {
                this.startColor = startColor;
                this.endColor = endColor;
                if (glowColor) this.glowColor = glowColor;
                this.draw();
            }
        }
        
        // Create health bar instance
        const healthBar = new CircularHealthBar('healthBar', {
            maxHealth: 100,
            currentHealth: 100,
            radius: 60,
            lineWidth: 12,
            startColor: '#667eea',
            endColor: '#764ba2',
            glowColor: '#667eea'
        });
        
        // Store health bar globally for scaling
        window.healthBar = healthBar;
        
        // Setup color picker first (before creating player)
        const colorPicker = document.getElementById('colorPicker');
        if (colorPicker) {
            // Load saved color from localStorage
            try {
                const savedColor = localStorage.getItem('playerColor');
                if (savedColor) {
                    colorPicker.value = savedColor;
                }
            } catch (e) {
                console.warn('Could not load color from localStorage:', e);
            }
            
            // Update color when picker changes
            colorPicker.addEventListener('input', (e) => {
                updatePlayerColor(e.target.value);
            });
        }
        
        // Setup name input
        const nameInput = document.getElementById('playerNameInput');
        if (nameInput) {
            nameInput.addEventListener('input', (e) => {
                if (localPlayer) {
                    localPlayer.name = e.target.value.trim() || null;
                    // Save to localStorage
                    try {
                        if (localPlayer.name) {
                            localStorage.setItem('playerName', localPlayer.name);
                        } else {
                            localStorage.removeItem('playerName');
                        }
                    } catch (err) {
                        console.warn('Could not save name to localStorage:', err);
                    }
                    // Update in players map
                    if (localPlayerId) {
                        players.set(localPlayerId, localPlayer);
                    }
                    // Broadcast name change immediately
                    if (connections.size > 0) {
                        const nameState = {
                            type: 'state_medium',
                            id: localPlayerId,
                            scaleX: localPlayer.scaleX,
                            scaleY: localPlayer.scaleY,
                            rotation: localPlayer.rotation,
                            isDashing: localPlayer.isDashing,
                            dashCooldown: localPlayer.dashCooldown,
                            color: localPlayer.color,
                            name: localPlayer.name
                        };
                        broadcastToAll(nameState);
                    }
                }
            });
        }
        
        // Setup image upload
        const imageInput = document.getElementById('actorImageInput');
        if (imageInput) {
            imageInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    // Resize and compress image before sending
                    const maxSize = 200; // Max width/height in pixels
                    const maxFileSize = 50000; // Max file size in bytes (50KB)
                    
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            // Create canvas to resize image
                            const canvas = document.createElement('canvas');
                            let width = img.width;
                            let height = img.height;
                            
                            // Resize if too large
                            if (width > maxSize || height > maxSize) {
                                if (width > height) {
                                    height = (height / width) * maxSize;
                                    width = maxSize;
                                } else {
                                    width = (width / height) * maxSize;
                                    height = maxSize;
                                }
                            }
                            
                            canvas.width = width;
                            canvas.height = height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, width, height);
                            
                            // Convert to data URL with compression
                            let imageData = canvas.toDataURL('image/jpeg', 0.7); // 70% quality
                            
                            // If still too large, reduce quality further
                            if (imageData.length > maxFileSize) {
                                imageData = canvas.toDataURL('image/jpeg', 0.5); // 50% quality
                            }
                            
                            if (imageData.length > maxFileSize) {
                                imageData = canvas.toDataURL('image/jpeg', 0.3); // 30% quality
                            }
                            
                            if (localPlayer) {
                                localPlayer.image = imageData;
                                // Save to localStorage
                                try {
                                    localStorage.setItem('playerImage', imageData);
                                } catch (err) {
                                    console.warn('Could not save image to localStorage:', err);
                                }
                                // Update in players map
                                if (localPlayerId) {
                                    players.set(localPlayerId, localPlayer);
                                }
                                updateImagePreview();
                                // Broadcast image change immediately using separate message type
                                if (connections.size > 0) {
                                    const imageState = {
                                        type: 'image_update',
                                        id: localPlayerId,
                                        image: localPlayer.image
                                    };
                                    broadcastToAll(imageState);
                                }
                            }
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            });
        }
        
        // Initialize local player for single player mode
        localPlayerId = 'local';
        localPlayer = createPlayer('local', true);
        // Set color from saved preference or color picker default
        const defaultColorPicker = document.getElementById('colorPicker');
        if (defaultColorPicker && localPlayer) {
            localPlayer.color = hexToHsl(defaultColorPicker.value);
        }
        players.set('local', localPlayer);
        
        // Initialize ocean background (after canvas is resized)
        if (canvas.width > 0 && canvas.height > 0) {
            oceanBackground = new OceanComplete(canvas);
        } else {
            // If canvas not ready, initialize on next frame
            setTimeout(() => {
                if (canvas.width > 0 && canvas.height > 0) {
                    oceanBackground = new OceanComplete(canvas);
                }
            }, 100);
        }
        
        // Start game loop
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>

